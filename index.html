<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/2356874721.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/2356874721.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/2356874721.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/2356874721.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/2356874721.github.io/css/main.css">


<link rel="stylesheet" href="/2356874721.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/2356874721.github.io/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="警长的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="警长的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="sheriff">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>警长的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/2356874721.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">警长的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录生活 记录成长</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/2356874721.github.io/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/2356874721.github.io/archives/" rel="section"><i class="archives fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/2356874721.github.io/categories/" rel="section"><i class="categories fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/2356874721.github.io/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/2356874721.github.io/about/" rel="section"><i class="about fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/30/http-05/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/2356874721.github.io/images/avatar.gif">
      <meta itemprop="name" content="sheriff">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="警长的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2356874721.github.io/2021/03/30/http-05/" class="post-title-link" itemprop="url">05 | 常说的“四层”和“七层”到底是什么？“五层”“六层”哪去了？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-30 21:40:06 / 修改时间：21:45:41" itemprop="dateCreated datePublished" datetime="2021-03-30T21:40:06+08:00">2021-03-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/2356874721.github.io/categories/HTTP/" itemprop="url" rel="index"><span itemprop="name">HTTP</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在工作中你一定经常听别人谈起什么“四层负载均衡”“七层负载均衡”，什么“二层转发”“三层路由”，那么你真正理解这些层次的含义吗？</p>
<p>网络分层的知识教科书上都有，但很多都是“泛泛而谈”，只有“学术价值”，于是就容易和实际应用“脱节”，造成的后果就是“似懂非懂”，真正用的时候往往会“一头雾水”。所以，今天我就从 HTTP 应用的角度，帮你把这些模糊的概念弄清楚。</p>
<h3 id="TCP-IP-网络分层模型"><a href="#TCP-IP-网络分层模型" class="headerlink" title="TCP/IP 网络分层模型"></a>TCP/IP 网络分层模型</h3><p>还是先从 TCP/IP 协议开始讲起，一是因为它非常经典，二是因为它是目前事实上的网络通信标准，研究它的实用价值最大。</p>
<p>TCP/IP 当初的设计者真的是非常聪明，创造性地提出了“<strong>分层</strong>”的概念，把复杂的网络通信划分出多个层次，再给每一个层次分配不同的职责，层次内只专心做自己的事情就好，用“分而治之”的思想把一个“大麻烦”拆分成了数个“小麻烦”，从而解决了网络通信的难题。你应该对 TCP/IP 的协议栈有所了解吧，这里我再贴一下层次图。</p>
<img src="/2356874721.github.io/2021/03/30/http-05/5-1.png" class>

<p><strong>TCP/IP 协议总共有四层</strong>，就像搭积木一样，每一层需要下层的支撑，同时又支撑着上层，任何一层被抽掉都可能会导致整个协议栈坍塌。我们来仔细地看一下这个精巧的积木架构，注意<strong>它的层次顺序是“从下往上”数的</strong>，所以<strong>第一层就是最下面的一层</strong>。</p>
<p>第一层叫“<strong>链接层</strong>”（link layer），负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在<strong>网卡</strong>这个层次，使用 <strong>MAC 地址来标记网络上的设备</strong>，所以有时候也叫 <strong>MAC 层</strong>。</p>
<p>第二层叫“<strong>网际层</strong>”或者“<strong>网络互连层</strong>”（internet layer），IP 协议就处在这一层。因为 IP 协议定义了“IP 地址”的概念，所以就可以<strong>在“链接层”的基础上，用 IP 地址取代 MAC 地址，把许许多多的局域网、广域网连接成一个虚拟的巨大网络，在这个网络里找设备时只要把 IP 地址再“翻译”成 MAC 地址就可以了</strong>。</p>
<p>第三层叫“<strong>传输层</strong>”（transport layer），这个层次协议的<strong>职责是保证数据在 IP 地址标记的两点之间“可靠”地传输</strong>，是 <strong>TCP</strong> 协议工作的层次，另外还有它的一个“小伙伴”UDP。TCP 是一个<strong>有状态</strong>的协议，需要<strong>先与对方建立连接然后才能发送数据</strong>，而且<strong>保证数据不丢失不重复</strong>。而 <strong>UDP</strong> 则比较简单，它<strong>无状态</strong>，<strong>不用事先建立连接就可以任意发送数据，但不保证数据一定会发到对方</strong>。两个协议的另一个重要区别在于数据的形式。TCP 的数据是<strong>连续</strong>的“<strong>字节流</strong>”，有<strong>先后顺序</strong>，而 UDP 则是<strong>分散的小数据包</strong>，是<strong>顺序发</strong>，<strong>乱序收</strong>。</p>
<p>关于 TCP 和 UDP 可以展开讨论的话题还有很多，比如最经典的“<strong>三次握手</strong>”和“<strong>四次挥手</strong>”，一时半会很难说完，好在与 HTTP 的关系不是太大，以后遇到了再详细讲解。</p>
<p>第四层叫“<strong>应用层</strong>”（application layer），由于下面的三层把基础打得非常好，所以在这一层就“百花齐放”了，<strong>有各种面向具体应用的协议</strong>。例如 Telnet、SSH、FTP、SMTP 等等，当然还有我们的 HTTP。</p>
<p><strong><u>MAC 层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。</u></strong></p>
<h3 id="OSI-网络分层模型"><a href="#OSI-网络分层模型" class="headerlink" title="OSI 网络分层模型"></a>OSI 网络分层模型</h3><p>看完 TCP/IP 协议栈，你可能要问了，“它只有四层，那常说的七层怎么没见到呢？”</p>
<p>别着急，这就是今天要说的第二个网络分层模型：<strong>OSI，全称是“开放式系统互联通信参考模型”（Open System Interconnection Reference Model）</strong>。</p>
<p>TCP/IP 发明于 1970 年代，当时除了它还有很多其他的网络协议，整个网络世界比较混乱。这个时候国际标准组织（ISO）注意到了这种现象，感觉“野路子”太多，就想要来个“大一统”。于是设计出了一个新的网络分层模型，想用这个新框架来统一既存的各种网络协议。</p>
<p>OSI 模型分成了七层，部分层次与 TCP/IP 很像，从下到上分别是：</p>
<img src="/2356874721.github.io/2021/03/30/http-05/5-2.png" class>

<p>第一层：<strong>物理层</strong>，网络的物理形式，例如电缆、光纤、网卡、集线器等等；</p>
<p>第二层：<strong>数据链路层</strong>，它基本相当于 TCP/IP 的<strong>链接层</strong>；</p>
<p>第三层：<strong>网络层</strong>，相当于 TCP/IP 里的<strong>网际层</strong>；</p>
<p>第四层：<strong>传输层</strong>，相当于 TCP/IP 里的<strong>传输层</strong>；</p>
<p>第五层：<strong>会话层</strong>，维护网络中的连接状态，即保持会话和同步；</p>
<p>第六层：<strong>表示层</strong>，把数据转换为合适、可理解的语法和语义；</p>
<p>第七层：<strong>应用层</strong>，面向具体的应用传输数据。</p>
<p>至此，我们常说的“四层”“七层”就出现了。不过国际标准组织心里也很清楚，TCP/IP 等协议已经在许多网络上实际运行，再推翻重来是不可能的。所以，OSI 分层模型在发布的时候就明确地表明是一个“参考”，不是强制标准，意思就是说，“你们以后该干什么还干什么，我不管，但面子上还是要按照我说的来”。</p>
<p>但 OSI 模型也是有优点的。对比一下就可以看出，TCP/IP 是一个纯软件的栈，没有网络应有的最根基的电缆、网卡等物理设备的位置。而 OSI 则补足了这个缺失<strong>，在理论层面上描述网络更加完整</strong>。</p>
<p>还有一个重要的形式上的优点：OSI 为每一层标记了明确了编号，最底层是一层，最上层是七层，而 TCP/IP 的层次从来只有名字而没有编号。显然，在交流的时候说“七层”要比“应用层”更简单快捷，特别是英文，对比一下“Layer seven”与“application layer”。</p>
<p>综合以上几点，在 OSI 模型之后，“四层”“七层”这样的说法就逐渐流行开了。不过在实际工作中你一定要注意，这种说法只是“理论上”的层次，并不是与现实完全对应。</p>
<h3 id="两个分层模型的映射关系"><a href="#两个分层模型的映射关系" class="headerlink" title="两个分层模型的映射关系"></a>两个分层模型的映射关系</h3><p>现在我们有了两个网络分层模型：TCP/IP 和 OSI，新的问题又出现了，一个是四层模型，一个是七层模型，这两者应该如何互相映射或者说互相解释呢？好在 OSI 在设计之初就参考了 TCP/IP 等多个协议，可以比较容易但不是很精确地实现对应关系。</p>
<img src="/2356874721.github.io/2021/03/30/http-05/5-3.png" class>

<p>第一层：物理层，TCP/IP 里无对应；</p>
<p>第二层：<strong>数据链路层</strong>，对应 TCP/IP 的<strong>链接层</strong>；</p>
<p>第三层：<strong>网络层</strong>，对应 TCP/IP 的<strong>网际层</strong>；</p>
<p>第四层：<strong>传输层</strong>，对应 TCP/IP 的<strong>传输层</strong>；</p>
<p>第五、六、七层：统一对应到 TCP/IP 的<strong>应用层</strong>。</p>
<p>所以你看，这就是“理想与现实”之间的矛盾。理想很美好，有七层，但现实很残酷，只有四层，“多余”的五层、六层就这样“消失”了。</p>
<p>但这也有一定的实际原因。<strong>OSI 的分层模型在四层以上分的太细，而 TCP/IP 实际应用时的会话管理、编码转换、压缩等和具体应用经常联系的很紧密，很难分开</strong>。例如，HTTP 协议就同时包含了连接管理和数据格式定义。</p>
<p>到这里，你应该能够明白一开始那些“某某层”的概念了。</p>
<p>所谓的“<strong>四层负载均衡</strong>”就是指工作在<strong>传输层</strong>上，基于 TCP/IP 协议的特性，例如 IP 地址、端口号等实现对后端服务器的负载均衡。</p>
<p>所谓的“<strong>七层负载均衡</strong>”就是指工作在<strong>应用层</strong>上，看到的是 HTTP 协议，解析 HTTP 报文里的 URI、主机名、资源类型等数据，再用适当的策略转发给后端服务器。</p>
<h3 id="TCP-IP-协议栈的工作方式"><a href="#TCP-IP-协议栈的工作方式" class="headerlink" title="TCP/IP 协议栈的工作方式"></a>TCP/IP 协议栈的工作方式</h3><p>TCP/IP 协议栈是如何工作的呢？你可以把 HTTP 利用 TCP/IP 协议栈传输数据想象成一个发快递的过程。</p>
<p>假设你想把一件毛绒玩具送给朋友，但你要先拿个塑料袋套一下，这件玩具就相当于 HTTP 协议里要传输的内容，比如 HTML，然后 HTTP 协议为它加一个 HTTP 专用附加数据。</p>
<p>你把玩具交给快递小哥，为了保护货物，他又加了层包装再贴了个标签，相当于在 TCP 层给数据再次打包，加上了 TCP 头。</p>
<p>接着快递小哥下楼，把包裹放进了三轮车里，运到集散点，然后再装进更大的卡车里，相当于在 IP 层、MAC 层对 TCP 数据包加上了 IP 头、MAC 头。</p>
<p>之后经过漫长的运输，包裹到达目的地，要卸货再放进另一位快递员的三轮车，就是在 IP 层、MAC 层传输后拆包。</p>
<p>快递员到了你朋友的家门口，撕掉标签，去除了 TCP 层的头，你朋友再拆掉塑料袋包装，也就是 HTTP 头，最后就拿到了玩具，也就是真正的 HTML 页面。</p>
<p>这个比喻里省略了很多 TCP/IP 协议里的细节，比如建连、路由、数据切分与重组、错误检查等，但核心的数据传输过程是差不多的。</p>
<p><strong><u>HTTP 协议的传输过程就是这样通过协议栈逐层向下，每一层都添加本层的专有数据，层层打包，然后通过下层发送出去。</u></strong></p>
<p><strong><u>接收数据则是相反的操作，从下往上穿过协议栈，逐层拆包，每层去掉本层的专有头，上层就会拿到自己的数据。</u></strong></p>
<p><strong>但下层的传输过程对于上层是完全“透明”的，上层也不需要关心下层的具体实现细节</strong>，所以就 HTTP 层次来看，它不管下层是不是 TCP/IP 协议，看到的只是一个可靠的传输链路，只要把数据加上自己的头，对方就能原样收到。</p>
<p>我为这个过程画了一张图，你可以对照着加深理解。</p>
<img src="/2356874721.github.io/2021/03/30/http-05/5-4.png" class>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这次我们学习了 HTTP 所在的网络分层模型，它是工作中常用的交流语言，在这里简单小结一下今天的内容。</p>
<ol>
<li>TCP/IP 分为四层，核心是二层的 IP 和三层的 TCP，HTTP 在第四层；</li>
<li>OSI 分为七层，基本对应 TCP/IP，TCP 在第四层，HTTP 在第七层；</li>
<li>OSI 可以映射到 TCP/IP，但这期间一、五、六层消失了；</li>
<li>日常交流的时候我们通常使用 OSI 模型，用四层、七层等术语；</li>
<li>HTTP 利用 TCP/IP 协议栈逐层打包再拆包，实现了数据传输，但下面的细节并不可见。</li>
<li>有一个辨别四层和七层比较好的（但不是绝对的）小窍门，“两个凡是”：<strong>凡是由操作系统负责处理的就是四层或四层以下，否则，凡是需要由应用程序（也就是你自己写代码）负责处理的就是七层。</strong></li>
</ol>
<h3 id="课下作业"><a href="#课下作业" class="headerlink" title="课下作业"></a>课下作业</h3><ol>
<li><p>你能用自己的话解释一下“二层转发”“三层路由”吗？</p>
<p>二层转发：二层应该指数据链路层，工作在二层的设备，通过查找到目标MAC地址，进行数据转发；</p>
<p>三层路由：三层应该指网络层，工作在三层的设备，通过解析数据包头信息，找到目标IP地址，转发数据</p>
</li>
<li><p>你认为上一讲中的 DNS 协议位于哪一层呢？</p>
<p>应用层</p>
</li>
<li><p>你认为 CDN 工作在那一层呢？</p>
<p>应用层</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/30/http-04/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/2356874721.github.io/images/avatar.gif">
      <meta itemprop="name" content="sheriff">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="警长的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2356874721.github.io/2021/03/30/http-04/" class="post-title-link" itemprop="url">04 | HTTP世界全览（下）：与HTTP相关的各种协议</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-30 21:40:03 / 修改时间：21:45:49" itemprop="dateCreated datePublished" datetime="2021-03-30T21:40:03+08:00">2021-03-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/2356874721.github.io/categories/HTTP/" itemprop="url" rel="index"><span itemprop="name">HTTP</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在上一讲中，我介绍了与 HTTP 相关的浏览器、服务器、CDN、网络爬虫等应用技术。今天要讲的则是比较偏向于理论的各种 HTTP 相关协议，重点是 TCP/IP、DNS、URI、HTTPS 等，希望能够帮你理清楚它们与 HTTP 的关系。</p>
<img src="/2356874721.github.io/2021/03/30/http-04/4-1.png" class>

<h3 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h3><p>TCP/IP 协议实际上是<strong>一系列网络通信协议的统称</strong>，其中最核心的两个协议是 TCP 和 IP，其他的还有 <strong>UDP、ICMP、ARP</strong> 等等，共同构成了一个复杂但有层次的协议栈。</p>
<p>这个协议栈有<strong>四层，最上层是“应用层”，最下层是“链接层”</strong>，TCP 和 IP 则在中间：TCP 属于“<strong>传输层</strong>”，IP 属于“<strong>网际层</strong>”。协议的层级关系模型非常重要，我会在下一讲中再专门讲解，这里先暂时放一放。</p>
<p><strong><u>IP 协议是“Internet Protocol”的缩写，主要目的是解决寻址和路由问题，以及如何在两点间传送数据包。</u></strong>IP 协议使用“<strong>IP 地址</strong>”的概念来定位互联网上的每一台计算机。可以对比一下现实中的电话系统，你拿着的手机相当于互联网上的计算机，而要打电话就必须接入电话网，由通信公司给你分配一个号码，这个号码就相当于 IP 地址。</p>
<p>现在我们使用的 IP 协议大多数是 v4 版，地址是四个用“.”分隔的数字，例如“192.168.0.1”，总共有 2^32，大约 42 亿个可以分配的地址。看上去好像很多，但互联网的快速发展让地址的分配管理很快就“捉襟见肘”。所以，就又出现了 v6 版，使用 8 组“:”分隔的数字作为地址，容量扩大了很多，有 2^128 个，在未来的几十年里应该是足够用了。</p>
<p><strong><u>TCP 协议是“Transmission Control Protocol”的缩写，意思是“传输控制协议”，它位于 IP 协议之上，基于 IP 协议提供可靠的、字节流形式的通信，是 HTTP 协议得以实现的基础。</u></strong></p>
<p><strong>“可靠”是指保证数据不丢失，“字节流”是指保证数据完整</strong>，<strong>所以在 TCP 协议的两端可以如同操作文件一样访问传输的数据，就像是读写在一个密闭的管道里“流动”的字节。</strong></p>
<p><strong>HTTP 是一个”传输协议”，但它不关心寻址、路由、数据完整性等传输细节，而要求这些工作都由下层来处理</strong>。因为互联网上最流行的是 TCP/IP 协议，而它刚好满足 HTTP 的要求，所以互联网上的 HTTP 协议就运行在了 TCP/IP 上，HTTP 也就可以更准确地称为“<strong>HTTP over TCP/IP</strong>”。</p>
<h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>在 TCP/IP 协议中使用 IP 地址来标识计算机，数字形式的地址对于计算机来说是方便了，但对于人类来说却既难以记忆又难以输入。</p>
<p>于是“<strong>域名系统</strong>”（<strong>Domain Name System</strong>）出现了，<strong>用有意义的名字来作为 IP 地址的等价替代</strong>。设想一下，你是愿意记“95.211.80.227”这样枯燥的数字，还是“nginx.org”这样的词组呢？</p>
<p>在 DNS 中，<strong>“域名”（Domain Name）又称为“主机名”（Host）</strong>，为了更好地标记不同国家或组织的主机，让名字更好记，所以被设计成了一个有层次的结构。</p>
<p>域名用“.”分隔成多个单词，<strong>级别从左到右逐级升高</strong>，最右边的被称为“顶级域名”。对于顶级域名，可能你随口就能说出几个，例如表示商业公司的“com”、表示教育机构的“edu”，表示国家的“cn”“uk”等，买火车票时的域名还记得吗？是“<a href="http://www.12306.cn”。" target="_blank" rel="noopener">www.12306.cn”。</a></p>
<p><strong><u>但想要使用 TCP/IP 协议来通信仍然要使用 IP 地址，所以需要把域名做一个转换，“映射”到它的真实 IP，这就是所谓的“域名解析”。</u></strong></p>
<p>继续用刚才的打电话做个比喻，你想要打电话给小明，但不知道电话号码，就得在手机里的号码簿里一项一项地找，直到找到小明那一条记录，然后才能查到号码。这里的“小明”就相当于域名，而“电话号码”就相当于 IP 地址，这个查找的过程就是域名解析。</p>
<p>域名解析的实际操作要比刚才的例子复杂很多，因为互联网上的电脑实在是太多了。目前全世界有 13 组根 DNS 服务器，下面再有许多的顶级 DNS、权威 DNS 和更小的本地 DNS，逐层递归地实现域名查询。</p>
<p>HTTP 协议中并没有明确要求必须使用 DNS，但实际上为了方便访问互联网上的 Web 服务器，通常都会使用 DNS 来定位或标记主机名，间接地把 DNS 与 HTTP 绑在了一起。</p>
<h3 id="URI-URL"><a href="#URI-URL" class="headerlink" title="URI/URL"></a>URI/URL</h3><p>有了 TCP/IP 和 DNS，是不是我们就可以任意访问网络上的资源了呢？</p>
<p>还不行，DNS 和 IP 地址只是标记了互联网上的主机，但主机上有那么多文本、图片、页面，到底要找哪一个呢？就像小明管理了一大堆文档，你怎么告诉他是哪个呢？</p>
<p>所以就出现了 <strong>URI（Uniform Resource Identifier）</strong>，中文名称是 <strong>统一资源标识符</strong>，使用它就能够<strong>唯一地标记互联网上资源</strong>。</p>
<p>URI 另一个更常用的表现形式是 <strong>URL（Uniform Resource Locator）</strong>， <strong>统一资源定位符</strong>，也就是我们俗称的“网址”，它实际上<strong>是 URI 的一个子集</strong>，不过因为这两者几乎是相同的，差异不大，所以通常不会做严格的区分。</p>
<p>我就拿 Nginx 网站来举例，看一下 URI 是什么样子的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//nginx.org/en/download.html</span></span><br></pre></td></tr></table></figure>

<p>你可以看到，<strong>URI 主要有三个基本的部分构成</strong>：</p>
<p><strong>协议名</strong>：即访问该资源应当使用的协议，在这里是“http”；</p>
<p><strong>主机名</strong>：即互联网上主机的标记，可以是域名或 IP 地址，在这里是“nginx.org”；</p>
<p><strong>路径</strong>：即资源在主机上的位置，使用“/”分隔多级目录，在这里是“/en/download.html”。</p>
<p>还是用打电话来做比喻，你通过电话簿找到了小明，让他把昨天做好的宣传文案快递过来。那么这个过程中你就完成了一次 URI 资源访问，“小明”就是“主机名”，“昨天做好的宣传文案”就是“路径”，而“快递”，就是你要访问这个资源的“协议名”。</p>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>在 TCP/IP、DNS 和 URI 的“加持”之下，HTTP 协议终于可以自由地穿梭在互联网世界里，顺利地访问任意的网页了，真的是“好生快活”。</p>
<p>但且慢，互联网上不仅有“美女”，还有很多的“野兽”。假设你打电话找小明要一份广告创意，很不幸，电话被商业间谍给窃听了，他立刻动用种种手段偷窃了你的快递，就在你还在等包裹的时候，他抢先发布了这份广告，给你的公司造成了无形或有形的损失。</p>
<p>有没有什么办法能够防止这种情况的发生呢？确实有。你可以使用“加密”的方法，比如这样打电话：</p>
<p>你：“喂，小明啊，接下来我们改用火星文通话吧。”</p>
<p>小明：“好啊好啊，就用火星文吧。”</p>
<p>你：“巴拉巴拉巴拉巴拉……”</p>
<p>小明：“巴拉巴拉巴拉巴拉……”</p>
<p>如果你和小明说的火星文只有你们两个才懂，那么即使窃听到了这段谈话，他也不会知道你们到底在说什么，也就无从破坏你们的通话过程。HTTPS 就相当于这个比喻中的“火星文”，它的全称是“<strong>HTTP over SSL/TLS</strong>”，<strong>也就是运行在 SSL/TLS 协议上的 HTTP</strong>。</p>
<p>注意它的名字，这里是 <strong>SSL/TLS</strong>，而不是 TCP/IP，它是一个<strong>负责加密通信的安全协议</strong>，<strong>建立在 TCP/IP 之上，所以也是个可靠的传输协议</strong>，可以被用作 HTTP 的下层。</p>
<p>因为 <u><strong>HTTPS 相当于“HTTP+SSL/TLS+TCP/IP”</strong></u>，其中的“HTTP”和“TCP/IP”我们都已经明白了，只要再了解一下 SSL/TLS，HTTPS 也就能够轻松掌握。</p>
<p>SSL 的全称是“<strong>Secure Socket Layer</strong>”，由网景公司发明，当发展到 3.0 时被标准化，改名为 <strong>TLS，即“Transport Layer Security”</strong>，但由于历史的原因还是有很多人称之为 SSL/TLS，或者直接简称为 SSL。</p>
<p>SSL 使用了许多密码学最先进的研究成果，综合了对称加密、非对称加密、摘要算法、数字签名、数字证书等技术，能够在不安全的环境中为通信的双方创建出一个秘密的、安全的传输通道，为 HTTP 套上一副坚固的盔甲。</p>
<p>你可以在今后上网时留心看一下浏览器地址栏，如果有一个小锁头标志，那就表明网站启用了安全的 HTTPS 协议，而 URI 里的协议名，也从“http”变成了“https”。</p>
<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>代理（Proxy）是 HTTP 协议中请求方和应答方中间的一个环节，作为“中转站”，<strong>既可以转发客户端的请求，也可以转发服务器的应答</strong>。</p>
<p>代理有很多的种类，常见的有：</p>
<p><strong>匿名代理</strong>：完全“隐匿”了被代理的机器，外界看到的只是代理服务器；</p>
<p><strong>透明代理</strong>：顾名思义，它在传输过程中是“透明开放”的，外界既知道代理，也知道客户端；</p>
<p><strong>正向代理</strong>：靠近客户端，代表客户端向服务器发送请求；</p>
<p><strong>反向代理</strong>：靠近服务器端，代表服务器响应客户端的请求；</p>
<p>上一讲提到的 CDN，实际上就是一种代理，它代替源站服务器响应客户端的请求，通常扮演着透明代理和反向代理的角色。</p>
<p>由于代理在传输过程中插入了一个“中间层”，所以可以在这个环节做很多有意思的事情，比如：</p>
<p><strong>负载均衡</strong>：把访问请求均匀分散到多台机器，实现访问集群化；</p>
<p><strong>内容缓存</strong>：暂存上下行的数据，减轻后端的压力；</p>
<p><strong>安全防护</strong>：隐匿 IP, 使用 WAF 等工具抵御网络攻击，保护被代理的机器；</p>
<p><strong>数据处理</strong>：提供压缩、加密等额外的功能。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这次我介绍了与 HTTP 相关的各种协议，在这里简单小结一下今天的内容。</p>
<ol>
<li>TCP/IP 是网络世界最常用的协议，HTTP 通常运行在 TCP/IP 提供的可靠传输基础上；</li>
<li>DNS 域名是 IP 地址的等价替代，需要用域名解析实现到 IP 地址的映射；</li>
<li>URI 是用来标记互联网上资源的一个名字，由“协议名 + 主机名 + 路径”构成，俗称 URL；</li>
<li>HTTPS 相当于“HTTP+SSL/TLS+TCP/IP”，为 HTTP 套了一个安全的外壳；</li>
<li>代理是 HTTP 传输过程中的“中转站”，可以实现缓存加速、负载均衡等功能。</li>
</ol>
<h3 id="课下作业"><a href="#课下作业" class="headerlink" title="课下作业"></a>课下作业</h3><ol>
<li><p>DNS 与 URI 有什么关系？</p>
<p>DNS专门用于域名解析，作用是简化人类记忆数据的复杂度。URI专门用于标识互联网世界中的资源，作用是帮助找到对应的互联网中资源。互联网中的电脑通过IP地址来表示，DNS可以把一个域名变成一个IP地址，IP地址是标识资源的一部分，仅定位了具体的电脑，还有继续定位在电脑上的具体位置。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/30/http-03/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/2356874721.github.io/images/avatar.gif">
      <meta itemprop="name" content="sheriff">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="警长的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2356874721.github.io/2021/03/30/http-03/" class="post-title-link" itemprop="url">03 | HTTP世界全览（上）：与HTTP相关的各种概念</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-30 21:38:14 / 修改时间：21:45:54" itemprop="dateCreated datePublished" datetime="2021-03-30T21:38:14+08:00">2021-03-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/2356874721.github.io/categories/HTTP/" itemprop="url" rel="index"><span itemprop="name">HTTP</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <img src="/2356874721.github.io/2021/03/30/http-03/3-1.png" class>

<p>图左边的部分是与 HTTP 有关系的各种协议，比较偏向于理论；而右边的部分是与 HTTP 有关系的各种应用技术，偏向于实际应用。</p>
<p>我希望借助这张图帮你澄清与 HTTP 相关的各种概念和角色，让你在实际工作中清楚它们在链路中的位置和作用，知道发起一个 HTTP 请求会有哪些角色参与，会如何影响请求的处理，做到“手中有粮，心中不慌”。</p>
<p>因为那张图比较大，所以我会把左右两部分拆开来分别讲，今天先讲右边的部分，也就是与 HTTP 相关的各种应用，着重介绍互联网、浏览器、Web 服务器等常见且重要的概念。</p>
<img src="/2356874721.github.io/2021/03/30/http-03/3-2.png" class>

<h3 id="网络世界"><a href="#网络世界" class="headerlink" title="网络世界"></a>网络世界</h3><p>互联网世界更像是由数不清的大小岛屿组成的“千岛之国”。</p>
<p>互联网的正式名称是 <strong>Internet</strong>，里面存储着无穷无尽的信息资源，我们通常所说的“上网”实际上访问的只是互联网的一个子集“<strong>万维网</strong>”（World Wide Web），它基于 HTTP 协议，传输 HTML 等超文本资源，能力也就被限制在 HTTP 协议之内。</p>
<p>互联网上还有许多<strong>万维网之外的资源</strong>，例如常用的<strong>电子邮件、BT 和 Magnet 点对点下载、FTP 文件下载、SSH 安全登录、各种即时通信服务</strong>等等，它们需要用各自的专有协议来访问。</p>
<p>不过由于 HTTP 协议非常灵活、易于扩展，而且“超文本”的表述能力很强，所以很多其他原本不属于 HTTP 的资源也可以“包装”成 HTTP 来访问，这就是我们为什么能够总看到各种“网页应用”——例如“微信网页版”“邮箱网页版”——的原因。</p>
<p><strong>综合起来看，现在的互联网 90% 以上的部分都被万维网，也就是 HTTP 所覆盖，所以把互联网约等于万维网或 HTTP 应该也不算大错。</strong></p>
<h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p>上网就要用到浏览器，常见的浏览器有 Google 的 Chrome、Mozilla 的 Firefox、Apple 的 Safari、Microsoft 的 IE 和 Edge，还有小众的 Opera 以及国内的各种“换壳”的“极速”“安全”浏览器。</p>
<p>那么你想过没有，所谓的“浏览器”到底是个什么东西呢？浏览器的正式名字叫<strong>“Web Browser</strong>”，顾名思义，就是<strong>检索、查看互联网上网页资源的应用程序</strong>，名字里的 Web，实际上指的就是“World Wide Web”，也就是万维网。</p>
<p><strong>浏览器本质上是一个 HTTP 协议中的请求方</strong>，使用 HTTP 协议获取网络上的各种资源。当然，为了让我们更好地检索查看网页，它还集成了很多额外的功能。</p>
<p>例如，HTML 排版引擎用来展示页面，JavaScript 引擎用来实现动态化效果，甚至还有开发者工具用来调试网页，以及五花八门的各种插件和扩展。</p>
<p><strong>在 HTTP 协议里，浏览器的角色被称为“User Agent”即“用户代理</strong>”，<strong>意思是作为访问者的“代理”来发起 HTTP 请求</strong>。不过在不引起混淆的情况下，我们通常都简单地称之为“<strong>客户端</strong>”。</p>
<h3 id="Web-服务器"><a href="#Web-服务器" class="headerlink" title="Web 服务器"></a>Web 服务器</h3><p>刚才说的浏览器是 HTTP 里的请求方，那么在协议另一端的<strong>应答方（响应方）</strong>又是什么呢？这个你一定也很熟悉，答案就是<strong>服务器</strong>，Web Server。</p>
<p>Web 服务器是一个很大也很重要的概念，它是 <strong>HTTP 协议里响应请求的主体</strong>，通常也<strong>把控着绝大多数的网络资源</strong>，<strong>在网络世界里处于强势地位</strong>。</p>
<p>当我们谈到“Web 服务器”时有两个层面的含义：硬件和软件。</p>
<h4 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h4><p>硬件含义就是<strong>物理形式或“云”形式的机器</strong>，在大多数情况下它可能不是一台服务器，而是利用反向代理、负载均衡等技术组成的庞大<strong>集群</strong>。但从外界看来，它仍然表现为一台机器，但这个形象是“虚拟的”。</p>
<h4 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h4><p>软件含义的 Web 服务器可能我们更为关心，它就是<strong>提供 Web 服务的应用程序</strong>，通常会运行在硬件含义的服务器上。它利用强大的硬件能力响应海量的客户端 HTTP 请求，处理磁盘上的网页、图片等静态文件，或者把请求转发给后面的 Tomcat、Node.js 等业务应用，返回动态的信息。</p>
<p>比起层出不穷的各种 Web 浏览器，Web 服务器就要少很多了，一只手的手指头就可以数得过来。</p>
<p><strong>Apache</strong> 是老牌的服务器，功能相当完善，相关的资料很多，学习门槛低，是许多创业者建站的入门产品。<strong>Nginx</strong> 是 Web 服务器里的后起之秀，特点是高性能、高稳定，且易于扩展。自 2004 年推出后就不断蚕食 Apache 的市场份额，在高流量的网站里更是不二之选。此外，还有 Windows 上的 <strong>IIS</strong>、Java 的 <strong>Jetty/Tomcat</strong> 等，因为性能不是很高，所以在互联网上应用得较少。</p>
<h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>浏览器和服务器是 HTTP 协议的两个端点，那么，在这两者之间还有别的什么东西吗？当然有了。浏览器通常不会直接连到服务器，中间会经过“重重关卡”，其中的一个重要角色就叫做 CDN。</p>
<p>CDN，全称是“<strong>Content Delivery Network</strong>”，翻译过来就是“<strong>内容分发网络</strong>”。它应用了 HTTP 协议里的<strong>缓存</strong>和<strong>代理</strong>技术，<strong>代替源站响应客户端的请求</strong>。</p>
<p>CDN 有什么好处呢？</p>
<p><u><strong>简单来说，它可以缓存源站的数据，让浏览器的请求不用“千里迢迢”地到达源站服务器，直接在“半路”就可以获取响应。如果 CDN 的调度算法很优秀，更可以找到离用户最近的节点，大幅度缩短响应时间。</strong></u></p>
<p>CDN 也是现在互联网中的一项重要基础设施，<strong>除了基本的网络加速外，还提供负载均衡、安全防护、边缘计算、跨运营商网络等功能</strong>，能够成倍地“放大”源站服务器的服务能力，很多云服务商都把 CDN 作为产品的一部分。</p>
<h3 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h3><p>前面说到过浏览器，它是一种用户代理，代替我们访问互联网。</p>
<p>但 <strong>HTTP 协议并没有规定用户代理后面必须是“真正的人类”</strong>，它也完全可以是“<strong>机器人</strong>”，这些“机器人”的正式名称就叫做“爬虫”（Crawler），<strong>实际上是一种可以自动访问 Web 资源的应用程序</strong>。</p>
<p>“爬虫”这个名字非常形象，它们就像是一只只不知疲倦的、辛勤的蚂蚁，在无边无际的网络上爬来爬去，不停地在网站间奔走，搜集抓取各种信息。</p>
<p>据估计，互联网上至少有 50% 的流量都是由爬虫产生的，某些特定领域的比例还会更高，也就是说，如果你的网站今天的访问量是十万，那么里面至少有五六万是爬虫机器人，而不是真实的用户。</p>
<p>爬虫是怎么来的呢？</p>
<p>绝大多数是由各大搜索引擎“放”出来的，抓取网页存入庞大的数据库，再建立关键字索引，这样我们才能够在搜索引擎中快速地搜索到互联网角落里的页面。</p>
<p>爬虫也有不好的一面，它会<strong>过度消耗网络资源，占用服务器和带宽，影响网站对真实数据的分析，甚至导致敏感信息泄漏</strong>。所以，又出现了“反爬虫”技术，通过各种手段来限制爬虫。其中一项就是“君子协定”robots.txt，约定哪些该爬，哪些不该爬。无论是“爬虫”还是“反爬虫”，用到的基本技术都是两个，一个是 HTTP，另一个就是 HTML。</p>
<h3 id="HTML-WebService-WAF"><a href="#HTML-WebService-WAF" class="headerlink" title="HTML/WebService/WAF"></a>HTML/WebService/WAF</h3><p>到现在我已经说完了图中右边的五大部分，而左边的 HTML、WebService、WAF 等由于与 HTTP 技术上实质关联不太大，所以就简略地介绍一下，不再过多展开。</p>
<p><strong>HTML 是 HTTP 协议传输的主要内容之一</strong>，它描述了超文本页面，用各种“标签”定义文字、图片等资源和排版布局，最终由浏览器“渲染”出可视化页面。HTML 目前有两个主要的标准，HTML4 和 HTML5。广义上的 HTML 通常是指 HTML、JavaScript、CSS 等前端技术的组合，能够实现比传统静态页面更丰富的动态页面。</p>
<p><strong>Web Service 是一种由 W3C 定义的应用服务开发规范</strong>，使用 client-server 主从架构，通常使用 WSDL 定义服务接口，使用 HTTP 协议传输 XML 或 SOAP 消息，也就是说，它是一个基于 Web（HTTP）的服务架构技术，既可以运行在内网，也可以在适当保护后运行在外网。因为采用了 HTTP 协议传输数据，所以在 Web Service 架构里服务器和客户端可以采用不同的操作系统或编程语言开发。例如服务器端用 Linux+Java，客户端用 Windows+C#，具有跨平台跨语言的优点。</p>
<p><strong>WAF</strong> 是近几年比较“火”的一个词，意思是“<strong>网络应用防火墙</strong>”。与硬件“防火墙”类似，它是应用层面的“防火墙”，专门检测 HTTP 流量，是防护 Web 应用的安全技术。WAF 通常位于 Web 服务器之前，可以阻止如 SQL 注入、跨站脚本等攻击，目前应用较多的一个开源项目是 ModSecurity，它能够完全集成进 Apache 或 Nginx。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>今天我详细介绍了与 HTTP 有关系的各种应用技术，在这里简单小结一下要点。</p>
<ol>
<li>互联网上绝大部分资源都使用 HTTP 协议传输；</li>
<li>浏览器是 HTTP 协议里的请求方，即 User Agent；</li>
<li>服务器是 HTTP 协议里的应答方，常用的有 Apache 和 Nginx；</li>
<li>CDN 位于浏览器和服务器之间，主要起到缓存加速的作用；</li>
<li>爬虫是另一类 User Agent，是自动访问网络资源的程序。</li>
</ol>
<h3 id="课下作业"><a href="#课下作业" class="headerlink" title="课下作业"></a>课下作业</h3><ol>
<li><p>你觉得 CDN 在对待浏览器和爬虫时会有差异吗？为什么？</p>
<p>CDN在对待浏览器和爬虫时没有差异，都被视为User Agent</p>
</li>
<li><p>你怎么理解 WebService 与 Web Server 这两个非常相似的词？</p>
<p>Webservice是服务，Web Server是服务器</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/30/http-02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/2356874721.github.io/images/avatar.gif">
      <meta itemprop="name" content="sheriff">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="警长的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2356874721.github.io/2021/03/30/http-02/" class="post-title-link" itemprop="url">02 | HTTP是什么？HTTP又不是什么？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-30 21:37:25 / 修改时间：21:37:58" itemprop="dateCreated datePublished" datetime="2021-03-30T21:37:25+08:00">2021-03-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/2356874721.github.io/categories/HTTP/" itemprop="url" rel="index"><span itemprop="name">HTTP</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="HTTP-是什么"><a href="#HTTP-是什么" class="headerlink" title="HTTP 是什么"></a>HTTP 是什么</h3><p>咱们中国有个成语“人如其名”，意思是一个人的性格和特点是与他的名字相符的。</p>
<p>先看一下 HTTP 的名字：“<strong>超文本传输协议</strong>”，它可以拆成<strong>三个部分</strong>，分别是：“<strong>超文本</strong>”“<strong>传输</strong>”和“<strong>协议</strong>”。我们从后往前来逐个解析，理解了这三个词，我们也就明白了什么是 HTTP。</p>
<h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><p>首先，HTTP 是一个<strong>协议</strong>。那么“协议”有什么特点呢？</p>
<p>第一点，<strong>协议必须要有两个或多个参与者</strong>，也就是“协”。如果只有你一个人，那你自然可以想干什么就干什么，想怎么玩就怎么玩，不会干涉其他人，其他人也不会干涉你，也就不需要所谓的“协议”。但是，一旦有了两个以上的参与者出现，为了保证最基本的顺畅交流，协议就自然而然地出现了。</p>
<p>第二点，<strong>协议是对参与者的一种行为约定和规范</strong>，也就是“议”。协议意味着有多个参与者为了达成某个共同的目的而站在了一起，除了要无疑义地沟通交流之外，还必须明确地规定各方的“责、权、利”，<strong>约定该做什么不该做什么，先做什么后做什么，做错了怎么办，有没有补救措施等等</strong>。</p>
<p>好，到这里，你应该能够明白 HTTP 的第一层含义了。</p>
<p><strong>HTTP 是一个用在计算机世界里的协议。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式。</strong></p>
<h4 id="传输"><a href="#传输" class="headerlink" title="传输"></a>传输</h4><p>接下来我们看 HTTP 字面里的第二部分：“传输”。</p>
<p>HTTP 是一个“传输协议”，所谓的“传输”（Transfer）其实很好理解，就是把一堆东西从 A 点搬到 B 点，或者从 B 点搬到 A 点，即“A&lt;===&gt;B”。别小看了这个简单的动作，它也至少包含了两项重要的信息。</p>
<p>第一点，HTTP 协议是一个“<strong>双向协议</strong>”。也就是说，有两个最基本的参与者 A 和 B，从 A 开始到 B 结束，<strong>数据在 A 和 B 之间双向而不是单向流动</strong>。通常我们把先发起传输动作的 A 叫做<strong>请求方</strong>，把后接到传输的 B 叫做<strong>应答方</strong>或者<strong>响应方</strong>。拿我们最常见的上网冲浪来举例子，浏览器就是请求方 A，网易、新浪这些网站就是应答方 B。双方约定用 HTTP 协议来通信，于是浏览器把一些数据发送给网站，网站再把一些数据发回给浏览器，最后展现在屏幕上，你就可以看到各种有意思的新闻、视频了。</p>
<p>第二点，数据虽然是在 A 和 B 之间传输，但并没有限制只有 A 和 B 这两个角色，<strong>允许中间有“中转”或者“接力”</strong>。这样，传输方式就从“A&lt;===&gt;B”，变成了“A&lt;=&gt;X&lt;=&gt;Y&lt;=&gt;Z&lt;=&gt;B”，A 到 B 的传输过程中可以存在任意多个“<strong>中间人</strong>”，而这些<strong>中间人也都遵从 HTTP 协议</strong>，只要不打扰基本的数据传输，就可以添加任意的额外功能，例如安全认证、数据压缩、编码转换等等，优化整个传输过程。</p>
<p>说到这里，你差不多应该能够明白 HTTP 的第二层含义了。</p>
<p><strong>HTTP 是一个在计算机世界里专门用来在两点之间传输数据的约定和规范。</strong></p>
<h4 id="超文本"><a href="#超文本" class="headerlink" title="超文本"></a>超文本</h4><p>既然 HTTP 是一个“传输协议”，那么它传输的“超文本”到底是什么呢？我还是用两点来进一步解释。</p>
<p>所谓“<strong>文本</strong>”（Text），就表示 HTTP 传输的<strong>不是</strong> TCP/UDP 这些底层协议里被切分的<strong>杂乱无章的二进制包</strong>（datagram），<strong>而是完整的、有意义的数据</strong>，<strong>可以被浏览器、服务器这样的上层应用程序处理</strong>。在互联网<strong>早期</strong>，“文本”只是简单的<strong>字符文字</strong>，但发展到现在，“文本”的涵义已经被大大地扩展了，<strong>图片、音频、视频、</strong>甚至是<strong>压缩包</strong>，在 HTTP 眼里都可以算做是“文本”。</p>
<p>所谓“<strong>超文本</strong>”，就是“<strong>超越了普通文本的文本</strong>”，它是<strong>文字、图片、音频和视频等的混合体</strong>，最关键的是含有“<strong>超链接</strong>”，<strong>能够从一个“超文本”跳跃到另一个“超文本”，形成复杂的非线性、网状的结构关系</strong>。对于“超文本”，我们最熟悉的就应该是 <strong>HTML</strong> 了，它本身只是纯文字文件，但内部用很多标签定义了对图片、音频、视频等的链接，再经过浏览器的解释，呈现在我们面前的就是一个含有多种视听信息的页面。</p>
<p>OK，经过了对 HTTP 里这三个名词的详细解释，下次你就可以给出比“超文本传输协议”这七个字更准确更有技术含量的答案：<u><strong>“HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范”</strong></u>。</p>
<h3 id="HTTP-不是什么"><a href="#HTTP-不是什么" class="headerlink" title="HTTP 不是什么"></a>HTTP 不是什么</h3><p>现在你对“HTTP 是什么？”应该有了比较清晰的认识，紧接着的问题就是“HTTP 不是什么？”，等价的问题是“HTTP 不能干什么？”。想想看，你能回答出来吗？</p>
<p>因为 HTTP 是一个协议，是一种计算机间通信的规范，所以它<strong>不存在“单独的实体”</strong>。它不是浏览器、手机 APP 那样的应用程序，也不是 Windows、Linux 那样的操作系统，更不是 Apache、Nginx、Tomcat 那样的 Web 服务器。</p>
<p>但 HTTP 又与应用程序、操作系统、Web 服务器密切相关，在它们之间的通信过程中存在，而且是一种“<strong>动态的存在</strong>”，是发生在网络连接、传输超文本数据时的一个“<strong>动态过程</strong>”。</p>
<h4 id="HTTP-不是互联网"><a href="#HTTP-不是互联网" class="headerlink" title="HTTP 不是互联网"></a>HTTP 不是互联网</h4><p>互联网（Internet）是遍布于全球的许多网络互相连接而形成的一个巨大的国际网络，在它上面存放着各式各样的资源，也对应着各式各样的协议，例如超文本资源使用 HTTP，普通文件使用 FTP，电子邮件使用 SMTP 和 POP3 等。但毫无疑问，HTTP 是构建互联网的一块重要拼图，而且是占比最大的那一块。</p>
<h4 id="HTTP-不是编程语言"><a href="#HTTP-不是编程语言" class="headerlink" title="HTTP 不是编程语言"></a>HTTP 不是编程语言</h4><p>编程语言是人与计算机沟通交流所使用的语言，而 HTTP 是计算机与计算机沟通交流的语言，我们无法使用 HTTP 来编程，但可以反过来，用编程语言去实现 HTTP，告诉计算机如何用 HTTP 来与外界通信。</p>
<p>很多流行的编程语言都支持编写 HTTP 相关的服务或应用，例如使用 Java 在 Tomcat 里编写 Web 服务，使用 PHP 在后端实现页面模板渲染，使用 JavaScript 在前端实现动态页面更新，你是否也会其中的一两种呢？</p>
<h4 id="HTTP-不是-HTML"><a href="#HTTP-不是-HTML" class="headerlink" title="HTTP 不是 HTML"></a>HTTP 不是 HTML</h4><p>这个可能要特别强调一下，<strong>千万不要把 HTTP 与 HTML 混为一谈</strong>，虽然这两者经常是同时出现。</p>
<p><strong>HTML 是超文本的载体，是一种标记语言</strong>，使用各种标签描述文字、图片、超链接等资源，并且可以嵌入 CSS、JavaScript 等技术实现复杂的动态效果。单论次数，<strong>在互联网上 HTTP 传输最多的可能就是 HTML，但要是论数据量，HTML 可能要往后排了，图片、音频、视频这些类型的资源显然更大</strong>。</p>
<h4 id="HTTP-不是一个孤立的协议"><a href="#HTTP-不是一个孤立的协议" class="headerlink" title="HTTP 不是一个孤立的协议"></a>HTTP 不是一个孤立的协议</h4><p>在互联网世界里，<strong>HTTP 通常跑在 TCP/IP 协议栈之上，依靠 IP 协议实现寻址和路由、TCP 协议实现可靠数据传输、DNS 协议实现域名查找、SSL/TLS 协议实现安全通信</strong>。此外，还有一些协议依赖于 HTTP，例如 WebSocket、HTTPDNS 等。这些协议相互交织，构成了一个协议网，而 <strong>HTTP 则处于中心地位</strong>。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol>
<li>HTTP 是一个用在计算机世界里的协议，它确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式。</li>
<li>HTTP 专门用来在两点之间传输数据，不能用于广播、寻址或路由。</li>
<li>HTTP 传输的是文字、图片、音频、视频等超文本数据。</li>
<li>HTTP 是构建互联网的重要基础技术，它没有实体，依赖许多其他的技术来实现，但同时许多技术也都依赖于它。</li>
</ol>
<h3 id="课下作业"><a href="#课下作业" class="headerlink" title="课下作业"></a>课下作业</h3><ol>
<li><p>有一种流行的说法：“HTTP 是用于从互联网服务器传输超文本到本地浏览器的协议”，你认为这种说法对吗？对在哪里，又错在哪里？</p>
<p>HTTP 是一个在计算机世界里专门在两点之间传输数据的约定和规范。HTTP 协议是一个“<strong>双向协议</strong>”，可以是服务器向服务器、浏览器向服务器、服务器向浏览器。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/30/http-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/2356874721.github.io/images/avatar.gif">
      <meta itemprop="name" content="sheriff">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="警长的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2356874721.github.io/2021/03/30/http-01/" class="post-title-link" itemprop="url">01 | 时势与英雄：HTTP的前世今生</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-30 21:36:13 / 修改时间：21:47:32" itemprop="dateCreated datePublished" datetime="2021-03-30T21:36:13+08:00">2021-03-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/2356874721.github.io/categories/HTTP/" itemprop="url" rel="index"><span itemprop="name">HTTP</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>HTTP 协议是怎么来的？它最开始是什么样子的？又是如何一步一步发展到今天，几乎“统治”了整个互联网世界的呢？</p>
<h3 id="史前时期"><a href="#史前时期" class="headerlink" title="史前时期"></a>史前时期</h3><p>20 世纪 60 年代，美国国防部高等研究计划署（ARPA）建立了 <strong>ARPA</strong> 网，它有四个分布在各地的节点，被认为是如今互联网的“<strong>始祖</strong>”。</p>
<p>在 70 年代，<strong>基于对 ARPA 网的实践和思考，研究人员发明出了著名的 TCP/IP 协议</strong>。由于具有良好的分层结构和稳定的性能，TCP/IP 协议迅速战胜其他竞争对手流行起来，并在 80 年代中期进入了 <strong>UNIX</strong> 系统内核，促使更多的计算机接入了互联网。</p>
<h3 id="创世纪"><a href="#创世纪" class="headerlink" title="创世纪"></a>创世纪</h3><p>1989 年，任职于欧洲核子研究中心（CERN）的<strong>蒂姆·伯纳斯 - 李（Tim Berners-Lee）</strong>发表了一篇<strong>论文</strong>，提出了在互联网上构建<strong>超链接文档系统</strong>的构想。这篇论文中他确立了<strong>三项关键技术</strong>。</p>
<p><strong>URI：即统一资源标识符，作为互联网上资源的唯一身份；</strong></p>
<p><strong>HTML：即超文本标记语言，描述超文本文档；</strong></p>
<p><strong>HTTP：即超文本传输协议，用来传输超文本。</strong></p>
<p>这三项技术在如今的我们看来已经是稀松平常，但在当时却是了不得的大发明。基于它们，就可以把超文本系统完美地运行在互联网上，让各地的人们能够自由地共享信息，蒂姆把这个系统称为“<strong>万维网</strong>”（World Wide Web），也就是我们现在所熟知的 <strong>Web</strong>。</p>
<p>所以在这一年，我们的英雄“<strong>HTTP”诞生</strong>了，从此开始了它伟大的征途。</p>
<h3 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP/0.9"></a>HTTP/0.9</h3><p>20 世纪 90 年代初期的互联网世界非常简陋，计算机处理能力低，存储容量小，网速很慢，还是一片“信息荒漠”。网络上绝大多数的资源都是纯文本，很多通信协议也都使用纯文本，所以 HTTP 的设计也不可避免地受到了时代的限制。</p>
<p>这一时期的 HTTP 被定义为 0.9 版，结构比较简单，为了便于服务器和客户端处理，它也采用了<strong>纯文本</strong>格式。蒂姆·伯纳斯 - 李最初设想的系统里的<strong>文档</strong>都是<strong>只读</strong>的，所以只允许用“<strong>GET</strong>”动作从服务器上获取 HTML 文档，并且<strong>在响应请求之后立即关闭连接</strong>，功能非常有限。</p>
<p>HTTP/0.9 虽然很简单，但它作为一个“<strong>原型</strong>”，充分验证了 Web 服务的可行性，而“简单”也正是它的优点，蕴含了进化和扩展的可能性，因为：</p>
<p><strong>“把简单的系统变复杂”，要比“把复杂的系统变简单”容易得多。</strong></p>
<h3 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP/1.0"></a>HTTP/1.0</h3><p>1993 年，NCSA（美国国家超级计算应用中心）开发出了 Mosaic，是第一个可以<strong>图文混排</strong>的浏览器，随后又在 1995 年开发出了服务器软件 <strong>Apache</strong>，简化了 HTTP 服务器的搭建工作。</p>
<p>同一时期，计算机多媒体技术也有了新的发展：1992 年发明了 <strong>jpeg</strong> 图像格式，1995 年发明了 <strong>MP3</strong> 音乐格式。</p>
<p>这些新软件新技术一经推出立刻就吸引了广大网民的热情，更的多的人开始使用互联网，研究 HTTP 并提出改进意见，甚至实验性地往协议里添加各种特性，<strong>从用户需求的角度促进了 HTTP 的发展</strong>。</p>
<p>于是在这些已有实践的基础上，经过一系列的草案，HTTP/1.0 版本在 1996 年正式发布。它在多方面增强了 0.9 版，形式上已经和我们现在的 HTTP 差别不大了，例如：</p>
<p><strong>增加了 HEAD、POST 等新方法；</strong></p>
<p><strong>增加了响应状态码，标记可能的错误原因；</strong></p>
<p><strong>引入了协议版本号概念；</strong></p>
<p><strong>引入了 HTTP Header（头部）的概念，让 HTTP 处理请求和响应更加灵活；</strong></p>
<p><strong>传输的数据不再仅限于文本。</strong></p>
<p>但 <strong>HTTP/1.0 并不是一个“标准”</strong>，只是记录已有实践和模式的一份<strong>参考文档</strong>，<strong>不具有实际的约束力</strong>，相当于一个“备忘录”。所以 HTTP/1.0 的发布对于当时正在蓬勃发展的互联网来说并没有太大的实际意义，各方势力仍然按照自己的意图继续在市场上奋力拼杀。</p>
<h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h3><p>1995 年，网景的 Netscape Navigator 和微软的 Internet Explorer 开始了著名的“<strong>浏览器大战</strong>”，都希望在互联网上占据主导地位。</p>
<p>这场战争的结果你一定早就知道了，最终微软的 IE 取得了决定性的胜利，而网景则“败走麦城”（但后来却凭借 Mozilla Firefox 又扳回一局）。</p>
<p>“浏览器大战”的是非成败我们放在一边暂且不管，不可否认的是，它再一次极大地推动了 Web 的发展，HTTP/1.0 也在这个过程中经受了实践检验。于是在“浏览器大战”结束之后的 <strong>1999 年</strong>，<strong>HTTP/1.1 发布了 RFC 文档，编号为 2616，正式确立了延续十余年的传奇</strong>。</p>
<p>从版本号我们就可以看到，<strong>HTTP/1.1 是对 HTTP/1.0 的小幅度修正。但一个重要的区别是：它是一个</strong>“<strong>正式的标准</strong>”，而不是一份可有可无的“参考文档”。这意味着今后互联网上所有的浏览器、服务器、网关、代理等等，只要用到 HTTP 协议，就必须严格遵守这个标准，相当于是互联网世界的一个“立法”。</p>
<p><strong>HTTP/1.1 主要的变更点有：</strong></p>
<p><strong>增加了 PUT、DELETE 等新的方法；</strong></p>
<p><strong>增加了缓存管理和控制；</strong></p>
<p><strong>明确了连接管理，允许持久连接；</strong></p>
<p><strong>允许响应数据分块（chunked），利于传输大文件；</strong></p>
<p><strong>强制要求 Host 头，让互联网主机托管成为可能</strong></p>
<h3 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h3><p>HTTP/1.1 发布之后，整个互联网世界呈现出了爆发式的增长，度过了十多年的“快乐时光”，更涌现出了 Facebook、Twitter、淘宝、京东等互联网新贵。</p>
<p>这期间也出现了一些对 HTTP 不满的意见，主要就是<strong>连接慢</strong>，无法跟上迅猛发展的互联网，但 HTTP/1.1 标准一直“岿然不动”，无奈之下人们只好发明各式各样的“小花招”来缓解这些问题，比如以前常见的切图、JS 合并等网页优化手段。</p>
<p>终于有一天，搜索巨头 Google 忍不住了，决定“揭竿而起”，就像马云说的“如果银行不改变，我们就改变银行”。那么，它是怎么“造反”的呢？</p>
<p>Google 首先开发了自己的浏览器 <strong>Chrome</strong>，然后推出了新的 <strong>SPDY</strong> 协议，并在 Chrome 里应用于自家的服务器，如同十多年前的网景与微软一样，<strong>从实际的用户方来“倒逼”HTTP 协议的变革</strong>，这也开启了<strong>第二次的“浏览器大战”</strong>。</p>
<p>历史再次重演，不过这次的胜利者是 Google，Chrome 目前的全球的占有率超过了 60%。“挟用户以号令天下”，Google 借此顺势把 SPDY 推上了标准的宝座，<strong>互联网标准化组织以 SPDY 为基础开始制定新版本的 HTTP 协议，最终在 2015 年发布了 HTTP/2，RFC 编号 7540</strong>。</p>
<p>HTTP/2 的制定充分考虑了<strong>现今互联网的现状：宽带、移动、不安全</strong>，在高度兼容 HTTP/1.1 的同时在性能改善方面做了很大努力，主要的特点有：</p>
<p><strong>二进制协议，不再是纯文本；</strong></p>
<p><strong>可发起多个请求，废弃了 1.1 里的管道；</strong></p>
<p><strong>使用专用算法压缩头部，减少数据传输量；</strong></p>
<p><strong>允许服务器主动向客户端推送数据；</strong></p>
<p><strong>增强了安全性，“事实上”要求加密通信</strong></p>
<p>虽然 HTTP/2 到今天已经六岁，也衍生出了 gRPC 等新协议，但由于 <strong>HTTP/1.1 实在是太过经典和强势</strong>，目前它的普及率还比较低，<strong>大多数网站使用的仍然还是 20 年前的 HTTP/1.1</strong>。</p>
<h3 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP/3"></a>HTTP/3</h3><p>看到这里，你可能会问了：“HTTP/2 这么好，是不是就已经完美了呢？”答案是否定的，这一次还是 Google，而且它要“革自己的命”。</p>
<p>在 HTTP/2 还处于草案之时，<strong>Google</strong> 又发明了一个新的协议，叫做 <strong>QUIC</strong>，而且还是相同的“套路”，继续在 Chrome 和自家服务器里试验着“玩”，依托它的庞大用户量和数据量，持续地推动 QUIC 协议成为互联网上的“既成事实”。</p>
<p>“功夫不负有心人”，当然也是因为 QUIC 确实自身素质过硬。</p>
<p>在 2018 年，互联网标准化组织 <strong>IETF</strong> 提议将“<strong>HTTP over QUIC</strong>”更名为“<strong>HTTP/3</strong>”并获得<strong>批准</strong>。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>在这里简单小结一下今天的内容：</p>
<ol>
<li>HTTP 协议始于三十年前蒂姆·伯纳斯 - 李的一篇论文；</li>
<li>HTTP/0.9 是个简单的文本协议，只能获取文本资源；</li>
<li>HTTP/1.0 确立了大部分现在使用的技术，但它不是正式标准；</li>
<li>HTTP/1.1 是目前互联网上使用最广泛的协议，功能也非常完善；</li>
<li>HTTP/2 基于 Google 的 SPDY 协议，注重性能改善，但还未普及；</li>
<li>HTTP/3 基于 Google 的 QUIC 协议，是将来的发展方向。</li>
</ol>
<h3 id="课下作业"><a href="#课下作业" class="headerlink" title="课下作业"></a>课下作业</h3><ol>
<li><p>你认为推动 HTTP 发展的原动力是什么？</p>
<p>协议标准不同于原理，原理是相对稳定的，而标准则需要<strong>与时俱进</strong>，随着业务和技术发展中出现的新问题一起变化。在实际商业应用、竞争和实践中反复打磨，让协议标准适应不断发展变化的实际业务问题，而不是让日渐庞大复杂的业务去适应受限于特定时空因素的标准。<br>标准的诞生和发展一方面是基于具体业务需要和技术发展，另一方面是为了统一游戏规则，让各厂商的软硬件产品可以方便地“互联”，降低“沟通”和“翻译”的成本，提高网络互联的开放性。</p>
</li>
<li><p>你是怎么理解 HTTP（超文本传输协议）的？</p>
<p>超文本传输协议＝超文本＋传输＋协议，协议即约定，<strong>HTTP就是约定超文本怎么传输的</strong>。初心就是分享信息，所以，简单、开放、有求有应，只针对文本，后来出现了音频、视频、动画、图片、超链接等，比纯文本复杂了一些，不过初心不改，所以，原则未变，只是需要调整一下适应这些正当其时的需求而已。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/27/algorithm-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/2356874721.github.io/images/avatar.gif">
      <meta itemprop="name" content="sheriff">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="警长的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2356874721.github.io/2021/03/27/algorithm-3/" class="post-title-link" itemprop="url">数组：为什么很多编程语言中数组都从0开始编号？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-27 16:11:43 / 修改时间：16:15:59" itemprop="dateCreated datePublished" datetime="2021-03-27T16:11:43+08:00">2021-03-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/2356874721.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">算法与数据结构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>提到数组，我想你肯定不陌生，甚至还会自信地说，它很简单啊。</p>
<p>是的，在每一种编程语言中，基本都会有数组这种数据类型。不过，它不仅仅是一种编程语言中的数据类型，还是一种最基础的数据结构。尽管数组看起来非常基础、简单，但是我估计很多人都并没有理解这个基础数据结构的精髓。</p>
<p>在大部分编程语言中，数组都是从 0 开始编号的，但你是否下意识地想过，为什么数组要从 0 开始编号，而不是从 1 开始呢？ 从 1 开始不是更符合人类的思维习惯吗？</p>
<p>你可以带着这个问题来学习接下来的内容。</p>
<h3 id="如何实现随机访问"><a href="#如何实现随机访问" class="headerlink" title="如何实现随机访问"></a>如何实现随机访问</h3><p>什么是数组？我估计你心中已经有了答案。不过，我还是想用专业的话来给你做下解释。<strong>数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。</strong></p>
<p>这个定义里有几个关键词，理解了这几个关键词，我想你就能彻底掌握数组的概念了。</p>
<p>第一是<strong>线性表（Linear List）</strong>。顾名思义，线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构。</p>
<img src="/2356874721.github.io/2021/03/27/algorithm-3/3-1.jpeg" class>

<p>而与它相对立的概念是<strong>非线性表</strong>，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。</p>
<img src="/2356874721.github.io/2021/03/27/algorithm-3/3-2.jpeg" class>

<p>第二个是<strong>连续的内存空间和相同类型的数据</strong>。正是因为这两个限制，它才有了一个堪称“杀手锏”的特性：“<strong>随机访问</strong>”。<strong>但有利就有弊，这两个限制也让数组的很多操作变得非常低效，比如要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。</strong></p>
<p>说到数据的访问，那你知道数组是如何实现根据下标随机访问数组元素的吗？</p>
<p>我们拿一个长度为 10 的 int 类型的数组 int[] a = new int[10]来举例。在我画的这个图中，计算机给数组 a[10]，分配了一块连续内存空间 1000～1039，其中，内存块的首地址为 base_address = 1000。</p>
<img src="/2356874721.github.io/2021/03/27/algorithm-3/3-3.jpeg" class>

<p>我们知道，计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[i]_address = base_address + i * data_type_size</span><br></pre></td></tr></table></figure>

<p>其中 data_type_size 表示数组中每个元素的大小。我们举的这个例子里，数组中存储的是 int 类型数据，所以 data_type_size 就为 4 个字节。</p>
<p><strong>这里要特别纠正一个“错误”。在面试的时候，常常会问数组和链表的区别，很多人都回答说，“链表适合插入、删除，时间复杂度 O(1)；数组适合查找，查找时间复杂度为 O(1)”。</strong></p>
<p>实际上，这种表述是不准确的。数组是适合查找操作，但是查找的时间复杂度并不为 O(1)。即便是排好序的数组，你用二分查找，时间复杂度也是 O(logn)。<strong>所以，正确的表述应该是，数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。</strong></p>
<h3 id="低效的“插入”和“删除”"><a href="#低效的“插入”和“删除”" class="headerlink" title="低效的“插入”和“删除”"></a>低效的“插入”和“删除”</h3><p>前面概念部分我们提到，数组为了保持内存数据的连续性，会导致插入、删除这两个操作比较低效。现在我们就来详细说一下，究竟为什么会导致低效？又有哪些改进方法呢？</p>
<h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a><strong>插入操作</strong></h4><p>假设数组的长度为 n，现在，如果我们需要将一个数据插入到数组中的第 k 个位置。为了把第 k 个位置腾出来，给新来的数据，我们需要将第 k～n 这部分的元素都顺序地往后挪一位。那插入操作的时间复杂度是多少呢？你可以自己先试着分析一下。</p>
<p><strong>如果在数组的末尾插入元素，那就不需要移动数据了，这时的时间复杂度为 O(1)。但如果在数组的开头插入元素，那所有的数据都需要依次往后移动一位，所以最坏时间复杂度是 O(n)。 因为我们在每个位置插入元素的概率是一样的，所以平均情况时间复杂度为 (1+2+…n)/n=O(n)。</strong></p>
<p>如果数组中的数据是<strong>有序</strong>的，我们在某个位置插入一个新的元素时，就必须按照刚才的方法搬移 k 之后的数据。但是，<strong>如果数组中存储的数据并没有任何规律</strong>，数组只是被当作一个存储数据的集合。在这种情况下，如果要将某个数据插入到第 k 个位置，为了避免大规模的数据搬移，我们还有一个<strong>简单的办法就是，直接将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第 k 个位置。</strong></p>
<p>为了更好地理解，我们举一个例子。假设数组 a[10]中存储了如下 5 个元素：a，b，c，d，e。</p>
<p>我们现在需要将元素 x 插入到第 3 个位置。我们只需要将 c 放入到 a[5]，将 a[2]赋值为 x 即可。最后，数组中的元素如下： a，b，x，d，e，c。</p>
<img src="/2356874721.github.io/2021/03/27/algorithm-3/3-4.jpeg" class>

<p>利用这种处理技巧，在特定场景下，在第 k 个位置插入一个元素的时间复杂度就会降为 O(1)。</p>
<h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a><strong>删除操作</strong></h4><p>跟插入数据类似，如果我们要删除第 k 个位置的数据，为了内存的连续性，也需要搬移数据，不然中间就会出现空洞，内存就不连续了。</p>
<p>和插入类似，如果删除数组末尾的数据，则最好情况时间复杂度为 O(1)；如果删除开头的数据，则最坏情况时间复杂度为 O(n)；平均情况时间复杂度也为 O(n)。</p>
<p>实际上，在某些特殊场景下，我们并不一定非得追求数组中数据的连续性。如果我们将多次删除操作集中在一起执行，删除的效率是不是会提高很多呢？</p>
<p>我们继续来看例子。数组 a[10]中存储了 8 个元素：a，b，c，d，e，f，g，h。现在，我们要依次删除 a，b，c 三个元素。</p>


<p>为了避免 d，e，f，g，h 这几个数据会被搬移三次，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。</p>
<h3 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h3><p>现在我们来思考开篇的问题：为什么大多数编程语言中，数组要从 0 开始编号，而不是从 1 开始呢？</p>
<p>从数组存储的内存模型上来看，<strong>“下标”最确切的定义应该是“偏移（offset）”</strong>。前面也讲到，如果用 a 来表示数组的首地址，a[0]就是偏移为 0 的位置，也就是首地址，a[k]就表示偏移 k 个 type_size 的位置，所以计算 a[k]的内存地址只需要用这个公式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[k]_address = base_address + k * type_size</span><br></pre></td></tr></table></figure>

<p>但是，如果数组从 1 开始计数，那我们计算数组元素 a[k]的内存地址就会变为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[k]_address &#x3D; base_address + (k-1)*type_size</span><br></pre></td></tr></table></figure>

<p><strong>对比两个公式，我们不难发现，从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。</strong></p>
<p><strong>数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从 0 开始编号，而不是从 1 开始。</strong></p>
<p>不过我认为，上面解释得再多其实都算不上压倒性的证明，说数组起始编号非 0 开始不可。所以我觉得最主要的原因可能是<strong>历史原因</strong>。</p>
<p>C 语言设计者用 0 开始计数数组下标，之后的 Java、JavaScript 等高级语言都效仿了 C 语言，或者说，为了在一定程度上减少 C 语言程序员学习 Java 的学习成本，因此继续沿用了从 0 开始计数的习惯。实际上，很多语言中数组也并不是从 0 开始计数的，比如 Matlab。甚至还有一些语言支持负数下标，比如 Python。</p>
<h3 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h3><p>我们今天学习了数组。它可以说是最基础、最简单的数据结构了。数组用一块连续的内存空间，来存储相同类型的一组数据，最大的特点就是支持随机访问，但插入、删除操作也因此变得比较低效，平均情况时间复杂度为 O(n)。</p>
<h3 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h3><p>前面我们讲到一维数组的内存寻址公式，那你可以思考一下，类比一下，二维数组的内存寻址公式是怎样的呢？</p>
<p>二维数组内存寻址：</p>
<p>对于 m * n 的数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[i][j] (i &lt; m,j &lt; n)</span><br></pre></td></tr></table></figure>

<p>的地址为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[i][j]_address = base_address + ( i * n + j) * type_size</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/27/algorithm-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/2356874721.github.io/images/avatar.gif">
      <meta itemprop="name" content="sheriff">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="警长的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2356874721.github.io/2021/03/27/algorithm-2/" class="post-title-link" itemprop="url">复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-27 14:55:14 / 修改时间：14:57:32" itemprop="dateCreated datePublished" datetime="2021-03-27T14:55:14+08:00">2021-03-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/2356874721.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">算法与数据结构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="最好、最坏情况时间复杂度"><a href="#最好、最坏情况时间复杂度" class="headerlink" title="最好、最坏情况时间复杂度"></a>最好、最坏情况时间复杂度</h3><p>上一节分析复杂度的例子都很简单，今天我们来看一个稍微复杂的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n表示数组array的长度</span></span><br><span class="line">int find(int[] array, int n, int x) &#123;</span><br><span class="line">  int i = <span class="number">0</span>;</span><br><span class="line">  int pos = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array[i] == x) pos = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你应该可以看出来，这段代码要实现的功能是，在一个无序的数组（array）中，查找变量 x 出现的位置。如果没有找到，就返回 -1。按照上节课讲的分析方法，这段代码的复杂度是 O(n)，其中，n 代表数组的长度。</p>
<p>我们在数组中查找一个数据，并不需要每次都把整个数组都遍历一遍，因为有可能中途找到就可以提前结束循环了。但是，这段代码写得不够高效。我们可以这样优化一下这段查找代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n表示数组array的长度</span></span><br><span class="line">int find(int[] array, int n, int x) &#123;</span><br><span class="line">  int i = <span class="number">0</span>;</span><br><span class="line">  int pos = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array[i] == x) &#123;</span><br><span class="line">       pos = i;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候，问题就来了。我们优化完之后，这段代码的时间复杂度还是 O(n) 吗？很显然，咱们上一节讲的分析方法，解决不了这个问题。因为，要查找的变量 x 可能出现在数组的任意位置。如果数组中第一个元素正好是要查找的变量 x，那就不需要继续遍历剩下的 n-1 个数据了，那时间复杂度就是 O(1)。但如果数组中不存在变量 x，那我们就需要把整个数组都遍历一遍，时间复杂度就成了 O(n)。所以，不同的情况下，这段代码的时间复杂度是不一样的。</p>
<p>为了表示代码在不同情况下的不同时间复杂度，我们需要引入三个概念：<strong>最好情况时间复杂度、最坏情况时间复杂度和平均情况时间复杂度</strong>。顾名思义，最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度。就像我们刚刚讲到的，在最理想的情况下，要查找的变量 x 正好是数组的第一个元素，这个时候对应的时间复杂度就是最好情况时间复杂度。同理，最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度。就像刚举的那个例子，如果数组中没有要查找的变量 x，我们需要把整个数组都遍历一遍才行，所以这种最糟糕情况下对应的时间复杂度就是最坏情况时间复杂度。</p>
<h3 id="平均情况时间复杂度"><a href="#平均情况时间复杂度" class="headerlink" title="平均情况时间复杂度"></a>平均情况时间复杂度</h3><p>我们都知道，最好情况时间复杂度和最坏情况时间复杂度对应的都是极端情况下的代码复杂度，发生的概率其实并不大。为了更好地表示平均情况下的复杂度，我们需要引入另一个概念：平均情况时间复杂度，后面我简称为平均时间复杂度。平均时间复杂度又该怎么分析呢？</p>
<p>我还是借助刚才查找变量 x 的例子来给你解释。要查找的变量 x 在数组中的位置，有 n+1 种情况：在数组的 0～n-1 位置中和不在数组中。我们把每种情况下，查找需要遍历的元素个数累加起来，然后再除以 n+1，就可以得到需要遍历的元素个数的平均值，即：</p>
<img src="/2356874721.github.io/2021/03/27/algorithm-2/2-1.jpeg" class>

<p>我们知道，时间复杂度的大 O 标记法中，可以省略掉系数、低阶、常量，所以，咱们把刚刚这个公式简化之后，得到的平均时间复杂度就是 O(n)。</p>
<p>这个结论虽然是正确的，但是计算过程稍微有点儿问题。究竟是什么问题呢？我们刚讲的这 n+1 种情况，出现的概率并不是一样的。我带你具体分析一下。</p>
<p>我们知道，要查找的变量 x，要么在数组里，要么就不在数组里。这两种情况对应的概率统计起来很麻烦，为了方便你理解，我们假设在数组中与不在数组中的概率都为 1/2。另外，要查找的数据出现在 0～n-1 这 n 个位置的概率也是一样的，为 1/n。所以，根据概率乘法法则，要查找的数据出现在 0～n-1 中任意位置的概率就是 1/(2n)。</p>
<p>因此，前面的推导过程中存在的最大问题就是，没有将各种情况发生的概率考虑进去。如果我们把每种情况发生的概率也考虑进去，那平均时间复杂度的计算过程就变成了这样：</p>
<img src="/2356874721.github.io/2021/03/27/algorithm-2/2-2.jpeg" class>

<p>这个值就是概率论中的加权平均值，也叫作期望值，所以平均时间复杂度的全称应该叫加权平均时间复杂度或者期望时间复杂度。</p>
<p>引入概率之后，前面那段代码的加权平均值为 (3n+1)/4。用大 O 表示法来表示，去掉系数和常量，这段代码的加权平均时间复杂度仍然是 O(n)。</p>
<p>你可能会说，平均时间复杂度分析好复杂啊，还要涉及概率论的知识。实际上，在大多数情况下，我们并不需要区分最好、最坏、平均情况时间复杂度三种情况。像我们上一节课举的那些例子那样，很多时候，我们使用一个复杂度就可以满足需求了。只有同一块代码在不同的情况下，时间复杂度有量级的差距，我们才会使用这三种复杂度表示法来区分。</p>
<h3 id="均摊时间复杂度"><a href="#均摊时间复杂度" class="headerlink" title="均摊时间复杂度"></a>均摊时间复杂度</h3><p>到此为止，你应该已经掌握了算法复杂度分析的大部分内容了。下面我要给你讲一个更加高级的概念，均摊时间复杂度，以及它对应的分析方法，摊还分析（或者叫平摊分析）。</p>
<p>均摊时间复杂度，听起来跟平均时间复杂度有点儿像。对于初学者来说，这两个概念确实非常容易弄混。我前面说了，大部分情况下，我们并不需要区分最好、最坏、平均三种复杂度。平均复杂度只在某些特殊情况下才会用到，而均摊时间复杂度应用的场景比它更加特殊、更加有限。</p>
<p>老规矩，我还是借助一个具体的例子来帮助你理解。（当然，这个例子只是我为了方便讲解想出来的，实际上没人会这么写。）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array表示一个长度为n的数组</span></span><br><span class="line"><span class="comment">// 代码中的array.length就等于n</span></span><br><span class="line">int[] array = <span class="keyword">new</span> int[n];</span><br><span class="line">int count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> insert(int val) &#123;</span><br><span class="line">   <span class="keyword">if</span> (count == array.length) &#123;</span><br><span class="line">      int sum = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; array.length; ++i) &#123;</span><br><span class="line">         sum = sum + array[i];</span><br><span class="line">      &#125;</span><br><span class="line">      array[<span class="number">0</span>] = sum;</span><br><span class="line">      count = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   array[count] = val;</span><br><span class="line">   ++count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我先来解释一下这段代码。这段代码实现了一个往数组中插入数据的功能。当数组满了之后，也就是代码中的 count == array.length 时，我们用 for 循环遍历数组求和，并清空数组，将求和之后的 sum 值放到数组的第一个位置，然后再将新的数据插入。但如果数组一开始就有空闲空间，则直接将数据插入数组。</p>
<p>那这段代码的时间复杂度是多少呢？你可以先用我们刚讲到的三种时间复杂度的分析方法来分析一下。</p>
<p>最理想的情况下，数组中有空闲空间，我们只需要将数据插入到数组下标为 count 的位置就可以了，所以最好情况时间复杂度为 O(1)。最坏的情况下，数组中没有空闲空间了，我们需要先做一次数组的遍历求和，然后再将数据插入，所以最坏情况时间复杂度为 O(n)。</p>
<p>假设数组的长度是 n，根据数据插入的位置的不同，我们可以分为 n 种情况，每种情况的时间复杂度是 O(1)。除此之外，还有一种“额外”的情况，就是在数组没有空闲空间时插入一个数据，这个时候的时间复杂度是 O(n)。而且，这 n+1 种情况发生的概率一样，都是 1/(n+1)。所以，根据加权平均的计算方法，我们求得的平均时间复杂度就是：</p>
<img src="/2356874721.github.io/2021/03/27/algorithm-2/2-3.jpeg" class>

<p>对于 insert() 函数来说，O(1) 时间复杂度的插入和 O(n) 时间复杂度的插入，出现的频率是非常有规律的，而且有一定的前后时序关系，一般都是一个 O(n) 插入之后，紧跟着 n-1 个 O(1) 的插入操作，循环往复。</p>
<p>所以，针对这样一种特殊场景的复杂度分析，我们并不需要像之前讲平均复杂度分析方法那样，找出所有的输入情况及相应的发生概率，然后再计算加权平均值。</p>
<p>针对这种特殊的场景，我们引入了一种更加简单的分析方法：摊还分析法，通过摊还分析得到的时间复杂度我们起了一个名字，叫均摊时间复杂度。</p>
<p>那究竟如何使用摊还分析法来分析算法的均摊时间复杂度呢？</p>
<p>我们还是继续看在数组中插入数据的这个例子。每一次 O(n) 的插入操作，都会跟着 n-1 次 O(1) 的插入操作，所以把耗时多的那次操作均摊到接下来的 n-1 次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是 O(1)。这就是均摊分析的大致思路。你都理解了吗？</p>
<p>均摊时间复杂度和摊还分析应用场景比较特殊，所以我们并不会经常用到。为了方便你理解、记忆，我这里简单总结一下它们的应用场景。如果你遇到了，知道是怎么回事儿就行了。</p>
<p>对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。</p>
<h3 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h3><p>今天我们学习了几个复杂度分析相关的概念，分别有：最好情况时间复杂度、最坏情况时间复杂度、平均情况时间复杂度、均摊时间复杂度。之所以引入这几个复杂度概念，是因为，同一段代码，在不同输入的情况下，复杂度量级有可能是不一样的。</p>
<p>在引入这几个概念之后，我们可以更加全面地表示一段代码的执行效率。而且，这几个概念理解起来都不难。最好、最坏情况下的时间复杂度分析起来比较简单，但平均、均摊两个复杂度分析相对比较复杂。如果你觉得理解得还不是很深入，不用担心，在后续具体的数据结构和算法学习中，我们可以继续慢慢实践！</p>
<h3 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h3><p>我们今天学的几个复杂度分析方法，你都掌握了吗？你可以用今天学习的知识，来分析一下下面这个 add() 函数的时间复杂度。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局变量，大小为10的数组array，长度len，下标i。</span></span><br><span class="line">int array[] = <span class="keyword">new</span> int[<span class="number">10</span>]; </span><br><span class="line">int len = <span class="number">10</span>;</span><br><span class="line">int i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 往数组中添加一个元素</span></span><br><span class="line"><span class="keyword">void</span> add(int element) &#123;</span><br><span class="line">   <span class="keyword">if</span> (i &gt;= len) &#123; <span class="comment">// 数组空间不够了</span></span><br><span class="line">     <span class="comment">// 重新申请一个2倍大小的数组空间</span></span><br><span class="line">     int new_array[] = <span class="keyword">new</span> int[len*<span class="number">2</span>];</span><br><span class="line">     <span class="comment">// 把原来array数组中的数据依次copy到new_array</span></span><br><span class="line">     <span class="keyword">for</span> (int j = <span class="number">0</span>; j &lt; len; ++j) &#123;</span><br><span class="line">       new_array[j] = array[j];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// new_array复制给array，array现在大小就是2倍len了</span></span><br><span class="line">     array = new_array;</span><br><span class="line">     len = <span class="number">2</span> * len;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 将element放到下标为i的位置，下标i加一</span></span><br><span class="line">   array[i] = element;</span><br><span class="line">   ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最好是O(1)，最差是O(n), 均摊是O(1)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/20/algorithm-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/2356874721.github.io/images/avatar.gif">
      <meta itemprop="name" content="sheriff">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="警长的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2356874721.github.io/2021/03/20/algorithm-1/" class="post-title-link" itemprop="url">复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-20 13:11:32 / 修改时间：13:19:39" itemprop="dateCreated datePublished" datetime="2021-03-20T13:11:32+08:00">2021-03-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/2356874721.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">算法与数据结构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>复杂度分析是整个算法学习的精髓，只要掌握了它，数据结构和算法的内容基本上就掌握了一半。</p>
<h3 id="大-O-复杂度表示法"><a href="#大-O-复杂度表示法" class="headerlink" title="大 O 复杂度表示法"></a>大 O 复杂度表示法</h3><p>算法的执行效率，粗略地讲，就是算法代码执行的时间。但是，如何在不运行代码的情况下，用“肉眼”得到一段代码的执行时间呢？</p>
<p>下面一块来估算一下这段代码的执行时间，假设每行代码执行的时间都一样，为 unit_time。在这个假设的基础之上，这段代码的总执行时间是多少呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int cal(int n) &#123;</span><br><span class="line">  int sum = <span class="number">0</span>;</span><br><span class="line">  int i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt;= n; ++i) &#123;</span><br><span class="line">    sum = sum + i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第2、3行分别是1<em>unit_time，4、5上是一个循环体，要执行n次，所以是2n</em>unit_time，所以这段代码总的执行时间就是 (2n+2)*unit_time。</p>
<p>按照这个分析思路，我们再来看这段代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int cal(int n) &#123;</span><br><span class="line">   int sum = <span class="number">0</span>;</span><br><span class="line">   int i = <span class="number">1</span>;</span><br><span class="line">   int j = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (; i &lt;= n; ++i) &#123;</span><br><span class="line">     j = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span> (; j &lt;= n; ++j) &#123;</span><br><span class="line">       sum = sum +  i * j;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>第2、3、4共3unit_time，第5、6行是2n unit_time，第7、8行共2n<sup>2</sup> unit_time，总的执行时间就是T(n) = 2n<sup>2</sup>+2n+3 unit_time，我们可以得到一个非常重要的规律，那就是，所有代码的执行时间 T(n) 与每行代码的执行次数 f(n) 成正比。</p>
<p>T(n) = O(f(n))</p>
<p>T(n) 表示代码执行的时间</p>
<p>n 表示数据规模的大小</p>
<p>f(n) 表示代码执行的次数总和</p>
<p>O表示代码的执行时间 T(n) 与 f(n) 表达式成正比</p>
<p>大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。</p>
<p>当 n 很大时，你可以把它想象成 10000、100000。而公式中的<strong>低阶、常量、系数</strong>三部分并不左右增长趋势，所以都可以忽略。我们只需要记录一个<strong>最大量级</strong>就可以了，如果用大 O 表示法表示刚讲的那两段代码的时间复杂度，就可以记为：T(n) = O(n)； T(n) = O(n<sup>2</sup>)</p>
<h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><p>那么如何分析一段代码的时间复杂度，下面有3个比较实用的方法</p>
<h4 id="只关注循环执行次数最多的一段代码"><a href="#只关注循环执行次数最多的一段代码" class="headerlink" title="只关注循环执行次数最多的一段代码"></a>只关注循环执行次数最多的一段代码</h4><p>大 O 这种复杂度表示方法只是表示一种变化趋势。我们通常会<strong>忽略掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级</strong>就可以了。所以，我们在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了。这段核心代码执行次数的 n 的量级，就是整段要分析代码的时间复杂度。</p>
<h4 id="加法法则：总复杂度等于量级最大的那段代码的复杂度"><a href="#加法法则：总复杂度等于量级最大的那段代码的复杂度" class="headerlink" title="加法法则：总复杂度等于量级最大的那段代码的复杂度"></a>加法法则：总复杂度等于量级最大的那段代码的复杂度</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int cal(int n) &#123;</span><br><span class="line">   int sum_1 = <span class="number">0</span>; 								<span class="comment">// O(1)</span></span><br><span class="line">   int p = <span class="number">1</span>; 										<span class="comment">// O(1)</span></span><br><span class="line">   <span class="keyword">for</span> (; p &lt; <span class="number">100</span>; ++p) &#123;					<span class="comment">// O(100)</span></span><br><span class="line">     sum_1 = sum_1 + p; 					<span class="comment">// O(100)</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   int sum_2 = <span class="number">0</span>; 								<span class="comment">// O(1)</span></span><br><span class="line">   int q = <span class="number">1</span>; 										<span class="comment">// O(1)</span></span><br><span class="line">   <span class="keyword">for</span> (; q &lt; n; ++q) &#123; 					<span class="comment">// O(n)</span></span><br><span class="line">     sum_2 = sum_2 + q;						<span class="comment">// O(n)</span></span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   int sum_3 = <span class="number">0</span>; 								<span class="comment">// O(1)</span></span><br><span class="line">   int i = <span class="number">1</span>;											<span class="comment">// O(1)</span></span><br><span class="line">   int j = <span class="number">1</span>;											<span class="comment">// O(1)</span></span><br><span class="line">   <span class="keyword">for</span> (; i &lt;= n; ++i) &#123;					<span class="comment">// O(n)</span></span><br><span class="line">     j = <span class="number">1</span>; 											<span class="comment">// O(n)</span></span><br><span class="line">     <span class="keyword">for</span> (; j &lt;= n; ++j) &#123;				<span class="comment">// O(n2)</span></span><br><span class="line">       sum_3 = sum_3 +  i * j;		<span class="comment">// O(n2)</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> sum_1 + sum_2 + sum_3;	<span class="comment">// O(1)	</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的最大量级是O(n<sup>2</sup>)，那么整段代码的时间复杂度就是O(n<sup>2</sup>)</p>
<h4 id="乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积"><a href="#乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积" class="headerlink" title="乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积"></a>乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int cal(int n) &#123;</span><br><span class="line">   int ret = <span class="number">0</span>; </span><br><span class="line">   int i = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (; i &lt; n; ++i) &#123; <span class="comment">// O(n)</span></span><br><span class="line">     ret = ret + f(i); <span class="comment">// O(n)*O(n)=O(n*n)=O(n2)</span></span><br><span class="line">   &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> int f(int n) &#123;</span><br><span class="line">  int sum = <span class="number">0</span>;</span><br><span class="line">  int i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">    sum = sum + i;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="几种常见时间复杂度实例分析"><a href="#几种常见时间复杂度实例分析" class="headerlink" title="几种常见时间复杂度实例分析"></a>几种常见时间复杂度实例分析</h4><p>这些复杂度量级几乎涵盖了今后可以接触的所有代码的复杂度量级。对于以下复杂度量级，我们可以粗略地分为两类，多项式量级和非多项式量级。其中，非多项式量级只有两个：O(2n) 和 O(n!)。我们把时间复杂度为非多项式量级的算法问题叫作 NP（Non-Deterministic Polynomial，非确定多项式）问题。当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，非多项式时间复杂度的算法其实是非常低效的算法。因此，关于 NP 时间复杂度我就不展开讲了。我们主要来看几种常见的多项式时间复杂度。</p>
<img src="/2356874721.github.io/2021/03/20/algorithm-1/1.jpg" class>

<h5 id="O-1"><a href="#O-1" class="headerlink" title="O(1)"></a>O(1)</h5><p>首先你必须明确一个概念，O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。比如这段代码，即便有 3 行，它的时间复杂度也是 O(1），而不是 O(3)。只要<strong>代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们都记作 O(1)</strong>。或者说，<strong>一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int i = <span class="number">8</span>;</span><br><span class="line">int j = <span class="number">6</span>;</span><br><span class="line">int sum = i + j;</span><br></pre></td></tr></table></figure>

<h5 id="O-logn-、O-nlogn"><a href="#O-logn-、O-nlogn" class="headerlink" title="O(logn)、O(nlogn)"></a>O(logn)、O(nlogn)</h5><p>对数阶时间复杂度非常常见，同时也是最难分析的一种时间复杂度。我通过一个例子来说明一下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= n)  &#123;</span><br><span class="line">  i = i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据我们前面讲的复杂度分析方法，第三行代码是循环执行次数最多的。所以，我们只要能计算出这行代码被执行了多少次，就能知道整段代码的时间复杂度。</p>
<p>从代码中可以看出，变量 i 的值从 1 开始取，每循环一次就乘以 2。如果我把它一个一个列出来，就应该是这个样子的。</p>
<img src="/2356874721.github.io/2021/03/20/algorithm-1/2.jpg" class>

<p>所以，我们只要知道 x 值是多少，就知道这行代码执行的次数了。通过 2<sup>x</sup>=n 求解 x ，则x=log<sub>2</sub>n</p>
<p>再看一个例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= n)  &#123;</span><br><span class="line">  i = i * <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>刚刚讲的思路，很简单就能看出来，这段代码就是3<sup>x</sup>=n 求解 x，这段代码的时间复杂度为 O(log<sub>3</sub>n)。</p>
<p>实际上，不管是以 2 为底、以 3 为底，还是以 10 为底，我们可以把所有对数阶的时间复杂度都记为 O(logn)，我们知道，对数之间是可以互相转换的，log<sub>3</sub>n就等于log<sub>3</sub>2 * log<sub>2</sub>n，忽略常量级log<sub>3</sub>2，那么就有O(log<sub>3</sub>n) = O(log<sub>2</sub>n) ，在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为 O(logn)。</p>
<p>如果理解了前面讲的 O(logn)，那 O(nlogn) 就很容易理解了。还记得乘法法则吗？如果一段代码的时间复杂度是 O(logn)，我们循环执行 n 遍，时间复杂度就是 O(nlogn) 了。而且，O(nlogn) 也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是 O(nlogn)。</p>
<h5 id="O-m-n-、O-m-n"><a href="#O-m-n-、O-m-n" class="headerlink" title="O(m+n)、O(m*n)"></a>O(m+n)、O(m*n)</h5><p>我们再来讲一种跟前面都不一样的时间复杂度，代码的复杂度由两个数据的规模来决定。老规矩，先看代码！</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int cal(int m, int n) &#123;</span><br><span class="line">  int sum_1 = <span class="number">0</span>;</span><br><span class="line">  int i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; m; ++i) &#123;</span><br><span class="line">    sum_1 = sum_1 + i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  int sum_2 = <span class="number">0</span>;</span><br><span class="line">  int j = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; j &lt; n; ++j) &#123;</span><br><span class="line">    sum_2 = sum_2 + j;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum_1 + sum_2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中可以看出，m 和 n 是表示两个数据规模。我们无法事先评估 m 和 n 谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是 O(m+n)。</p>
<h3 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h3><p>咱们花了很长时间讲大 O 表示法和时间复杂度分析，理解了前面讲的内容，空间复杂度分析方法学起来就非常简单了。</p>
<p>时间复杂度的全称是渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系。类比一下，空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> print(int n) &#123;</span><br><span class="line">  int i = <span class="number">0</span>;</span><br><span class="line">  int[] a = <span class="keyword">new</span> int[n];</span><br><span class="line">  <span class="keyword">for</span> (i; i &lt;n; ++i) &#123;</span><br><span class="line">    a[i] = i * i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    print out a[i]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟时间复杂度分析一样，我们可以看到，第 2 行代码中，我们申请了一个空间存储变量 i，但是它是常量阶的，跟数据规模 n 没有关系，所以我们可以忽略。第 3 行申请了一个大小为 n 的 int 类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是 O(n)。</p>
<p>我们常见的空间复杂度就是 O(1)、O(n)、O(n2 )，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。而且，空间复杂度分析比时间复杂度分析要简单很多。</p>
<h3 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h3><p>复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的算法，执行效率越低。常见的复杂度并不多，从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n2 )。</p>
<img src="/2356874721.github.io/2021/03/20/algorithm-1/3.jpg" class>

<h3 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h3><p>有人说，我们项目之前都会进行性能测试，再做代码的时间复杂度、空间复杂度分析，是不是多此一举呢？而且，每段代码都分析一下时间复杂度、空间复杂度，是不是很浪费时间呢？你怎么看待这个问题呢？</p>
<p>我不认为是多此一举，渐进时间，空间复杂度分析为我们提供了一个很好的理论分析的方向，并且它是宿主平台无关的，能够让我们对我们的程序或算法有一个大致的认识，让我们知道，比如在最坏的情况下程序的执行效率如何，同时也为我们交流提供了一个不错的桥梁，我们可以说，算法1的时间复杂度是O(n)，算法2的时间复杂度是O(logN)，这样我们立刻就对不同的算法有了一个“效率”上的感性认识。</p>
<p>当然，渐进式时间，空间复杂度分析只是一个理论模型，只能提供给粗略的估计分析，我们不能直接断定就觉得O(logN)的算法一定优于O(n), 针对不同的宿主环境，不同的数据集，不同的数据量的大小，在实际应用上面可能真正的性能会不同，个人觉得，针对不同的实际情况，进而进行一定的性能基准测试是很有必要的，比如在统一一批手机上(同样的硬件，系统等等)进行横向基准测试，进而选择适合特定应用场景下的最有算法。</p>
<p>综上所述，渐进式时间，空间复杂度分析与性能基准测试并不冲突，而是相辅相成的，但是一个低阶的时间复杂度程序有极大的可能性会优于一个高阶的时间复杂度程序，所以在实际编程中，时刻关心理论时间，空间度模型是有助于产出效率高的程序的，同时，因为渐进式时间，空间复杂度分析只是提供一个粗略的分析模型，因此也不会浪费太多时间，重点在于在编程时，要具有这种复杂度分析的思维。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/10/linkage/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/2356874721.github.io/images/avatar.gif">
      <meta itemprop="name" content="sheriff">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="警长的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2356874721.github.io/2021/01/10/linkage/" class="post-title-link" itemprop="url">商品属性联动</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-01-10 15:40:24 / 修改时间：17:30:04" itemprop="dateCreated datePublished" datetime="2021-01-10T15:40:24+08:00">2021-01-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/2356874721.github.io/categories/js/" itemprop="url" rel="index"><span itemprop="name">js</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="商品属性联动"><a href="#商品属性联动" class="headerlink" title="商品属性联动"></a>商品属性联动</h2><p>本篇主要介绍电商系统商品属性联动选择的效果。最终实现的效果如下：</p>
<img src="/2356874721.github.io/2021/01/10/linkage/1.gif" class>

<h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><p>接口返回的数据格式如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123; <span class="attr">color</span>: <span class="string">"红"</span>, <span class="attr">size</span>: <span class="string">"大"</span>, <span class="attr">model</span>: <span class="string">"A"</span>, <span class="attr">stock</span>: <span class="string">"0"</span>, <span class="attr">skuId</span>: <span class="string">"100001"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">color</span>: <span class="string">"白"</span>, <span class="attr">size</span>: <span class="string">"大"</span>, <span class="attr">model</span>: <span class="string">"A"</span>, <span class="attr">stock</span>: <span class="string">"1"</span>, <span class="attr">skuId</span>: <span class="string">"100002"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">color</span>: <span class="string">"白"</span>, <span class="attr">size</span>: <span class="string">"中"</span>, <span class="attr">model</span>: <span class="string">"B"</span>, <span class="attr">stock</span>: <span class="string">"1"</span>, <span class="attr">skuId</span>: <span class="string">"100003"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">color</span>: <span class="string">"蓝"</span>, <span class="attr">size</span>: <span class="string">"小"</span>, <span class="attr">model</span>: <span class="string">"C"</span>, <span class="attr">stock</span>: <span class="string">"1"</span>, <span class="attr">skuId</span>: <span class="string">"100004"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">color</span>: <span class="string">"红"</span>, <span class="attr">size</span>: <span class="string">"小"</span>, <span class="attr">model</span>: <span class="string">"A"</span>, <span class="attr">stock</span>: <span class="string">"1"</span>, <span class="attr">skuId</span>: <span class="string">"100005"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">color</span>: <span class="string">"红"</span>, <span class="attr">size</span>: <span class="string">"中"</span>, <span class="attr">model</span>: <span class="string">"A"</span>, <span class="attr">stock</span>: <span class="string">"0"</span>, <span class="attr">skuId</span>: <span class="string">"100006"</span> &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>color：商品的颜色</li>
<li>size：商品的尺寸</li>
<li>model：商品的型号</li>
<li>stock：商品的库存</li>
<li>skuId：商品的 id，也是最终我们要传回接口的值，该值是由 color、size、model 三个值共同决定的</li>
</ul>
<h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>实现该功能最重要的就是对返回的数据进行处理，可以把 color、size、model 这三个属性值中所有的属性先进行统计，属性有：<strong>红、白、蓝、大、中、小、A、B、C</strong>，分别标记为：<strong>1、2、3、4、5、6、7、8、9</strong>，属性和标记对应：<strong>红(1)、白(2)、蓝(3)、大(4)、中(5)、小(6)、A(7)、B(8)、C(9)</strong>，对应所以对于接口返回的数据编码如下：<strong>[1,4,7]、[2,4,7]、[2,5,8]、[3,6,9]、[1,6,7]、[1,5,7]</strong>。</p>
<p>数组中每个元素以#分割，数组之间以 S 分割，最后得到一条数据的编码，当然这个编码是所有数据的编码，包含库存 stock 为 0 的：<strong>S#1#4#7#S#2#4#7#S#2#5#8#S#3#6#9#S#1#6#7#S#1#5#7#S</strong>，实际上我们只需对 stock 大于 0 的数据进行编码：<strong>S#2#4#7#S#2#5#8#S#3#6#9#S#1#6#7#S</strong>，最后使用正则匹配，来实现属性的选中和禁用状态，以 color 为例，正则如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stockSign:S#2#4#7#S#2#5#8#S#3#6#9#S#1#6#7#S</span></span><br><span class="line"><span class="built_in">RegExp</span>(</span><br><span class="line">  <span class="string">`S#<span class="subst">$&#123;prMap[item]&#125;</span>#<span class="subst">$&#123;prMap[currentSize] || <span class="string">"([0-9]+)"</span>&#125;</span>#<span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">    prMap[currentModel] || <span class="string">"([0-9]+)"</span></span></span></span><br><span class="line"><span class="string"><span class="subst">  &#125;</span>#S`</span></span><br><span class="line">).test(stockSign)</span><br><span class="line">  ? <span class="string">""</span></span><br><span class="line">  : <span class="string">"disable"</span></span><br></pre></td></tr></table></figure>

<p>对于 color 来说，只需要关心 S 后面的第一个标记，<strong>S#<u>2</u>#4#7#S#<u>2</u>#5#8#S#<u>3</u>#6#9#S#<u>1</u>#6#7#S</strong>，size 和 model 匹配 0-9 任意数字即可，如果该 color 下面没有匹配上 0-9 的任意数字，那么说明，size 和 model 是 disabled，对于 size 和 model 的匹配同理。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;home&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;line&quot;&gt;</span><br><span class="line">      &lt;span&gt;颜色:&lt;&#x2F;span&gt;</span><br><span class="line">      &lt;span</span><br><span class="line">        :class&#x3D;&quot;[</span><br><span class="line">          item &#x3D;&#x3D; currentColor ? &#39;active&#39; : &#39;&#39;,</span><br><span class="line">          RegExp(</span><br><span class="line">            &#96;S#$&#123;prMap[item]&#125;#$&#123;prMap[currentSize] || &#39;([0-9]+)&#39;&#125;#$&#123;</span><br><span class="line">              prMap[currentModel] || &#39;([0-9]+)&#39;</span><br><span class="line">            &#125;#S&#96;</span><br><span class="line">          ).test(stockSign)</span><br><span class="line">            ? &#39;&#39;</span><br><span class="line">            : &#39;disable&#39;,</span><br><span class="line">        ]&quot;</span><br><span class="line">        @click&#x3D;&quot;itemclick(&#39;currentColor&#39;, item, $event)&quot;</span><br><span class="line">        class&#x3D;&quot;item&quot;</span><br><span class="line">        v-for&#x3D;&quot;item in ocolorArray&quot;</span><br><span class="line">        :key&#x3D;&quot;item&quot;</span><br><span class="line">        &gt;&#123;&#123; item &#125;&#125;&lt;&#x2F;span</span><br><span class="line">      &gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div class&#x3D;&quot;line&quot;&gt;</span><br><span class="line">      &lt;span&gt;大小:&lt;&#x2F;span&gt;</span><br><span class="line">      &lt;span</span><br><span class="line">        @click&#x3D;&quot;itemclick(&#39;currentSize&#39;, item, $event)&quot;</span><br><span class="line">        class&#x3D;&quot;item&quot;</span><br><span class="line">        :class&#x3D;&quot;[</span><br><span class="line">          item &#x3D;&#x3D; currentSize ? &#39;active&#39; : &#39;&#39;,</span><br><span class="line">          RegExp(</span><br><span class="line">            &#96;S#$&#123;prMap[currentColor] || &#39;([0-9]+)&#39;&#125;#$&#123;prMap[item]&#125;#$&#123;</span><br><span class="line">              prMap[currentModel] || &#39;([0-9]+)&#39;</span><br><span class="line">            &#125;#S&#96;</span><br><span class="line">          ).test(stockSign)</span><br><span class="line">            ? &#39;&#39;</span><br><span class="line">            : &#39;disable&#39;,</span><br><span class="line">        ]&quot;</span><br><span class="line">        v-for&#x3D;&quot;item in osizeArray&quot;</span><br><span class="line">        :key&#x3D;&quot;item&quot;</span><br><span class="line">        &gt;&#123;&#123; item &#125;&#125;&lt;&#x2F;span</span><br><span class="line">      &gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div class&#x3D;&quot;line&quot;&gt;</span><br><span class="line">      &lt;span&gt;型号:&lt;&#x2F;span&gt;</span><br><span class="line">      &lt;span</span><br><span class="line">        :class&#x3D;&quot;[</span><br><span class="line">          item &#x3D;&#x3D; currentModel ? &#39;active&#39; : &#39;&#39;,</span><br><span class="line">          RegExp(</span><br><span class="line">            &#96;S#$&#123;prMap[currentColor] || &#39;([0-9]+)&#39;&#125;#$&#123;</span><br><span class="line">              prMap[currentSize] || &#39;([0-9]+)&#39;</span><br><span class="line">            &#125;#$&#123;prMap[item]&#125;#S&#96;</span><br><span class="line">          ).test(stockSign)</span><br><span class="line">            ? &#39;&#39;</span><br><span class="line">            : &#39;disable&#39;,</span><br><span class="line">        ]&quot;</span><br><span class="line">        @click&#x3D;&quot;itemclick(&#39;currentModel&#39;, item, $event)&quot;</span><br><span class="line">        class&#x3D;&quot;item&quot;</span><br><span class="line">        v-for&#x3D;&quot;item in omodelArray&quot;</span><br><span class="line">        :key&#x3D;&quot;item&quot;</span><br><span class="line">        &gt;&#123;&#123; item &#125;&#125;&lt;&#x2F;span</span><br><span class="line">      &gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">&#x2F;&#x2F; @ is an alias to &#x2F;src</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;&#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      &#x2F;&#x2F; mockData</span><br><span class="line">      skuList: [</span><br><span class="line">        &#123; color: &quot;红&quot;, size: &quot;大&quot;, model: &quot;A&quot;, stock: &quot;0&quot;, skuId: &quot;100001&quot; &#125;,</span><br><span class="line">        &#123; color: &quot;白&quot;, size: &quot;大&quot;, model: &quot;A&quot;, stock: &quot;1&quot;, skuId: &quot;100002&quot; &#125;,</span><br><span class="line">        &#123; color: &quot;白&quot;, size: &quot;中&quot;, model: &quot;B&quot;, stock: &quot;1&quot;, skuId: &quot;100003&quot; &#125;,</span><br><span class="line">        &#123; color: &quot;蓝&quot;, size: &quot;小&quot;, model: &quot;C&quot;, stock: &quot;1&quot;, skuId: &quot;100004&quot; &#125;,</span><br><span class="line">        &#123; color: &quot;红&quot;, size: &quot;大&quot;, model: &quot;A&quot;, stock: &quot;1&quot;, skuId: &quot;100005&quot; &#125;,</span><br><span class="line">        &#123; color: &quot;红&quot;, size: &quot;大&quot;, model: &quot;A&quot;, stock: &quot;0&quot;, skuId: &quot;100006&quot; &#125;,</span><br><span class="line">      ],</span><br><span class="line">      &#x2F;&#x2F; color数组  [ &quot;红&quot;, &quot;白&quot;, &quot;蓝&quot; ]</span><br><span class="line">      ocolorArray: [],</span><br><span class="line">      &#x2F;&#x2F; size数组 [ &quot;大&quot;, &quot;中&quot;, &quot;小&quot; ]</span><br><span class="line">      osizeArray: [],</span><br><span class="line">      &#x2F;&#x2F; model数组 [ &quot;A&quot;, &quot;B&quot;, &quot;C&quot; ]</span><br><span class="line">      omodelArray: [],</span><br><span class="line">      &#x2F;&#x2F; 当前size</span><br><span class="line">      currentSize: &quot;&quot;,</span><br><span class="line">      &#x2F;&#x2F; 当前color</span><br><span class="line">      currentColor: &quot;&quot;,</span><br><span class="line">      &#x2F;&#x2F; 当前model</span><br><span class="line">      currentModel: &quot;&quot;,</span><br><span class="line">      &#x2F;&#x2F; map</span><br><span class="line">      prMap: &#123;&#125;,</span><br><span class="line">      &#x2F;&#x2F; 编码</span><br><span class="line">      stockSign: &quot;&quot;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    this.filterData()</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    filterData() &#123;</span><br><span class="line">      let colorArray &#x3D; []</span><br><span class="line">      let sizeArray &#x3D; []</span><br><span class="line">      let modelArray &#x3D; []</span><br><span class="line">      let oIndex &#x3D; 0</span><br><span class="line">      let strArray &#x3D; []</span><br><span class="line">      this.skuList.forEach((item) &#x3D;&gt; &#123;</span><br><span class="line">        if (!this.prMap[item.color]) &#123;</span><br><span class="line">          this.prMap[item.color] &#x3D; oIndex</span><br><span class="line">          oIndex++</span><br><span class="line">        &#125;</span><br><span class="line">        if (!this.prMap[item.size]) &#123;</span><br><span class="line">          this.prMap[item.size] &#x3D; oIndex</span><br><span class="line">          oIndex++</span><br><span class="line">        &#125;</span><br><span class="line">        if (!this.prMap[item.model]) &#123;</span><br><span class="line">          this.prMap[item.model] &#x3D; oIndex</span><br><span class="line">          oIndex++</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 有库存的才编码</span><br><span class="line">        if (item.stock &gt; 0) &#123;</span><br><span class="line">          let str &#x3D;</span><br><span class="line">            &quot;#&quot; +</span><br><span class="line">            [</span><br><span class="line">              this.prMap[item.color],</span><br><span class="line">              this.prMap[item.size],</span><br><span class="line">              this.prMap[item.model],</span><br><span class="line">            ].join(&quot;#&quot;) +</span><br><span class="line">            &quot;#&quot;</span><br><span class="line">          strArray.push(str)</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 取出color size model属性值</span><br><span class="line">        colorArray.push(item.color)</span><br><span class="line">        sizeArray.push(item.size)</span><br><span class="line">        modelArray.push(item.model)</span><br><span class="line">      &#125;)</span><br><span class="line">      &#x2F;&#x2F; color size model属性值去重，用于展示</span><br><span class="line">      this.ocolorArray &#x3D; Array.from(new Set(colorArray))</span><br><span class="line">      this.osizeArray &#x3D; Array.from(new Set(sizeArray))</span><br><span class="line">      this.omodelArray &#x3D; Array.from(new Set(modelArray))</span><br><span class="line">      this.stockSign &#x3D; &quot;S&quot; + strArray.join(&quot;S&quot;) + &quot;S&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    itemclick(target, item, e) &#123;</span><br><span class="line">      if (e.target.className.indexOf(&quot;disable&quot;) !&#x3D; &quot;-1&quot;) &#123;</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 给currentSize、currentColor、currentModel赋值 选中和反选</span><br><span class="line">      if (this[target] &#x3D;&#x3D; item) &#123;</span><br><span class="line">        this[target] &#x3D; &quot;&quot;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        this[target] &#x3D; item</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;style lang&#x3D;&quot;less&quot;&gt;</span><br><span class="line">.line &#123;</span><br><span class="line">  margin-top: 20px;</span><br><span class="line">&#125;</span><br><span class="line">.item &#123;</span><br><span class="line">  font-size: 16px;</span><br><span class="line">  border: 1px solid #e2e2e2;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  width: 40px;</span><br><span class="line">  height: 40px;</span><br><span class="line">  margin-left: 15px;</span><br><span class="line">  cursor: pointer;</span><br><span class="line">  text-align: center;</span><br><span class="line">  line-height: 40px;</span><br><span class="line">&#125;</span><br><span class="line">.item.active &#123;</span><br><span class="line">  color: #f60;</span><br><span class="line">  border-color: #f60;</span><br><span class="line">&#125;</span><br><span class="line">.item.disable &#123;</span><br><span class="line">  color: #e2e2e2;</span><br><span class="line">  border: 1px dashed #e2e2e2;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/29/interview-first/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/2356874721.github.io/images/avatar.gif">
      <meta itemprop="name" content="sheriff">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="警长的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2356874721.github.io/2020/07/29/interview-first/" class="post-title-link" itemprop="url">面试总结(字节)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-29 21:16:47" itemprop="dateCreated datePublished" datetime="2020-07-29T21:16:47+08:00">2020-07-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-08 23:13:03" itemprop="dateModified" datetime="2020-08-08T23:13:03+08:00">2020-08-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/2356874721.github.io/categories/interview/" itemprop="url" rel="index"><span itemprop="name">interview</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>周末面试了字节跳动，内心慌得一批，面试表现的也很不好，但是生活总是要继续的，跌倒了不可怕，拍拍身上的土，继续往前走。但是这次面试也让我反思了一些东西，也是很有收获的。</p>
<h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p>第一个问题是说出这段代码的输出</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Object</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">正确结果是会报错：Uncaught SyntaxError: Unexpected token &#39;instanceof&#39;</span><br><span class="line">原因：instanceof 的前操作数需要是一个对象，但是&#123;&#125;同时也是空的代码块，所以js无法识别&#123;&#125;是代码块还是空对象，因此会报错</span><br></pre></td></tr></table></figure>
<p>关于instance，这里再深入的理解一下，<code>instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上。</code>。</p>
<h3 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h3><p>instanceof的普通的用法，obj instanceof Object 检测Object.prototype是否存在于参数obj的原型链上</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person()</span><br><span class="line">person <span class="keyword">instanceof</span> Person <span class="comment">// ==&gt; true</span></span><br></pre></td></tr></table></figure>
<h3 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h3><p>继承中判断实例是否属于它的父类</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent()</span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child()</span><br><span class="line">child <span class="keyword">instanceof</span> Parent <span class="comment">// ==&gt; true</span></span><br></pre></td></tr></table></figure>
<h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><p><code>var arr = [1,3,4,2,1,3,4]</code></p>
<h3 id="es6-Set"><a href="#es6-Set" class="headerlink" title="es6 Set"></a>es6 Set</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [...new <span class="built_in">Set</span>(arr)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>new Set()</code>能够把数组去重，但是返回的是一个类数组，需要转换成数组<br><code>Array.from和...</code>能够把类数组转换成数组</p>
<h3 id="双层for循环"><a href="#双层for循环" class="headerlink" title="双层for循环"></a>双层for循环</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; arr.length;i ++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = i + <span class="number">1</span>;j &lt; arr.length;j ++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[i] === arr[j])&#123;</span><br><span class="line">        arr.splice(j,<span class="number">1</span>)</span><br><span class="line">        j --</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> resArr = []</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; arr.length;i ++)&#123;</span><br><span class="line">    <span class="keyword">let</span> item = arr[i]</span><br><span class="line">    <span class="keyword">let</span> beleftArr = arr.slice(i+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span>(arr.slice(i+<span class="number">1</span>).indexOf(item) == <span class="number">-1</span>)&#123;</span><br><span class="line">      resArr.push(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> resArr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>思路：先排序，如果相邻项一致，就把取一个就行了，用正则实现</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/2356874721.github.io/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/2356874721.github.io/page/5/">5</a><a class="extend next" rel="next" href="/2356874721.github.io/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">sheriff</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/2356874721.github.io/archives/">
        
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/2356874721.github.io/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/2356874721.github.io/tags/">
          
        <span class="site-state-item-count">40</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sheriff</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/2356874721.github.io/lib/anime.min.js"></script>
  <script src="/2356874721.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/2356874721.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/2356874721.github.io/js/utils.js"></script>

<script src="/2356874721.github.io/js/motion.js"></script>


<script src="/2356874721.github.io/js/schemes/pisces.js"></script>


<script src="/2356874721.github.io/js/next-boot.js"></script>




  















  

  

</body>
</html>
