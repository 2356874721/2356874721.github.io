<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/2356874721.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/2356874721.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/2356874721.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/2356874721.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/2356874721.github.io/css/main.css">


<link rel="stylesheet" href="/2356874721.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/2356874721.github.io/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="警长的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="警长的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="sheriff">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>警长的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/2356874721.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">警长的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录生活 记录成长</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/2356874721.github.io/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/2356874721.github.io/archives/" rel="section"><i class="archives fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/2356874721.github.io/categories/" rel="section"><i class="categories fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/2356874721.github.io/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/2356874721.github.io/about/" rel="section"><i class="about fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/04/22/http-13/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/2356874721.github.io/images/avatar.gif">
      <meta itemprop="name" content="sheriff">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="警长的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2356874721.github.io/2021/04/22/http-13/" class="post-title-link" itemprop="url">HTTP有哪些优点？又有哪些缺点？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-22 20:42:09" itemprop="dateCreated datePublished" datetime="2021-04-22T20:42:09+08:00">2021-04-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-24 20:54:51" itemprop="dateModified" datetime="2021-04-24T20:54:51+08:00">2021-04-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/2356874721.github.io/categories/HTTP/" itemprop="url" rel="index"><span itemprop="name">HTTP</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今天的讨论范围仅限于 HTTP/1.1，所说的优点和缺点也仅针对 HTTP/1.1。</p>
<h3 id="简单、灵活、易于扩展"><a href="#简单、灵活、易于扩展" class="headerlink" title="简单、灵活、易于扩展"></a>简单、灵活、易于扩展</h3><p>首先，HTTP 最重要也是最突出的优点是“<strong>简单、灵活、易于扩展</strong>”。</p>
<p>初次接触 HTTP 的人都会认为，HTTP 协议是很“简单”的，基本的报文格式就是“<strong>header+body</strong>”，头部信息也是简单的文本格式，用的也都是常见的英文单词，即使不去看 RFC 文档，只靠猜也能猜出个“八九不离十”。</p>
<p>可不要小看了“简单”这个优点，它不仅降低了学习和使用的门槛，能够让更多的人研究和开发 HTTP 应用，<strong>“简单”蕴含了进化和扩展的可能性，所谓“少即是多”，“把简单的系统变复杂”，要比“把复杂的系统变简单”容易得多</strong>。</p>
<p>所以，在“简单”这个最基本的设计理念之下，HTTP 协议又多出了“灵活和易于扩展”的优点。</p>
<p>“灵活和易于扩展”实际上是一体的，它们互为表里、相互促进，因为“灵活”所以才会“易于扩展”，而“易于扩展”又反过来让 HTTP 更加灵活，拥有更强的表现能力。</p>
<p>HTTP 协议里的<em>请求方法、URI、状态码、原因短语、头字段等每一个核心组成要素都没有被“写死”，允许开发者任意定制、扩充或解释，给予了浏览器和服务器最大程度的信任和自由，也正好符合了互联网“自由与平等”的精神——缺什么功能自己加个字段或者错误码什么的补上就是了。</em></p>
<p>“请勿跟踪”所使用的头字段 <strong>DNT</strong>（Do Not Track）就是一个很好的例子。它最早由 Mozilla 提出，<strong>用来保护用户隐私，防止网站监测追踪用户的偏好</strong>。不过可惜的是 DNT 从推出至今有差不多七八年的历史，但很多网站仍然选择“无视”DNT。虽然 DNT 基本失败了，但这也正说明 HTTP 协议是“灵活自由的”，不会受单方面势力的压制。</p>
<p>“灵活、易于扩展”的特性还表现在 HTTP 对“<strong>可靠传输</strong>”的定义上，<strong>它不限制具体的下层协议，不仅可以使用 TCP、UNIX Domain Socket，还可以使用 SSL/TLS，甚至是基于 UDP 的 QUIC，下层可以随意变化，而上层的语义则始终保持稳定</strong>。</p>
<h3 id="应用广泛、环境成熟"><a href="#应用广泛、环境成熟" class="headerlink" title="应用广泛、环境成熟"></a>应用广泛、环境成熟</h3><p>HTTP 协议的另一大优点是“<strong>应用广泛</strong>”，软硬件环境都非常成熟。</p>
<p>随着互联网特别是移动互联网的普及，<strong>HTTP 的触角已经延伸到了世界的每一个角落</strong>：从简单的 Web 页面到复杂的 JSON、XML 数据，从台式机上的浏览器到手机上的各种 APP，从看新闻、泡论坛到购物、理财、“吃鸡”，你很难找到一个没有使用 HTTP 的地方。</p>
<p>不仅在应用领域，在开发领域 HTTP 协议也得到了广泛的支持。它并不限定某种编程语言或者操作系统，所以天然具有“<strong>跨语言、跨平台</strong>”的优越性。而且，因为本身的简单特性很容易实现，所以几乎所有的编程语言都有 HTTP 调用库和外围的开发测试工具，这一点我觉得就不用再举例了吧，你可能比我更熟悉。</p>
<p>HTTP 广泛应用的背后还有许多硬件基础设施支持，各个互联网公司和传统行业公司都不遗余力地“触网”，购买服务器开办网站，建设数据中心、CDN 和高速光纤，持续地优化上网体验，让 HTTP 运行的越来越顺畅。</p>
<p>“应用广泛”的这个优点也就决定了：无论是创业者还是求职者，无论是做网站服务器还是写应用客户端，HTTP 协议都是必须要掌握的基本技能。</p>
<h3 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h3><p>看过了两个优点，我们再来看看一把“<strong>双刃剑</strong>”，也就是上一讲中说到的“无状态”，它对于 HTTP 来说既是优点也是缺点。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p><strong>因为服务器没有“记忆能力”，所以就不需要额外的资源来记录状态信息，不仅实现上会简单一些，而且还能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务。</strong></p>
<p><strong>而且，“无状态”也表示服务器都是相同的，没有“状态”的差异，所以可以很容易地组成集群，让负载均衡把请求转发到任意一台服务器，不会因为状态不一致导致处理出错，使用“堆机器”的“笨办法”轻松实现高并发高可用。</strong></p>
<h4 id="坏处"><a href="#坏处" class="headerlink" title="坏处"></a>坏处</h4><p>既然服务器没有“记忆能力”，它就<strong>无法支持需要连续多个步骤的“事务”操作</strong>。<strong>例如电商购物，首先要登录，然后添加购物车，再下单、结算、支付，这一系列操作都需要知道用户的身份才行，但“无状态”服务器是不知道这些请求是相互关联的，每次都得问一遍身份信息，不仅麻烦，而且还增加了不必要的数据传输量</strong>。</p>
<h3 id="明文"><a href="#明文" class="headerlink" title="明文"></a>明文</h3><p>HTTP 协议里还有一把优缺点一体的“<strong>双刃剑</strong>”，就是明文传输。</p>
<p><strong>“明文”意思就是协议里的报文（准确地说是 header 部分）不使用二进制数据，而是用简单可阅读的文本形式。</strong></p>
<h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><p>对比 TCP、UDP 这样的二进制协议，它的优点显而易见，<strong>不需要借助任何外部工具，用浏览器、Wireshark 或者 tcpdump 抓包后，直接用肉眼就可以很容易地查看或者修改，为我们的开发调试工作带来极大的便利</strong>。</p>
<h4 id="坏处-1"><a href="#坏处-1" class="headerlink" title="坏处"></a>坏处</h4><p>当然，明文的缺点也是一样显而易见，HTTP 报文的所有信息都会<strong>暴露在“光天化日之下”，在漫长的传输链路的每一个环节上都毫无隐私可言，不怀好意的人只要侵入了这个链路里的某个设备，简单地“旁路”一下流量，就可以实现对通信的窥视</strong>。</p>
<h3 id="不安全"><a href="#不安全" class="headerlink" title="不安全"></a>不安全</h3><p>安全有很多的方面，明文只是“机密”方面的一个缺点，在“<strong>身份认证</strong>”和“<strong>完整性校验</strong>”这两方面 HTTP 也是欠缺的。</p>
<p>HTTP 没有提供有效的手段来确认通信双方的真实身份。虽然协议里有一个基本的认证机制，但因为刚才所说的明文传输缺点，这个机制几乎可以说是“纸糊的”，非常容易被攻破。如果仅使用 HTTP 协议，很可能你会连到一个页面一模一样但却是个假冒的网站，然后再被“钓”走各种私人信息。</p>
<p>HTTP 协议也不支持“完整性校验”，数据在传输过程中容易被窜改而无法验证真伪。比如，你收到了一条银行用 HTTP 发来的消息：“小明向你转账一百元”，你无法知道小明是否真的就只转了一百元，也许他转了一千元或者五十元，但被黑客窜改成了一百元，真实情况到底是什么样子 HTTP 协议没有办法给你答案。</p>
<p><strong>为了解决 HTTP 不安全的缺点，所以就出现了 HTTPS</strong>，这个我们以后再说。</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>最后我们来谈谈 HTTP 的性能，可以用六个字来概括：“不算差，不够好”。</p>
<p>HTTP 协议基于 TCP/IP，并且使用了“请求 - 应答”的通信模式，所以性能的关键就在这两点上。</p>
<p>必须要说的是，<strong>TCP 的性能是不差的</strong>，否则也不会纵横互联网江湖四十余载了，而且它已经被研究的很透，集成在操作系统内核里经过了细致的优化，足以应付大多数的场景。</p>
<p>只可惜如今的江湖已经不是从前的江湖，现在互联网的特点是<strong>移动和高并发</strong>，不能保证稳定的连接质量，所以在 TCP 层面上 HTTP 协议有时候就会表现的不够好。</p>
<p>而“请求 - 应答”模式则加剧了 HTTP 的性能问题，这就是著名的“<strong>队头阻塞</strong>”（Head-of-line blocking），当顺<strong>序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一并被阻塞，会导致客户端迟迟收不到数据</strong>。</p>
<p>不过现在已经有了终极解决方案：HTTP/2 和 HTTP/3.</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol>
<li>HTTP 最大的优点是简单、灵活和易于扩展；</li>
<li>HTTP 拥有成熟的软硬件环境，应用的非常广泛，是互联网的基础设施；</li>
<li>HTTP 是无状态的，可以轻松实现集群化，扩展性能，但有时也需要用 Cookie 技术来实现“有状态”；</li>
<li>HTTP 是明文传输，数据完全肉眼可见，能够方便地研究分析，但也容易被窃听；</li>
<li>HTTP 是不安全的，无法验证通信双方的身份，也不能判断报文是否被窜改；</li>
<li>HTTP 的性能不算差，但不完全适应现在的互联网，还有很大的提升空间。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/04/08/http-12/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/2356874721.github.io/images/avatar.gif">
      <meta itemprop="name" content="sheriff">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="警长的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2356874721.github.io/2021/04/08/http-12/" class="post-title-link" itemprop="url">12 | HTTP有哪些特点？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-04-08 18:40:03 / 修改时间：21:05:16" itemprop="dateCreated datePublished" datetime="2021-04-08T18:40:03+08:00">2021-04-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/2356874721.github.io/categories/HTTP/" itemprop="url" rel="index"><span itemprop="name">HTTP</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今天主要说的是 HTTP 协议的特点，但不会讲它们的好坏，这些特点即有可能是优点，也有可能是缺点。</p>
<img src="/2356874721.github.io/2021/04/08/http-12/12-1.png" class>

<h3 id="灵活可扩展"><a href="#灵活可扩展" class="headerlink" title="灵活可扩展"></a>灵活可扩展</h3><p>首先， <strong>HTTP 协议是一个“灵活可扩展”的传输协议。</strong></p>
<p>HTTP 协议最初诞生的时候就比较简单，本着开放的精神只规定了报文的基本格式，比如用空格分隔单词，用换行分隔字段，“header+body”等，报文里的各个组成部分都没有做严格的语法语义限制，可以由开发者任意定制。</p>
<p>所以，HTTP 协议就随着互联网的发展一同成长起来了。在这个过程中，HTTP 协议逐渐增加了请求方法、版本号、状态码、头字段等特性。而 body 也不再限于文本形式的 TXT 或 HTML，而是能够传输图片、音频视频等任意数据，这些都是源于它的“灵活可扩展”的特点。</p>
<p>而那些 RFC 文档，实际上也可以理解为是对已有扩展的“承认和标准化”，实现了“从实践中来，到实践中去”的良性循环。</p>
<p>也正是因为这个特点，HTTP 才能在三十年的历史长河中“屹立不倒”，从最初的低速实验网络发展到现在的遍布全球的高速互联网，始终保持着旺盛的生命力。</p>
<h3 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h3><p>第二个特点， <strong>HTTP 协议是一个“可靠”的传输协议。</strong></p>
<p>这个特点显而易见，<strong>因为 HTTP 协议是基于 TCP/IP 的，而 TCP 本身是一个“可靠”的传输协议，所以 HTTP 自然也就继承了这个特性</strong>，能够在请求方和应答方之间“可靠”地传输数据。</p>
<p><em>不过我们必须正确地理解“可靠”的含义，HTTP 并不能 100% 保证数据一定能够发送到另一端，在网络繁忙、连接质量差等恶劣的环境下，也有可能收发失败。“可靠”只是向使用者提供了一个“承诺”，会在下层用多种手段“尽量”保证数据的完整送达。</em></p>
<p>当然，如果遇到光纤被意外挖断这样的极端情况，即使是神仙也不能发送成功。所以，“可靠”传输是指在网络基本正常的情况下数据收发必定成功，借用运维里的术语，大概就是“3 个 9”或者“4 个 9”的程度吧。</p>
<h3 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h3><p>第三个特点，<strong>HTTP 协议是一个应用层的协议。</strong></p>
<p>在 TCP/IP 诞生后的几十年里，虽然出现了许多的应用层协议，但它们都仅关注很小的应用领域，局限在很少的应用场景。例如 FTP 只能传输文件、SMTP 只能发送邮件、SSH 只能远程登录等，在<strong>通用的数据传输方面</strong>“完全不能打”。</p>
<p>所以 HTTP 凭借着可携带任意头字段和实体数据的报文结构，以及连接控制、缓存代理等方便易用的特性，一出现就“技压群雄”，迅速成为了应用层里的“明星”协议。<strong>只要不太苛求性能，HTTP 几乎可以传递一切东西，满足各种需求，称得上是一个“万能”的协议</strong>。</p>
<p>套用一个网上流行的段子，HTTP 完全可以用开玩笑的口吻说：“不要误会，我不是针对 FTP，我是说在座的应用层各位，都是垃圾。”</p>
<h3 id="请求-应答"><a href="#请求-应答" class="headerlink" title="请求 - 应答"></a>请求 - 应答</h3><p>第四个特点，<strong>HTTP 协议使用的是请求 - 应答通信模式。</strong></p>
<p>这个请求 - 应答模式是 HTTP 协议最根本的通信模型，通俗来讲就是“<strong>一发一收</strong>”“<strong>有来有去</strong>”，就像是写代码时的函数调用，只要填好请求头里的字段，“调用”后就会收到答复。</p>
<p>请求 - 应答模式也明确了 HTTP 协议里通信双方的定位，<strong>永远是请求方先发起连接和请求，是主动的，而应答方只有在收到请求后才能答复，是被动的，如果没有请求时不会有任何动作</strong>。</p>
<p>当然，<strong>请求方和应答方的角色也不是绝对的</strong>，在浏览器 - 服务器的场景里，通常服务器都是应答方，但如果将它用作代理连接后端服务器，那么它就可能同时扮演请求方和应答方的角色。</p>
<h3 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h3><p>第五个特点，<strong>HTTP 协议是无状态的</strong>。</p>
<p>这个所谓的“状态”应该怎么理解呢？<strong>“状态”其实就是客户端或者服务器里保存的一些数据或者标志</strong>，记录了通信过程中的一些变化信息。</p>
<p>你一定知道，<em>TCP 协议是有状态的，一开始处于 CLOSED 状态，连接成功后是 ESTABLISHED 状态，断开连接后是 FIN-WAIT 状态，最后又是 CLOSED 状态。</em></p>
<p><em>这些“状态”就需要 TCP 在内部用一些数据结构去维护，可以简单地想象成是个标志量，标记当前所处的状态，例如 0 是 CLOSED，2 是 ESTABLISHED 等等。</em></p>
<p>再来看 HTTP，那么对比一下 TCP 就看出来了，在整个协议里没有规定任何的“状态”，客户端和服务器永远是处在一种“<strong>无知</strong>”的状态。建立连接前两者互不知情，每次收发的报文也都是互相独立的，没有任何的联系。收发报文也不会对客户端或服务器产生任何影响，连接后也不会要求保存任何信息。</p>
<p><strong>“无状态”形象地来说就是“没有记忆能力”</strong>。<em>比如，浏览器发了一个请求，说“我是小明，请给我 A 文件。”，服务器收到报文后就会检查一下权限，看小明确实可以访问 A 文件，于是把文件发回给浏览器。接着浏览器还想要 B 文件，但服务器不会记录刚才的请求状态，不知道第二个请求和第一个请求是同一个浏览器发来的，所以浏览器必须还得重复一次自己的身份才行：“我是刚才的小明，请再给我 B 文件。”</em></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol>
<li>HTTP 是灵活可扩展的，可以任意添加头字段实现任意功能；</li>
<li>HTTP 是可靠传输协议，基于 TCP/IP 协议“尽量”保证数据的送达；</li>
<li>HTTP 是应用层协议，比 FTP、SSH 等更通用功能更多，能够传输任意数据；</li>
<li>HTTP 使用了请求 - 应答模式，客户端主动发起请求，服务器被动回复请求；</li>
<li>HTTP 本质上是无状态的，每个请求都是互相独立、毫无关联的，协议不要求客户端或服务器记录请求相关的信息。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/04/08/http-11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/2356874721.github.io/images/avatar.gif">
      <meta itemprop="name" content="sheriff">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="警长的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2356874721.github.io/2021/04/08/http-11/" class="post-title-link" itemprop="url">11 | 响应状态码该怎么用？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-04-08 18:12:30 / 修改时间：21:05:16" itemprop="dateCreated datePublished" datetime="2021-04-08T18:12:30+08:00">2021-04-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/2356874721.github.io/categories/HTTP/" itemprop="url" rel="index"><span itemprop="name">HTTP</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>前面，我们学习了 HTTP 报文里请求行的组成部分，包括请求方法和 URI。有了请求行，加上后面的头字段就形成了请求头，可以通过 TCP/IP 协议发送给服务器。</p>
<p>服务器收到请求报文，解析后需要进行处理，具体的业务逻辑多种多样，但最后必定是拼出一个响应报文发回客户端。</p>
<p><strong>响应报文由响应头加响应体数据组成，响应头又由状态行和头字段构成。</strong></p>
<p>我们先来复习一下状态行的结构，有三部分：</p>
<img src="/2356874721.github.io/2021/04/08/http-11/11-1.png" class>

<p>开头的 Version 部分是 HTTP 协议的版本号，通常是 HTTP/1.1，用处不是很大。后面的 Reason 部分是原因短语，是状态码的简短文字描述，例如“OK”“Not Found”等等，也可以自定义。但它只是为了兼容早期的文本客户端而存在，提供的信息很有限，目前的大多数客户端都会忽略它。</p>
<p>所以，状态行里有用的就只剩下中间的<strong>状态码（Status Code）</strong>了。它是一个<strong>十进制数字</strong>，以代码的形式表示服务器对请求的处理结果，就像我们通常编写程序时函数返回的错误码一样。</p>
<p>不过你要注意，<strong>它的名字是“状态码”而不是“错误码”</strong>。也就是说，<strong>它的含义不仅是错误，更重要的意义在于表达 HTTP 数据处理的“状态”</strong>，客户端可以依据代码适时转换处理状态，例如继续发送请求、切换协议，重定向跳转等，有那么点 TCP 状态转换的意思。</p>
<h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p>目前 RFC 标准里规定的状态码是三位数，所以取值范围就是从 000 到 999。但如果把代码简单地从 000 开始顺序编下去就显得有点太“low”，不灵活、不利于扩展，所以状态码也被设计成有一定的格式。</p>
<p>RFC 标准把状态码分成了<strong>五类</strong>，用数字的第一位表示分类，而 0<del>99 不用，这样状态码的实际可用范围就大大缩小了，由 000</del>999 变成了 <strong>100~599</strong>。</p>
<p>这五类的具体含义是：</p>
<ul>
<li>1××：提示信息，表示目前是协议处理的中间状态，还需要后续的操作；</li>
<li>2××：成功，报文已经收到并被正确处理；</li>
<li>3××：重定向，资源位置发生变动，需要客户端重新发送请求；</li>
<li>4××：客户端错误，请求报文有误，服务器无法处理；</li>
<li>5××：服务器错误，服务器在处理请求时内部发生了错误。</li>
</ul>
<p>在 HTTP 协议中，<strong>正确地理解并应用这些状态码不是客户端或服务器单方的责任，而是双方共同的责任。</strong></p>
<p><strong>客户端作为请求的发起方，获取响应报文后，需要通过状态码知道请求是否被正确处理，是否要再次发送请求，如果出错了原因又是什么。这样才能进行下一步的动作，要么发送新请求，要么改正错误重发请求。</strong></p>
<p><strong>服务器端作为请求的接收方，也应该很好地运用状态码。在处理请求时，选择最恰当的状态码回复客户端，告知客户端处理的结果，指示客户端下一步应该如何行动。特别是在出错的时候，尽量不要简单地返 400、500 这样意思含糊不清的状态码。</strong></p>
<h3 id="1××"><a href="#1××" class="headerlink" title="1××"></a>1××</h3><p>1××类状态码属于<strong>提示信息</strong>，<strong>是协议处理的中间状态</strong>，实际能够用到的时候很少。</p>
<h4 id="101"><a href="#101" class="headerlink" title="101"></a>101</h4><p>我们偶尔能够见到的是“<strong>101 Switching Protocols”</strong>。<strong>它的意思是客户端使用 Upgrade 头字段，要求在 HTTP 协议的基础上改成其他的协议继续通信，比如 WebSocket</strong>。而如果服务器也同意变更协议，就会发送状态码 101，但这之后的数据传输就不会再使用 HTTP 了。</p>
<h3 id="2××"><a href="#2××" class="headerlink" title="2××"></a>2××</h3><p>2××类状态码<strong>表示服务器收到并成功处理了客户端的请求</strong>，这也是客户端最愿意看到的状态码。</p>
<h4 id="200"><a href="#200" class="headerlink" title="200"></a>200</h4><p>“<strong>200 OK</strong>”是最常见的成功状态码，表示一切正常，服务器如客户端所期望的那样返回了处理结果，如果是非 HEAD 请求，通常在响应头后都会有 body 数据。</p>
<h4 id="204"><a href="#204" class="headerlink" title="204"></a>204</h4><p>“<strong>204 No Content</strong>”是另一个很常见的成功状态码，它的含义与“200 OK”基本相同，但<strong>响应头后没有 body 数据</strong>。所以对于 Web 服务器来说，正确地区分 200 和 204 是很必要的。</p>
<h4 id="206"><a href="#206" class="headerlink" title="206"></a>206</h4><p>“<strong>206 Partial Content</strong>”是 <strong>HTTP 分块下载或断点续传的基础</strong>，在客户端发送“范围请求”、要求获取资源的部分数据时出现，它与 200 一样，也是服务器成功处理了请求，但 <strong>body 里的数据不是资源的全部，而是其中的一部分</strong>。</p>
<p>状态码 206 通常还会伴随着头字段“<strong>Content-Range</strong>”，<strong>表示响应报文里 body 数据的具体范围</strong>，供客户端确认<strong>，例如“Content-Range: bytes 0-99/2000”，意思是此次获取的是总计 2000 个字节的前 100 个字节。</strong></p>
<h3 id="3××"><a href="#3××" class="headerlink" title="3××"></a>3××</h3><p>3××类状态码表示客户端请求的资源发生了变动，客户端必须用新的 URI 重新发送请求获取资源，也就是通常所说的“重定向”，包括著名的 301、302 跳转。</p>
<h4 id="301"><a href="#301" class="headerlink" title="301"></a>301</h4><p>“301 Moved Permanently”俗称“<strong>永久重定向</strong>”，<strong>含义是此次请求的资源已经不存在了，需要改用新的 URI 再次访问</strong>。</p>
<h4 id="302"><a href="#302" class="headerlink" title="302"></a>302</h4><p>与它类似的是“302 Found”，曾经的描述短语是“Moved Temporarily”，俗称“临时重定向”，<strong>意思是请求的资源还在，但需要暂时用另一个 URI 来访问。</strong></p>
<p>301 和 302 都会在响应头里使用字段 <strong>Location 指明后续要跳转的 URI</strong>，最终的效果很相似，浏览器都会重定向到新的 URI。<strong>两者的根本区别在于语义，一个是“永久”，一个是“临时”，所以在场景、用法上差距很大</strong>。</p>
<p><em>比如，你的网站升级到了 HTTPS，原来的 HTTP 不打算用了，这就是“永久”的，所以要配置 301 跳转，把所有的 HTTP 流量都切换到 HTTPS。</em></p>
<p><em>再比如，今天夜里网站后台要系统维护，服务暂时不可用，这就属于“临时”的，可以配置成 302 跳转，把流量临时切换到一个静态通知页面，浏览器看到这个 302 就知道这只是暂时的情况，<strong>不会做缓存优化</strong>，第二天还会访问原来的地址。</em></p>
<h4 id="304"><a href="#304" class="headerlink" title="304"></a>304</h4><p>“304 Not Modified” 是一个比较有意思的状态码，它<strong>用于 If-Modified-Since 等条件请求，表示资源未修改，用于缓存控制</strong>。它不具有通常的跳转含义，但可以理解成“<strong>重定向已到缓存的文件”</strong>（即“<strong>缓存重定向</strong>”）。</p>
<h3 id="4××"><a href="#4××" class="headerlink" title="4××"></a>4××</h3><p>4××类状态码表示<strong>客户端发送的请求报文有误</strong>，服务器无法处理，它就是真正的“错误码”含义了。</p>
<h4 id="400"><a href="#400" class="headerlink" title="400"></a>400</h4><p>“400 Bad Request”是一个通用的错误码，表示请求报文有错误，但具体是数据格式错误、缺少请求头还是 URI 超长它没有明确说，只是一个笼统的错误，客户端看到 400 只会是“一头雾水”“不知所措”。所以，在开发 Web 应用时应当尽量避免给客户端返回 400，而是要用其他更有明确含义的状态码。</p>
<h4 id="403"><a href="#403" class="headerlink" title="403"></a>403</h4><p>“403 Forbidden”实际上不是客户端的请求出错，而是表示<strong>服务器禁止访问资源</strong>。原因可能多种多样，例如信息敏感、法律禁止等，如果服务器友好一点，可以在 body 里详细说明拒绝请求的原因，不过现实中通常都是直接给一个“闭门羹”。</p>
<h4 id="404"><a href="#404" class="headerlink" title="404"></a>404</h4><p>“404 Not Found”可能是我们最常看见也是最不愿意看到的一个状态码，它的原意是<strong>资源在本服务器上未找到</strong>，所以无法提供给客户端。但现在已经被“用滥了”，只要服务器“不高兴”就可以给出个 404，而我们也无从得知后面到底是真的未找到，还是有什么别的原因，某种程度上它比 403 还要令人讨厌。</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul>
<li>405 Method Not Allowed：不允许使用某些方法操作资源，例如不允许 POST 只能 GET；</li>
<li>406 Not Acceptable：资源无法满足客户端请求的条件，例如请求中文但只有英文；</li>
<li>408 Request Timeout：请求超时，服务器等待了过长的时间；</li>
<li>409 Conflict：多个请求发生了冲突，可以理解为多线程并发时的竞态；</li>
<li>413 Request Entity Too Large：请求报文里的 body 太大；</li>
<li>414 Request-URI Too Long：请求行里的 URI 太大；</li>
<li>429 Too Many Requests：客户端发送了太多的请求，通常是由于服务器的限连策略；</li>
<li>431 Request Header Fields Too Large：请求头某个字段或总体太大；</li>
</ul>
<h3 id="5xx"><a href="#5xx" class="headerlink" title="5xx"></a>5xx</h3><p>5××类状态码表示客户端请求报文正确，但<strong>服务器在处理时内部发生了错误</strong>，无法返回应有的响应数据，是服务器端的“错误码”。</p>
<h4 id="500"><a href="#500" class="headerlink" title="500"></a>500</h4><p>“500 Internal Server Error”与 400 类似，也是一个<strong>通用的错误码，服务器究竟发生了什么错误我们是不知道的</strong>。<strong>不过对于服务器来说这应该算是好事，通常不应该把服务器内部的详细信息，例如出错的函数调用栈告诉外界。虽然不利于调试，但能够防止黑客的窥探或者分析</strong>。</p>
<h4 id="501"><a href="#501" class="headerlink" title="501"></a>501</h4><p>“501 Not Implemented”表示<strong>客户端请求的功能还不支持</strong>，这个错误码比 500 要“温和”一些，和“即将开业，敬请期待”的意思差不多，不过具体什么时候“开业”就不好说了。</p>
<h4 id="502"><a href="#502" class="headerlink" title="502"></a>502</h4><p>“502 Bad Gateway”通常是<strong>服务器作为网关或者代理时返回的错误码</strong>，表示<strong>服务器自身工作正常，访问后端服务器时发生了错误</strong>，但具体的错误原因也是不知道的。</p>
<h4 id="503"><a href="#503" class="headerlink" title="503"></a>503</h4><p>“503 Service Unavailable”<strong>表示服务器当前很忙，暂时无法响应服务</strong>，我们上网时有时候遇到的“网络服务正忙，请稍后重试”的提示信息就是状态码 503。</p>
<p>503 是一个“临时”的状态，很可能过几秒钟后服务器就不那么忙了，可以继续提供服务，所以 503 响应报文里通常还会有一个“Retry-After”字段，指示客户端可以在多久以后再次尝试发送请求。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol>
<li>状态码在响应报文里表示了服务器对请求的处理结果；</li>
<li>状态码后的原因短语是简单的文字描述，可以自定义；</li>
<li>状态码是十进制的三位数，分为五类，从 100 到 599；</li>
<li>2××类状态码表示成功，常用的有 200、204、206；</li>
<li>3××类状态码表示重定向，常用的有 301、302、304；</li>
<li>4××类状态码表示客户端错误，常用的有 400、403、404；</li>
<li>5××类状态码表示服务器错误，常用的有 500、501、502、503。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/04/01/http-10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/2356874721.github.io/images/avatar.gif">
      <meta itemprop="name" content="sheriff">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="警长的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2356874721.github.io/2021/04/01/http-10/" class="post-title-link" itemprop="url">10 | 你能写出正确的网址吗？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-01 18:36:09" itemprop="dateCreated datePublished" datetime="2021-04-01T18:36:09+08:00">2021-04-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-08 21:05:16" itemprop="dateModified" datetime="2021-04-08T21:05:16+08:00">2021-04-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/2356874721.github.io/categories/HTTP/" itemprop="url" rel="index"><span itemprop="name">HTTP</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>应该用什么来标记服务器上的资源呢？怎么区分“这个”资源和“那个”资源呢？</p>
<p>你一定已经知道了，用的是 <strong>URI</strong>，也就是<strong>统一资源标识符</strong>（Uniform Resource Identifier）。因为它经常出现在浏览器的地址栏里，所以俗称为“网络地址”，简称“网址”。</p>
<p><strong>严格地说，URI 不完全等同于网址，它包含有 URL 和 URN 两个部分</strong>，在 HTTP 世界里用的网址实际上是 <strong>URL——统一资源定位符</strong>（Uniform Resource Locator）。但因为 URL 实在是太普及了，所以常常把这两者简单地视为相等。</p>
<p>URI 非常重要，要搞懂 HTTP 甚至网络应用，就必须搞懂 URI。</p>
<h3 id="URI-的格式"><a href="#URI-的格式" class="headerlink" title="URI 的格式"></a>URI 的格式</h3><p>不知道你平常上网的时候有没有关注过地址栏里的那一长串字符，有的比较简短，有的则一行都显示不下，有的意思大概能看明白，而有的则带着各种怪字符，有如“天书”。</p>
<p>其实只要你弄清楚了 URI 的格式，就能够轻易地“破解”这些难懂的“天书”了。</p>
<p>URI 本质上是一个字符串，这个字符串的<strong>作用是唯一地标记资源的位置或者名字</strong>。</p>
<p>这里我要提醒你注意，<strong>它不仅能够标记万维网的资源，也可以标记其他的，如邮件系统、本地文件系统等任意资源</strong>。而“资源”既可以是存在磁盘上的静态文本、页面数据，也可以是由 Java、PHP 提供的动态服务。</p>
<p>下面的这张图显示了 URI 最常用的形式，由 scheme、host:port、path 和 query 四个部分组成，但有的部分可以视情况省略。</p>


<h3 id="URI-的基本组成"><a href="#URI-的基本组成" class="headerlink" title="URI 的基本组成"></a>URI 的基本组成</h3><p>URI 第一个组成部分叫 <strong>scheme</strong>，翻译成中文叫“方案名”或者“<strong>协议名</strong>”，<strong>表示资源应该使用哪种协议来访问</strong>。</p>
<p>最常见的当然就是“<strong>http</strong>”了，表示使用 HTTP 协议。另外还有“<strong>https</strong>”，表示使用经过加密、安全的 HTTPS 协议。此外还有其他不是很常见的 scheme，例如 <strong>ftp、ldap、file、news</strong> 等。</p>
<p>浏览器或者你的应用程序看到 URI 里的 scheme，就知道下一步该怎么走了，会调用相应的 HTTP 或者 HTTPS 下层 API。显然，如果一个 URI 没有提供 scheme，即使后面的地址再完善，也是无法处理的。</p>
<p>在 scheme 之后，<strong>必须是三个特定的字符“://”</strong>，它把 scheme 和后面的部分分离开。</p>
<p>实话实说，这个设计非常的怪异，URI 的创造者蒂姆·伯纳斯 - 李也曾经私下承认“://”并非必要，当初有些“过于草率”了。不过这个设计已经有了三十年的历史，不管我们愿意不愿意，只能接受。</p>
<p>在“://”之后，是被称为“<strong>authority</strong>”的部分，表示<strong>资源所在的主机名</strong>，通常的形式是“<strong>host:port</strong>”，即<strong>主机名加端口号</strong>。</p>
<p><strong>主机名可以是 IP 地址或者域名的形式，必须要有</strong>，否则浏览器就会找不到服务器。<strong>但端口号有时可以省略</strong>，浏览器等客户端会依据 scheme 使用默认的端口号，例如 <strong>HTTP 的默认端口号是 80，HTTPS 的默认端口号是 443</strong>。</p>
<p>有了<strong>协议名</strong>和<strong>主机地址、端口号</strong>，再加上后面标记资源所在位置的 <strong>path</strong>，浏览器就可以连接服务器访问资源了。</p>
<p>URI 里 path 采用了类似文件系统“目录”“路径”的表示方式，因为早期互联网上的计算机多是 UNIX 系统，所以采用了 UNIX 的“/”风格。其实也比较好理解，它与 scheme 后面的“://”是一致的。</p>
<p><strong><u>这里我也要再次提醒你注意，URI 的 path 部分必须以“/”开始，也就是必须包含“/”，不要把“/”误认为属于前面 authority。</u></strong></p>
<p>说了这么多“理论”，来看几个实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//nginx.org</span></span><br><span class="line">http:<span class="comment">//www.chrono.com:8080/11-1</span></span><br><span class="line">https:<span class="comment">//tools.ietf.org/html/rfc7230</span></span><br><span class="line">file:<span class="comment">///D:/http_study/www/</span></span><br></pre></td></tr></table></figure>

<p>第一个 URI 算是最简单的了，协议名是“http”，主机名是“nginx.org”，端口号省略，所以是默认的 80，而路径部分也被省略了，<strong>默认就是一个“/”，表示根目录</strong>。</p>
<p>第二个 URI 是在实验环境里这次课程的专用 URI，主机名是“<a href="http://www.chrono.com”，端口号是" target="_blank" rel="noopener">www.chrono.com”，端口号是</a> 8080，后面的路径是“/11-1”。</p>
<p>第三个是 HTTP 协议标准文档 RFC7230 的 URI，主机名是“tools.ietf.org”，路径是“/html/rfc7230”。</p>
<p>最后一个 URI 要注意了，它的协议名不是“http”，而是“<strong>file</strong>”，表示这是<strong>本地文件</strong>，而后面居然有<strong>三个斜杠</strong>，这是怎么回事？如果你刚才仔细听了 scheme 的介绍就能明白，这三个斜杠里的<strong>前两个属于 URI 特殊分隔符“://”</strong>，<strong>然后后面的“/D:/http_study/www/”是路径，而中间的主机名被“省略”了</strong>。这实际上是 <strong>file 类型 URI 的“特例”，它允许省略主机名，默认是本机 localhost</strong>。</p>
<p><strong><u>但对于 HTTP 或 HTTPS 这样的网络通信协议，主机名是绝对不能省略的。原因之前也说了，会导致浏览器无法找到服务器。</u></strong></p>
<h3 id="URI-的查询参数"><a href="#URI-的查询参数" class="headerlink" title="URI 的查询参数"></a>URI 的查询参数</h3><p>使用“协议名 + 主机名 + 路径”的方式，已经可以精确定位网络上的任何资源了。但这还不够，很多时候我们还想在操作资源的时候附加一些额外的修饰参数。</p>
<p>仅用“协议名 + 主机名 + 路径”的方式是无法适应这些场景的，所以 URI 后面还有一个“<strong>query</strong>”部分，<strong>它在 path 之后，用一个“?”开始，但不包含“?”</strong>，<strong>表示对资源附加的额外要求</strong>。这是个很形象的符号，比“://”要好的多，很明显地表示了“查询”的含义。</p>
<p>查询参数 query 有一套自己的格式，是多个“key=value”的字符串，这些 <strong>KV</strong> 值用字符“<strong>&amp;</strong>”连接，浏览器和服务器都可以按照这个格式把长串的查询参数解析成可理解的字典或关联数组形式。</p>
<h3 id="URI-的完整格式"><a href="#URI-的完整格式" class="headerlink" title="URI 的完整格式"></a>URI 的完整格式</h3><p>讲完了 query 参数，URI 就算完整了，HTTP 协议里用到的 URI 绝大多数都是这种形式。不过必须要说的是，URI 还有一个“真正”的完整形态，如下图所示。</p>


<p>这个“真正”形态比基本形态多了两部分。</p>
<p>第一个多出的部分是协议名之后、主机名之前的<strong>身份信息</strong>“user:passwd@”，表示登录主机时的用户名和密码，但现在已经不推荐使用这种形式了（RFC7230），因为它把敏感信息以明文形式暴露出来，存在严重的安全隐患。</p>
<p>第二个多出的部分是查询参数后的<strong>片段标识符</strong>“#fragment”，它是 URI 所定位的资源内部的一个“锚点”或者说是“标签”，浏览器可以在获取资源后直接跳转到它指示的位置。</p>
<h3 id="URI-的编码"><a href="#URI-的编码" class="headerlink" title="URI 的编码"></a>URI 的编码</h3><p>刚才我们看到了，在 URI 里只能使用 ASCII 码，但如果要在 URI 里使用英语以外的汉语、日语等其他语言该怎么办呢？还有，某些特殊的 URI，会在 path、query 里出现“@&amp;?”等起界定符作用的字符，会导致 URI 解析错误，这时又该怎么办呢？</p>
<p>所以，URI 引入了编码机制，对于 ASCII 码以外的字符集和特殊字符做一个特殊的操作，把它们转换成与 URI 语义不冲突的形式。这在 RFC 规范里称为“escape”和“unescape”，俗称“<strong>转义</strong>”。</p>
<p><strong>URI 转义的规则有点“简单粗暴”，直接把非 ASCII 码或特殊字符转换成十六进制字节值，然后前面再加上一个“%”。</strong></p>
<p>例如，空格被转义成“%20”，“?”被转义成“%3F”。而中文、日文等则通常使用 UTF-8 编码后再转义，例如“银河”会被转义成“%E9%93%B6%E6%B2%B3”。</p>
<p>有了这个编码规则后，URI 就更加完美了，可以支持任意的字符集用任何语言来标记资源。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol>
<li>URI 是用来唯一标记服务器上资源的一个字符串，通常也称为 URL；</li>
<li>URI 通常由 scheme、host:port、path 和 query 四个部分组成，有的可以省略；</li>
<li>scheme 叫“方案名”或者“协议名”，表示资源应该使用哪种协议来访问；</li>
<li>“host:port”表示资源所在的主机名和端口号；</li>
<li>path 标记资源所在的位置；</li>
<li>query 表示对资源附加的额外要求；</li>
<li>在 URI 里对“@&amp;/”等特殊字符和汉字必须要做编码，否则服务器收到 HTTP 报文后会无法正确处理。</li>
</ol>
<h3 id="课下作业"><a href="#课下作业" class="headerlink" title="课下作业"></a>课下作业</h3><ol>
<li><p>HTTP 协议允许在在请求行里使用完整的 URI，但为什么浏览器没有这么做呢？</p>
<p>因为在请求头的字段中都有，没必要重复</p>
</li>
<li><p>URI 的查询参数和头字段很相似，都是 key-value 形式，都可以任意自定义，那么它们在使用时该如何区别呢？</p>
<p>头字段是针对这次请求的，query是针对访问的资源</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/31/http-09/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/2356874721.github.io/images/avatar.gif">
      <meta itemprop="name" content="sheriff">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="警长的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2356874721.github.io/2021/03/31/http-09/" class="post-title-link" itemprop="url">09 | 应该如何理解请求方法？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-31 18:16:50" itemprop="dateCreated datePublished" datetime="2021-03-31T18:16:50+08:00">2021-03-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-08 21:05:16" itemprop="dateModified" datetime="2021-04-08T21:05:16+08:00">2021-04-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/2356874721.github.io/categories/HTTP/" itemprop="url" rel="index"><span itemprop="name">HTTP</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>HTTP 的报文结构是由 header+body 构成，请求头里有请求方法和请求目标，响应头里有状态码和原因短语，今天要说的就是请求头里的请求方法。</p>
<h3 id="标准请求方法"><a href="#标准请求方法" class="headerlink" title="标准请求方法"></a>标准请求方法</h3><p>HTTP 协议里为什么要有“请求方法”这个东西呢？</p>
<p>这就要从 HTTP 协议设计时的定位说起了。还记得吗？蒂姆·伯纳斯 - 李最初设想的是要用 HTTP 协议构建一个超链接文档系统，使用 URI 来定位这些文档，也就是资源。那么，该怎么在协议里操作这些资源呢？</p>
<p>很显然，需要有某种“动作的指示”，告诉操作这些资源的方式。所以，就这么出现了“请求方法”。它的<strong>实际含义就是客户端发出了一个“动作指令”，要求服务器端对 URI 定位的资源执行这个动作</strong>。</p>
<p>目前 HTTP/1.1 规定了八种方法，单词都必须是大写的形式，我先简单地列把它们列出来，后面再详细讲解。</p>
<ol>
<li>GET：获取资源，可以理解为读取或者下载数据；</li>
<li>HEAD：获取资源的元信息；</li>
<li>POST：向资源提交数据，相当于写入或上传数据；</li>
<li>PUT：类似 POST；</li>
<li>DELETE：删除资源；</li>
<li>CONNECT：建立特殊的连接隧道；</li>
<li>OPTIONS：列出可对资源实行的方法；</li>
<li>TRACE：追踪请求 - 响应的传输路径。</li>
</ol>
<img src="/2356874721.github.io/2021/03/31/http-09/9-1.jpeg" class>

<p>看看这些方法，是不是有点像对文件或数据库的“增删改查”操作，只不过这些动作操作的目标不是本地资源，而是远程服务器上的资源，所以只能由客户端“请求”或者“指示”服务器来完成。</p>
<p>既然请求方法是一个“指示”，那么客户端自然就没有决定权，<strong>服务器掌控着所有资源，也就有绝对的决策权力</strong>。<strong>它收到 HTTP 请求报文后，看到里面的请求方法，可以执行也可以拒绝，或者改变动作的含义，毕竟 HTTP 是一个“协议”，两边都要“商量着来”</strong>。</p>
<p>比如，你发起了一个 GET 请求，想获取“/orders”这个文件，但这个文件保密级别比较高，不是谁都能看的，服务器就可以有如下的几种响应方式：</p>
<ol>
<li>假装这个文件不存在，直接返回一个 404 Not found 报文；</li>
<li>稍微友好一点，明确告诉你有这个文件，但不允许访问，返回一个 403 Forbidden；</li>
<li>再宽松一些，返回 405 Method Not Allowed，然后用 Allow 头告诉你可以用 HEAD 方法获取文件的元信息。</li>
</ol>
<h3 id="GET-HEAD"><a href="#GET-HEAD" class="headerlink" title="GET/HEAD"></a>GET/HEAD</h3><p>GET 方法应该是 HTTP 协议里最知名的请求方法了，也应该是用的最多的，自 0.9 版出现并一直被保留至今，是名副其实的“元老”。它的含义是<strong>请求从服务器获取资源</strong>，这个资源既可以是静态的文本、页面、图片、视频，也可以是由 PHP、Java 动态生成的页面或者其他格式的数据。。</p>
<p>HEAD 方法与 GET 方法类似，也是请求从服务器获取资源，服务器的处理机制也是一样的，<strong>但服务器不会返回请求的实体数据，只会传回响应头，也就是资源的“元信息”</strong>。HEAD 方法可以看做是 GET 方法的一个“简化版”或者“轻量版”。因为它的响应头与 GET 完全相同，所以<strong>可以用在很多并不真正需要资源的场合，避免传输 body 数据的浪费</strong>。比如，想要检查一个文件是否存在，只要发个 HEAD 请求就可以了，没有必要用 GET 把整个文件都取下来。再比如，要检查文件是否有最新版本，同样也应该用 HEAD，服务器会在响应头里把文件的修改时间传回来。</p>
<h3 id="POST-PUT"><a href="#POST-PUT" class="headerlink" title="POST/PUT"></a>POST/PUT</h3><p>GET 和 HEAD 方法是从服务器获取数据，而 POST 和 PUT 方法则是相反操作，<strong>向 URI 指定的资源提交数据，数据就放在报文的 body 里</strong>。</p>
<p>POST 也是一个经常用到的请求方法，使用频率应该是仅次于 GET，应用的场景也非常多，只要向服务器发送数据，用的大多数都是 POST。</p>
<p>PUT 的作用与 POST 类似，也可以向服务器提交数据，但与 POST 存在微妙的不同，<strong>通常 POST 表示的是“新建”“create”的含义，而 PUT 则是“修改”“update”的含义</strong>。</p>
<p>在实际应用中，PUT 用到的比较少。而且，因为它与 POST 的语义、功能太过近似，有的服务器甚至就直接禁止使用 PUT 方法，只用 POST 方法上传数据。</p>
<h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><p>DELETE 方法<strong>指示服务器删除资源</strong>，因为这个动作危险性太大，所以通常服务器不会执行真正的删除操作，而是对资源做一个删除标记。当然，更多的时候服务器就直接不处理 DELETE 请求。</p>
<h3 id="CONNECT"><a href="#CONNECT" class="headerlink" title="CONNECT"></a>CONNECT</h3><p>CONNECT 是一个比较特殊的方法，<strong>要求服务器为客户端和另一台远程服务器建立一条特殊的连接隧道，这时 Web 服务器在中间充当了代理的角色</strong>。</p>
<h3 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h3><p>OPTIONS 方法<strong>要求服务器列出可对资源实行的操作方法，在响应头的 Allow 字段里返回</strong>。它的功能很有限，用处也不大，有的服务器（例如 Nginx）干脆就没有实现对它的支持。</p>
<h3 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h3><p>TRACE 方法<strong>多用于对 HTTP 链路的测试或诊断</strong>，可以显示出请求 - 响应的传输路径。它的本意是好的，但存在漏洞，会泄漏网站的信息，所以 Web 服务器通常也是禁止使用。</p>
<h3 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h3><p>虽然 HTTP/1.1 里规定了八种请求方法，但它并没有限制我们只能用这八种方法，这也体现了 HTTP 协议良好的扩展性，我们可以任意添加请求动作，只要请求方和响应方都能理解就行。</p>
<p>此外，还有一些得到了实际应用的请求方法（WebDAV），例如 MKCOL、COPY、MOVE、LOCK、UNLOCK、PATCH 等。如果有合适的场景，你也可以把它们应用到自己的系统里，比如用 LOCK 方法锁定资源暂时不允许修改，或者使用 PATCH 方法给资源打个小补丁，部分更新数据。但因为这些方法是非标准的，所以需要为客户端和服务器编写额外的代码才能添加支持。</p>
<p>当然了，你也完全可以根据实际需求，自己发明新的方法，比如“PULL”拉取某些资源到本地，“PURGE”清理某个目录下的所有缓存数据。</p>
<h3 id="安全与幂等"><a href="#安全与幂等" class="headerlink" title="安全与幂等"></a>安全与幂等</h3><p>关于请求方法还有两个面试时有可能会问到、比较重要的概念：安全与幂等。</p>
<p><strong>在 HTTP 协议里，所谓的“安全”是指请求方法不会“破坏”服务器上的资源，即不会对服务器上的资源造成实质的修改。</strong></p>
<p>按照这个定义，<strong>只有 GET 和 HEAD 方法是“安全”的</strong>，因为它们是“只读”操作，只要服务器不故意曲解请求方法的处理方式，无论 GET 和 HEAD 操作多少次，服务器上的数据都是“安全的”。</p>
<p>而 <strong>POST/PUT/DELETE 操作会修改服务器上的资源，增加或删除数据，所以是“不安全”的。</strong></p>
<p>所谓的“<strong>幂等</strong>”实际上是一个数学用语，被借用到了 HTTP 协议里，<strong>意思是多次执行相同的操作，结果也都是相同的，即多次“幂”后结果“相等”。</strong></p>
<p>很显然，<strong>GET 和 HEAD 既是安全的也是幂等的</strong>，<strong>DELETE</strong> 可以多次删除同一个资源，效果都是“资源不存在”，所以也是幂等的。</p>
<p>按照 RFC 里的语义，<strong>POST 是“新增或提交数据”，多次提交数据会创建多个资源，所以不是幂等的</strong>；<strong>而 PUT 是“替换或更新数据”，多次更新一个资源，资源还是会第一次更新的状态，所以是幂等的</strong>。</p>
<p>我对你的建议是，你可以对比一下 SQL 来加深理解：<strong>把 POST 理解成 INSERT，把 PUT 理解成 UPDATE，这样就很清楚了。多次 INSERT 会添加多条记录，而多次 UPDATE 只操作一条记录，而且效果相同</strong>。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol>
<li>请求方法是客户端发出的、要求服务器执行的、对资源的一种操作；</li>
<li>请求方法是对服务器的“指示”，真正应如何处理由服务器来决定；</li>
<li>最常用的请求方法是 GET 和 POST，分别是获取数据和发送数据；</li>
<li>HEAD 方法是轻量级的 GET，用来获取资源的元信息；</li>
<li>PUT 基本上是 POST 的同义词，多用于更新数据；</li>
<li>“安全”与“幂等”是描述请求方法的两个重要属性，具有理论指导意义，可以帮助我们设计系统。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/31/http-08/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/2356874721.github.io/images/avatar.gif">
      <meta itemprop="name" content="sheriff">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="警长的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2356874721.github.io/2021/03/31/http-08/" class="post-title-link" itemprop="url">08 | HTTP报文是什么样子的？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-31 18:16:43" itemprop="dateCreated datePublished" datetime="2021-03-31T18:16:43+08:00">2021-03-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-08 21:05:16" itemprop="dateModified" datetime="2021-04-08T21:05:16+08:00">2021-04-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/2356874721.github.io/categories/HTTP/" itemprop="url" rel="index"><span itemprop="name">HTTP</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>HTTP 的工作模式是非常简单的，由于 TCP/IP 协议负责底层的具体传输工作，HTTP 协议基本上不用在这方面操心太多。单从这一点上来看，所谓的“超文本传输协议”其实并不怎么管“传输”的事情，有点“名不副实”。</p>
<p>那么 HTTP 协议的<strong>核心部分</strong>是什么呢？</p>
<p>答案就是它传输的<strong>报文内容</strong>。</p>
<h3 id="报文结构"><a href="#报文结构" class="headerlink" title="报文结构"></a>报文结构</h3><p>你也许对 TCP/UDP 的报文格式有所了解，拿 TCP 报文来举例，它在实际要传输的数据之前附加了一个 20 字节的头部数据，存储 TCP 协议必须的额外信息，例如发送方的端口号、接收方的端口号、包序号、标志位等等。有了这个附加的 TCP 头，数据包才能够正确传输，到了目的地后把头部去掉，就可以拿到真正的数据。</p>
<p>HTTP 协议也是与 TCP/UDP 类似，同样也需要在实际传输的数据前附加一些头数据，不过与 TCP/UDP 不同的是，它是一个“<strong>纯文本</strong>”的协议，所以头数据都是 <strong>ASCII 码的文本</strong>，可以很容易地用肉眼阅读，不用借助程序解析也能够看懂。</p>
<p>HTTP 协议的请求报文和响应报文的结构基本相同，由三大部分组成：</p>
<ol>
<li>起始行（start line）：描述请求或响应的基本信息；</li>
<li>头部字段集合（header）：使用 key-value 形式更详细地说明报文；</li>
<li>消息正文（entity）：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据。</li>
</ol>
<p>这其中前两部分<strong>起始行和头部字段经常又合称为“请求头”或“响应头”</strong>，<strong>消息正文又称为“实体”</strong>，但与“header”对应，很多时候就直接称为“<strong>body</strong>”。</p>
<p><strong>HTTP 协议规定报文必须有 header，但可以没有 body，而且在 header 之后必须要有一个“空行”，也就是“CRLF”</strong>。</p>
<p>所以，一个完整的 HTTP 报文就像是下图的这个样子，注意在 header 和 body 之间有一个“空行”。</p>
<img src="/2356874721.github.io/2021/03/31/http-08/8-1.png" class>

<p>在下面这个浏览器发出的请求报文里，第一行“GET / HTTP/1.1”就是请求行，而后面的“Host”“Connection”等等都属于 header，报文的最后是一个空白行结束，没有 body。</p>
<img src="/2356874721.github.io/2021/03/31/http-08/8-2.png" class>

<p>在很多时候，特别是浏览器发送 GET 请求的时候都是这样，HTTP 报文经常是只有 header 而没 body，相当于只发了一个超级“大头”过来，你可以想象的出来：每时每刻网络上都会有数不清的“大头儿子”在跑来跑去。不过这个“大头”也不能太大，虽然 HTTP 协议对 header 的大小没有做限制，但各个 Web 服务器都不允许过大的请求头，因为头部太大可能会占用大量的服务器资源，影响运行效率。</p>
<h3 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h3><p>了解了 HTTP 报文的基本结构后，我们来看看<strong>请求报文里的起始行</strong>也就是<strong>请求行（request line）</strong>，它<strong>简要地描述了客户端想要如何操作服务器端的资源</strong>。</p>
<p>请求行由三部分构成：</p>
<ol>
<li>请求方法：是一个动词，如 GET/POST，表示对资源的操作；</li>
<li>请求目标：通常是一个 URI，标记了请求方法要操作的资源；</li>
<li>版本号：表示报文使用的 HTTP 协议版本。</li>
</ol>
<p>这三个部分通常使用空格（space）来分隔，最后要用 CRLF 换行表示结束。</p>
<img src="/2356874721.github.io/2021/03/31/http-08/8-3.png" class>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/<span class="number">1.1</span></span><br></pre></td></tr></table></figure>

<p>在这个请求行里，“GET”是请求方法，“/”是请求目标，“HTTP/1.1”是版本号，把这三部分连起来，意思就是“服务器你好，我想获取网站根目录下的默认文件，我用的协议版本号是 1.1，请不要用 1.0 或者 2.0 回复我。”</p>
<h3 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h3><p>看完了请求行，我们再看<strong>响应报文里的起始行</strong>，在这里它不叫“响应行”，而是叫“<strong>状态行”（status line）</strong>，意思是服务器响应的状态。</p>
<p>比起请求行来说，状态行要简单一些，同样也是由三部分构成：</p>
<ol>
<li>版本号：表示报文使用的 HTTP 协议版本；</li>
<li>状态码：一个三位数，用代码的形式表示处理的结果，比如 200 是成功，500 是服务器错误；</li>
<li>原因：作为数字状态码补充，是更详细的解释文字，帮助人理解原因。</li>
</ol>
<img src="/2356874721.github.io/2021/03/31/http-08/8-4.png" class>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br></pre></td></tr></table></figure>

<p>意思就是：“浏览器你好，我已经处理完了你的请求，这个报文使用的协议版本号是 1.1，状态码是 200，一切 OK。”</p>
<h3 id="头部字段"><a href="#头部字段" class="headerlink" title="头部字段"></a>头部字段</h3><p>请求行或状态行再加上头部字段集合就构成了 HTTP 报文里完整的请求头或响应头，我画了两个示意图，你可以看一下。</p>
<img src="/2356874721.github.io/2021/03/31/http-08/8-5.png" class>

<img src="/2356874721.github.io/2021/03/31/http-08/8-6.png" class>

<p>头部字段是 key-value 的形式，key 和 value 之间用“:”分隔，最后用 CRLF 换行表示字段结束。</p>
<p>HTTP 头字段非常灵活，不仅可以使用标准里的 Host、Connection 等已有头，也可以任意添加自定义头，这就给 HTTP 协议带来了无限的扩展可能。</p>
<p>不过使用头字段需要注意下面几点：</p>
<ol>
<li>字段名不区分大小写，例如“Host”也可以写成“host”，但首字母大写的可读性更好；</li>
<li>字段名里不允许出现空格，可以使用连字符“-”，但不能使用下划线“_”。例如，“test-name”是合法的字段名，而“test name”“test_name”是不正确的字段名；</li>
<li>字段名后面必须紧接着“:”，不能有空格，而“:”后的字段值前可以有多个空格；</li>
<li>字段的顺序是没有意义的，可以任意排列不影响语义；</li>
<li>字段原则上不能重复，除非这个字段本身的语义允许，例如 Set-Cookie。</li>
</ol>
<h3 id="常用头字段"><a href="#常用头字段" class="headerlink" title="常用头字段"></a>常用头字段</h3><p>HTTP 协议规定了非常多的头部字段，实现各种各样的功能，但基本上可以分为四大类：</p>
<ol>
<li>通用字段：在请求头和响应头里都可以出现；</li>
<li>请求字段：仅能出现在请求头里，进一步说明请求信息或者额外的附加条件；</li>
<li>响应字段：仅能出现在响应头里，补充说明响应报文的信息；</li>
<li>实体字段：它实际上属于通用字段，但专门描述 body 的额外信息。</li>
</ol>
<p>对 HTTP 报文的解析和处理实际上主要就是对头字段的处理，理解了头字段也就理解了 HTTP 报文。今天先讲几个最基本的头，看完了它们你就应该能够读懂大多数 HTTP 报文了。</p>
<h4 id="请求字段-Host"><a href="#请求字段-Host" class="headerlink" title="请求字段 Host"></a>请求字段 Host</h4><p>首先要说的是 Host 字段，它属于请求字段，<strong>只能出现在请求头里，它同时也是唯一一个 HTTP/1.1 规范里要求必须出现的字段</strong>，也就是说，如果请求头里没有 Host，那这就是一个错误的报文。</p>
<p>Host 字段告诉服务器这个请求应该由哪个主机来处理，当一台计算机上托管了多个虚拟主机的时候，服务器端就需要用 Host 字段来选择，有点像是一个简单的“路由重定向”。(<em>host字段是给Web服务器（Apache，Nginx）用的。 解析出ip后，请求到达Nginx，因为上面运行了很多的虚拟主机，比如a.com/b.com/c.com，那么应该进那个呢？ 这个时候就要用到host字段了。如果host=b.com，那么Nginx就会使用b.com的配置提供服务。</em>)</p>
<h4 id="请求字段-User-Agent"><a href="#请求字段-User-Agent" class="headerlink" title="请求字段 User-Agent"></a>请求字段 User-Agent</h4><p>User-Agent 是请求字段，只出现在请求头里。它<strong>使用一个字符串来描述发起 HTTP 请求的客户端</strong>，服务器可以依据它来返回最合适此浏览器显示的页面。但由于历史的原因，User-Agent 非常混乱，每个浏览器都自称是“Mozilla”“Chrome”“Safari”，企图使用这个字段来互相“伪装”，导致 User-Agent 变得越来越长，最终变得毫无意义。不过有的比较“诚实”的<strong>爬虫</strong>会在 User-Agent 里用“<strong>spider</strong>”标明自己是爬虫，所以可以利用这个字段实现简单的反爬虫策略。</p>
<h4 id="通用字段-Date"><a href="#通用字段-Date" class="headerlink" title="通用字段 Date"></a>通用字段 Date</h4><p>Date 字段是一个通用字段，但<strong>通常出现在响应头里</strong>，<strong>表示 HTTP 报文创建的时间</strong>，客户端可以使用这个时间再搭配其他字段<strong>决定缓存策略</strong>。</p>
<h4 id="响应字段-Server"><a href="#响应字段-Server" class="headerlink" title="响应字段 Server"></a>响应字段 Server</h4><p>Server 字段是响应字段，只能出现在响应头里。它<strong>告诉客户端当前正在提供 Web 服务的软件名称和版本号</strong>。Server 字段也不是必须要出现的，因为这会把服务器的一部分信息暴露给外界，如果这个版本恰好存在 bug，那么黑客就有可能利用 bug 攻陷服务器。所以，有的网站响应头里要么没有这个字段，要么就给出一个完全无关的描述信息。</p>
<h4 id="实体字段-Content-Length"><a href="#实体字段-Content-Length" class="headerlink" title="实体字段 Content-Length"></a>实体字段 Content-Length</h4><p>实体字段里要说的一个是 Content-Length，它<strong>表示报文里 body 的长度</strong>，也就是请求头或响应头空行后面数据的长度。服务器看到这个字段，就知道了后续有多少数据，可以直接接收。<strong>如果没有这个字段，那么 body 就是不定长的，需要使用 chunked 方式分段传输</strong>。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol>
<li>HTTP 报文结构就像是“大头儿子”，由“起始行 + 头部 + 空行 + 实体”组成，简单地说就是“header+body”；</li>
<li>HTTP 报文可以没有 body，但必须要有 header，而且 header 后也必须要有空行，形象地说就是“大头”必须要带着“脖子”；</li>
<li>请求头由“请求行 + 头部字段”构成，响应头由“状态行 + 头部字段”构成；</li>
<li>请求行有三部分：请求方法，请求目标和版本号；</li>
<li>状态行也有三部分：版本号，状态码和原因字符串；</li>
<li>头部字段是 key-value 的形式，用“:”分隔，不区分大小写，顺序任意，除了规定的标准头，也可以任意添加自定义字段，实现功能扩展；</li>
<li>HTTP/1.1 里唯一要求必须提供的头字段是 Host，它必须出现在请求头里，标记虚拟主机名。</li>
</ol>
<h3 id="课下作业"><a href="#课下作业" class="headerlink" title="课下作业"></a>课下作业</h3><ol>
<li><p>如果拼 HTTP 报文的时候，在头字段后多加了一个 CRLF，导致出现了一个空行，会发生什么？</p>
<p>在header 下面第一个空行以后都会被当作body 体</p>
</li>
<li><p>讲头字段时说“:”后的空格可以有多个，那为什么绝大多数情况下都只使用一个空格呢？</p>
<p>头部多一个空格就会多一个传输的字节，去掉无用的信息，保证传输的头部字节数尽量小</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/31/http-06/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/2356874721.github.io/images/avatar.gif">
      <meta itemprop="name" content="sheriff">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="警长的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2356874721.github.io/2021/03/31/http-06/" class="post-title-link" itemprop="url">06 | 域名里有哪些门道？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-31 17:53:05" itemprop="dateCreated datePublished" datetime="2021-03-31T17:53:05+08:00">2021-03-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-08 21:05:16" itemprop="dateModified" datetime="2021-04-08T21:05:16+08:00">2021-04-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/2356874721.github.io/categories/HTTP/" itemprop="url" rel="index"><span itemprop="name">HTTP</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在上一讲里，我们学习了 HTTP 协议使用的 TCP/IP 协议栈，知道了 HTTP 协议是运行在 TCP/IP 上的。</p>
<p>IP 协议的职责是“网际互连”，它在 MAC 层之上，使用 IP 地址把 MAC 编号转换成了四位数字，这就对物理网卡的 MAC 地址做了一层抽象，发展出了许多的“新玩法”。</p>
<p>但接入互联网的计算机越来越多，IP 地址的缺点也就暴露出来了，最主要的是它“对人不友好”，虽然比 MAC 的 16 进制数要好一点，但还是难于记忆和输入。</p>
<p>怎么解决这个问题呢？</p>
<p>那就“以其人之道还治其人之身”，<strong>在 IP 地址之上再来一次抽象，把数字形式的 IP 地址转换成更有意义更好记的名字</strong>，在字符串的层面上再增加“新玩法”。于是，<strong>DNS 域名系统</strong>就这么出现了。</p>
<h3 id="域名的形式"><a href="#域名的形式" class="headerlink" title="域名的形式"></a>域名的形式</h3><p>域名是一个有层次的结构，是一串用“.”分隔的多个单词，<strong>最右边的被称为“顶级域名”，然后是“二级域名”，层级关系向左依次降低</strong>。</p>
<p><strong>最左边的是主机名</strong>，通常用来表明主机的用途，比如“<strong>www”表示提供万维网服务</strong>、“mail”表示提供邮件服务，不过这也不是绝对的，名字的关键是要让我们容易记忆。</p>
<p>看一下百度的域名“<a href="http://www.baidu.com”，这里的“com”就是顶级域名，“baidu”是二级域名，“www”则是主机名。使用这个域名，DNS" target="_blank" rel="noopener">www.baidu.com”，这里的“com”就是顶级域名，“baidu”是二级域名，“www”则是主机名。使用这个域名，DNS</a> 就会把它转换成相应的 IP 地址，你就可以访问百度的网站了。</p>
<p>域名本质上还是个名字空间系统，<strong>使用多级域名就可以划分出不同的国家、地区、组织、公司、部门，每个域名都是独一无二的，可以作为一种身份的标识</strong>。</p>
<p>举个例子吧，假设 A 公司里有个小明，B 公司里有个小强，于是他们就可以分别说是“小明.A 公司”，“小强.B 公司”，即使 B 公司里也有个小明也不怕，可以标记为“小明.B 公司”，很好地解决了<strong>重名问题</strong>。</p>
<h3 id="域名的解析"><a href="#域名的解析" class="headerlink" title="域名的解析"></a>域名的解析</h3><p>就像 IP 地址必须转换成 MAC 地址才能访问主机一样，<strong>域名也必须要转换成 IP 地址，这个过程就是“域名解析”</strong>。</p>
<p>目前全世界有几亿个站点，有几十亿网民，而每天网络上发生的 HTTP 流量更是天文数字。这些请求绝大多数都是基于域名来访问网站的，所以 DNS 就成了互联网的重要基础设施，必须要保证域名解析稳定可靠、快速高效。</p>
<p>DNS 的核心系统是一个<strong>三层的树状、分布式服务</strong>，基本对应域名的结构：</p>
<ol>
<li>根域名服务器（Root DNS Server）：管理顶级域名服务器，返回“com”“net”“cn”等顶级域名服务器的 IP 地址；</li>
<li>顶级域名服务器（Top-level DNS Server）：管理各自域名下的权威域名服务器，比如 com 顶级域名服务器可以返回 apple.com 域名服务器的 IP 地址；</li>
<li>权威域名服务器（Authoritative DNS Server）：管理自己域名下主机的 IP 地址，比如 apple.com 权威域名服务器可以返回 <a href="http://www.apple.com" target="_blank" rel="noopener">www.apple.com</a> 的 IP 地址。</li>
</ol>
<img src="/2356874721.github.io/2021/03/31/http-06/6-1.png" class>

<p>在这里<strong>根域名服务器是关键</strong>，它必须是众所周知的，否则下面的各级服务器就无从谈起了。目前全世界共有 <strong>13 组</strong>根域名服务器，又有数百台的镜像，保证一定能够被访问到。有了这个系统以后，任何一个域名都可以在这个树形结构里<strong>从顶至下进行查询</strong>，就好像是把<strong>域名从右到左顺序走了一遍</strong>，最终就获得了域名对应的 IP 地址。</p>
<p>例如，你要访问“<a href="http://www.apple.com”，就要进行下面的三次查询：">www.apple.com”，就要进行下面的三次查询：</a></p>
<ol>
<li>访问根域名服务器，它会告诉你“com”顶级域名服务器的地址；</li>
<li>访问“com”顶级域名服务器，它再告诉你“apple.com”域名服务器的地址；</li>
<li>最后访问“apple.com”域名服务器，就得到了“<a href="http://www.apple.com”的地址。" target="_blank" rel="noopener">www.apple.com”的地址。</a></li>
</ol>
<p>虽然核心的 DNS 系统遍布全球，服务能力很强也很稳定，但如果全世界的网民都往这个系统里挤，即使不挤瘫痪了，访问速度也会很慢。</p>
<p><strong>所以在核心 DNS 系统之外，还有两种手段用来减轻域名解析的压力，并且能够更快地获取结果，基本思路就是“缓存”。</strong></p>
<p>首先，许多大公司、网络运行商都会<strong>建立自己的 DNS 服务器，作为用户 DNS 查询的代理，代替用户访问核心 DNS 系统</strong>。这些“野生”服务器被称为“<strong>非权威域名服务器</strong>”，可以<strong>缓存之前的查询结果，如果已经有了记录，就无需再向根服务器发起查询，直接返回对应的 IP 地址</strong>。这些 DNS 服务器的数量要比核心系统的服务器多很多，而且大多部署在离用户很近的地方。比较知名的 DNS 有 Google 的“8.8.8.8”，Microsoft 的“4.2.2.1”，还有 CloudFlare 的“1.1.1.1”等等。</p>
<p>其次，<strong>操作系统里也会对 DNS 解析结果做缓存</strong>，如果你之前访问过“<a href="http://www.apple.com”，那么下一次在浏览器里再输入这个网址的时候就不会再跑到" target="_blank" rel="noopener">www.apple.com”，那么下一次在浏览器里再输入这个网址的时候就不会再跑到</a> DNS 那里去问了，直接在操作系统里就可以拿到 IP 地址。</p>
<p>另外，操作系统里还有一个特殊的<strong>“主机映射”文件</strong>，通常是一个可编辑的文本，在 Linux 里是“/etc/hosts”，在 Windows 里是“C:\WINDOWS\system32\drivers\etc\hosts”，<strong>如果操作系统在缓存里找不到 DNS 记录，就会找这个文件</strong>。</p>
<p>有了上面的<strong>“野生”DNS 服务器、操作系统缓存和 hosts 文件</strong>后，很多域名解析的工作就都不用“跋山涉水”了，直接在本地或本机就能解决，不仅方便了用户，也减轻了各级 DNS 服务器的压力，效率就大大提升了。</p>
<p>下面的这张图比较完整地表示了现在的 DNS 架构。</p>
<img src="/2356874721.github.io/2021/03/31/http-06/6-1.png" class>

<h3 id="域名的“新玩法”"><a href="#域名的“新玩法”" class="headerlink" title="域名的“新玩法”"></a>域名的“新玩法”</h3><p>有了域名，又有了可以稳定工作的解析系统，于是我们就可以实现比 IP 地址更多的“新玩法”了。</p>
<p>第一种，也是最简单的，“<strong>重定向</strong>”。<strong>因为域名代替了 IP 地址，所以可以让对外服务的域名不变，而主机的 IP 地址任意变动</strong>。当主机有情况需要下线、迁移时，可以更改 DNS 记录，让域名指向其他的机器。比如，你有一台“buy.tv”的服务器要临时停机维护，那你就可以通知 DNS 服务器：“我这个 buy.tv 域名的地址变了啊，原先是 1.2.3.4，现在是 5.6.7.8，麻烦你改一下。”DNS 于是就修改内部的 IP 地址映射关系，之后再有访问 buy.tv 的请求就不走 1.2.3.4 这台主机，改由 5.6.7.8 来处理，这样就可以保证业务服务不中断。</p>
<p>第二种，因为域名是一个名字空间，所以可以使用 bind9 等开源软件<strong>搭建一个在内部使用的 DNS，作为名字服务器。这样我们开发的各种内部服务就都用域名来标记</strong>，比如数据库服务都用域名“mysql.inner.app”，商品服务都用“goods.inner.app”，发起网络通信时也就<strong>不必再使用写死的 IP 地址</strong>了，可以直接用域名，而且这种方式也兼具了第一种“玩法”的优势。</p>
<p>第三种“玩法”包含了前两种，也就是<strong>基于域名实现的负载均衡</strong>。第一种方式，<strong>因为域名解析可以返回多个 IP 地址，所以一个域名可以对应多台主机，客户端收到多个 IP 地址后，就可以自己使用轮询算法依次向服务器发起请求，实现负载均衡</strong>。第二种方式，<strong>域名解析可以配置内部的策略，返回离客户端最近的主机，或者返回当前服务质量最好的主机，这样在 DNS 端把请求分发到不同的服务器，实现负载均衡</strong>。</p>
<p>前面我们说的都是可信的 DNS，如果有一些<strong>不怀好意的 DNS</strong>，那么它也可以在域名这方面“做手脚”，弄一些比较“恶意”的“玩法”，举两个例子：</p>
<ol>
<li>“域名屏蔽”，对域名直接不解析，返回错误，让你无法拿到 IP 地址，也就无法访问网站；</li>
<li>“域名劫持”，也叫“域名污染”，你要访问 A 网站，但 DNS 给了你 B 网站。</li>
</ol>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol>
<li>域名使用字符串来代替 IP 地址，方便用户记忆，本质上一个名字空间系统；</li>
<li>DNS 就像是我们现实世界里的电话本、查号台，统管着互联网世界里的所有网站，是一个“超级大管家”；</li>
<li>DNS 是一个树状的分布式查询系统，但为了提高查询效率，外围有多级的缓存；</li>
<li>使用 DNS 可以实现基于域名的负载均衡。</li>
</ol>
<h3 id="课下作业"><a href="#课下作业" class="headerlink" title="课下作业"></a>课下作业</h3><ol>
<li><p>在浏览器地址栏里随便输入一个不存在的域名，比如就叫“www. 不存在.com”，试着解释一下它的 DNS 解析过程。</p>
<p>查找过程：浏览器缓存-&gt;操作系统dnscache -&gt;hosts文件-&gt;非权威域名服务器-&gt;根域名服务器-&gt;顶级域名服务器-&gt;二级域名服务器-&gt;权威域名服务器。</p>
</li>
<li><p>如果因为某些原因，DNS 失效或者出错了，会出现什么后果？</p>
<p>无法根据域名定位到ip地址，导致访问失败</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/30/http-05/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/2356874721.github.io/images/avatar.gif">
      <meta itemprop="name" content="sheriff">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="警长的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2356874721.github.io/2021/03/30/http-05/" class="post-title-link" itemprop="url">05 | 常说的“四层”和“七层”到底是什么？“五层”“六层”哪去了？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-30 21:40:06 / 修改时间：21:45:41" itemprop="dateCreated datePublished" datetime="2021-03-30T21:40:06+08:00">2021-03-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/2356874721.github.io/categories/HTTP/" itemprop="url" rel="index"><span itemprop="name">HTTP</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在工作中你一定经常听别人谈起什么“四层负载均衡”“七层负载均衡”，什么“二层转发”“三层路由”，那么你真正理解这些层次的含义吗？</p>
<p>网络分层的知识教科书上都有，但很多都是“泛泛而谈”，只有“学术价值”，于是就容易和实际应用“脱节”，造成的后果就是“似懂非懂”，真正用的时候往往会“一头雾水”。所以，今天我就从 HTTP 应用的角度，帮你把这些模糊的概念弄清楚。</p>
<h3 id="TCP-IP-网络分层模型"><a href="#TCP-IP-网络分层模型" class="headerlink" title="TCP/IP 网络分层模型"></a>TCP/IP 网络分层模型</h3><p>还是先从 TCP/IP 协议开始讲起，一是因为它非常经典，二是因为它是目前事实上的网络通信标准，研究它的实用价值最大。</p>
<p>TCP/IP 当初的设计者真的是非常聪明，创造性地提出了“<strong>分层</strong>”的概念，把复杂的网络通信划分出多个层次，再给每一个层次分配不同的职责，层次内只专心做自己的事情就好，用“分而治之”的思想把一个“大麻烦”拆分成了数个“小麻烦”，从而解决了网络通信的难题。你应该对 TCP/IP 的协议栈有所了解吧，这里我再贴一下层次图。</p>
<img src="/2356874721.github.io/2021/03/30/http-05/5-1.png" class>

<p><strong>TCP/IP 协议总共有四层</strong>，就像搭积木一样，每一层需要下层的支撑，同时又支撑着上层，任何一层被抽掉都可能会导致整个协议栈坍塌。我们来仔细地看一下这个精巧的积木架构，注意<strong>它的层次顺序是“从下往上”数的</strong>，所以<strong>第一层就是最下面的一层</strong>。</p>
<p>第一层叫“<strong>链接层</strong>”（link layer），负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在<strong>网卡</strong>这个层次，使用 <strong>MAC 地址来标记网络上的设备</strong>，所以有时候也叫 <strong>MAC 层</strong>。</p>
<p>第二层叫“<strong>网际层</strong>”或者“<strong>网络互连层</strong>”（internet layer），IP 协议就处在这一层。因为 IP 协议定义了“IP 地址”的概念，所以就可以<strong>在“链接层”的基础上，用 IP 地址取代 MAC 地址，把许许多多的局域网、广域网连接成一个虚拟的巨大网络，在这个网络里找设备时只要把 IP 地址再“翻译”成 MAC 地址就可以了</strong>。</p>
<p>第三层叫“<strong>传输层</strong>”（transport layer），这个层次协议的<strong>职责是保证数据在 IP 地址标记的两点之间“可靠”地传输</strong>，是 <strong>TCP</strong> 协议工作的层次，另外还有它的一个“小伙伴”UDP。TCP 是一个<strong>有状态</strong>的协议，需要<strong>先与对方建立连接然后才能发送数据</strong>，而且<strong>保证数据不丢失不重复</strong>。而 <strong>UDP</strong> 则比较简单，它<strong>无状态</strong>，<strong>不用事先建立连接就可以任意发送数据，但不保证数据一定会发到对方</strong>。两个协议的另一个重要区别在于数据的形式。TCP 的数据是<strong>连续</strong>的“<strong>字节流</strong>”，有<strong>先后顺序</strong>，而 UDP 则是<strong>分散的小数据包</strong>，是<strong>顺序发</strong>，<strong>乱序收</strong>。</p>
<p>关于 TCP 和 UDP 可以展开讨论的话题还有很多，比如最经典的“<strong>三次握手</strong>”和“<strong>四次挥手</strong>”，一时半会很难说完，好在与 HTTP 的关系不是太大，以后遇到了再详细讲解。</p>
<p>第四层叫“<strong>应用层</strong>”（application layer），由于下面的三层把基础打得非常好，所以在这一层就“百花齐放”了，<strong>有各种面向具体应用的协议</strong>。例如 Telnet、SSH、FTP、SMTP 等等，当然还有我们的 HTTP。</p>
<p><strong><u>MAC 层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。</u></strong></p>
<h3 id="OSI-网络分层模型"><a href="#OSI-网络分层模型" class="headerlink" title="OSI 网络分层模型"></a>OSI 网络分层模型</h3><p>看完 TCP/IP 协议栈，你可能要问了，“它只有四层，那常说的七层怎么没见到呢？”</p>
<p>别着急，这就是今天要说的第二个网络分层模型：<strong>OSI，全称是“开放式系统互联通信参考模型”（Open System Interconnection Reference Model）</strong>。</p>
<p>TCP/IP 发明于 1970 年代，当时除了它还有很多其他的网络协议，整个网络世界比较混乱。这个时候国际标准组织（ISO）注意到了这种现象，感觉“野路子”太多，就想要来个“大一统”。于是设计出了一个新的网络分层模型，想用这个新框架来统一既存的各种网络协议。</p>
<p>OSI 模型分成了七层，部分层次与 TCP/IP 很像，从下到上分别是：</p>
<img src="/2356874721.github.io/2021/03/30/http-05/5-2.png" class>

<p>第一层：<strong>物理层</strong>，网络的物理形式，例如电缆、光纤、网卡、集线器等等；</p>
<p>第二层：<strong>数据链路层</strong>，它基本相当于 TCP/IP 的<strong>链接层</strong>；</p>
<p>第三层：<strong>网络层</strong>，相当于 TCP/IP 里的<strong>网际层</strong>；</p>
<p>第四层：<strong>传输层</strong>，相当于 TCP/IP 里的<strong>传输层</strong>；</p>
<p>第五层：<strong>会话层</strong>，维护网络中的连接状态，即保持会话和同步；</p>
<p>第六层：<strong>表示层</strong>，把数据转换为合适、可理解的语法和语义；</p>
<p>第七层：<strong>应用层</strong>，面向具体的应用传输数据。</p>
<p>至此，我们常说的“四层”“七层”就出现了。不过国际标准组织心里也很清楚，TCP/IP 等协议已经在许多网络上实际运行，再推翻重来是不可能的。所以，OSI 分层模型在发布的时候就明确地表明是一个“参考”，不是强制标准，意思就是说，“你们以后该干什么还干什么，我不管，但面子上还是要按照我说的来”。</p>
<p>但 OSI 模型也是有优点的。对比一下就可以看出，TCP/IP 是一个纯软件的栈，没有网络应有的最根基的电缆、网卡等物理设备的位置。而 OSI 则补足了这个缺失<strong>，在理论层面上描述网络更加完整</strong>。</p>
<p>还有一个重要的形式上的优点：OSI 为每一层标记了明确了编号，最底层是一层，最上层是七层，而 TCP/IP 的层次从来只有名字而没有编号。显然，在交流的时候说“七层”要比“应用层”更简单快捷，特别是英文，对比一下“Layer seven”与“application layer”。</p>
<p>综合以上几点，在 OSI 模型之后，“四层”“七层”这样的说法就逐渐流行开了。不过在实际工作中你一定要注意，这种说法只是“理论上”的层次，并不是与现实完全对应。</p>
<h3 id="两个分层模型的映射关系"><a href="#两个分层模型的映射关系" class="headerlink" title="两个分层模型的映射关系"></a>两个分层模型的映射关系</h3><p>现在我们有了两个网络分层模型：TCP/IP 和 OSI，新的问题又出现了，一个是四层模型，一个是七层模型，这两者应该如何互相映射或者说互相解释呢？好在 OSI 在设计之初就参考了 TCP/IP 等多个协议，可以比较容易但不是很精确地实现对应关系。</p>
<img src="/2356874721.github.io/2021/03/30/http-05/5-3.png" class>

<p>第一层：物理层，TCP/IP 里无对应；</p>
<p>第二层：<strong>数据链路层</strong>，对应 TCP/IP 的<strong>链接层</strong>；</p>
<p>第三层：<strong>网络层</strong>，对应 TCP/IP 的<strong>网际层</strong>；</p>
<p>第四层：<strong>传输层</strong>，对应 TCP/IP 的<strong>传输层</strong>；</p>
<p>第五、六、七层：统一对应到 TCP/IP 的<strong>应用层</strong>。</p>
<p>所以你看，这就是“理想与现实”之间的矛盾。理想很美好，有七层，但现实很残酷，只有四层，“多余”的五层、六层就这样“消失”了。</p>
<p>但这也有一定的实际原因。<strong>OSI 的分层模型在四层以上分的太细，而 TCP/IP 实际应用时的会话管理、编码转换、压缩等和具体应用经常联系的很紧密，很难分开</strong>。例如，HTTP 协议就同时包含了连接管理和数据格式定义。</p>
<p>到这里，你应该能够明白一开始那些“某某层”的概念了。</p>
<p>所谓的“<strong>四层负载均衡</strong>”就是指工作在<strong>传输层</strong>上，基于 TCP/IP 协议的特性，例如 IP 地址、端口号等实现对后端服务器的负载均衡。</p>
<p>所谓的“<strong>七层负载均衡</strong>”就是指工作在<strong>应用层</strong>上，看到的是 HTTP 协议，解析 HTTP 报文里的 URI、主机名、资源类型等数据，再用适当的策略转发给后端服务器。</p>
<h3 id="TCP-IP-协议栈的工作方式"><a href="#TCP-IP-协议栈的工作方式" class="headerlink" title="TCP/IP 协议栈的工作方式"></a>TCP/IP 协议栈的工作方式</h3><p>TCP/IP 协议栈是如何工作的呢？你可以把 HTTP 利用 TCP/IP 协议栈传输数据想象成一个发快递的过程。</p>
<p>假设你想把一件毛绒玩具送给朋友，但你要先拿个塑料袋套一下，这件玩具就相当于 HTTP 协议里要传输的内容，比如 HTML，然后 HTTP 协议为它加一个 HTTP 专用附加数据。</p>
<p>你把玩具交给快递小哥，为了保护货物，他又加了层包装再贴了个标签，相当于在 TCP 层给数据再次打包，加上了 TCP 头。</p>
<p>接着快递小哥下楼，把包裹放进了三轮车里，运到集散点，然后再装进更大的卡车里，相当于在 IP 层、MAC 层对 TCP 数据包加上了 IP 头、MAC 头。</p>
<p>之后经过漫长的运输，包裹到达目的地，要卸货再放进另一位快递员的三轮车，就是在 IP 层、MAC 层传输后拆包。</p>
<p>快递员到了你朋友的家门口，撕掉标签，去除了 TCP 层的头，你朋友再拆掉塑料袋包装，也就是 HTTP 头，最后就拿到了玩具，也就是真正的 HTML 页面。</p>
<p>这个比喻里省略了很多 TCP/IP 协议里的细节，比如建连、路由、数据切分与重组、错误检查等，但核心的数据传输过程是差不多的。</p>
<p><strong><u>HTTP 协议的传输过程就是这样通过协议栈逐层向下，每一层都添加本层的专有数据，层层打包，然后通过下层发送出去。</u></strong></p>
<p><strong><u>接收数据则是相反的操作，从下往上穿过协议栈，逐层拆包，每层去掉本层的专有头，上层就会拿到自己的数据。</u></strong></p>
<p><strong>但下层的传输过程对于上层是完全“透明”的，上层也不需要关心下层的具体实现细节</strong>，所以就 HTTP 层次来看，它不管下层是不是 TCP/IP 协议，看到的只是一个可靠的传输链路，只要把数据加上自己的头，对方就能原样收到。</p>
<p>我为这个过程画了一张图，你可以对照着加深理解。</p>
<img src="/2356874721.github.io/2021/03/30/http-05/5-4.png" class>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这次我们学习了 HTTP 所在的网络分层模型，它是工作中常用的交流语言，在这里简单小结一下今天的内容。</p>
<ol>
<li>TCP/IP 分为四层，核心是二层的 IP 和三层的 TCP，HTTP 在第四层；</li>
<li>OSI 分为七层，基本对应 TCP/IP，TCP 在第四层，HTTP 在第七层；</li>
<li>OSI 可以映射到 TCP/IP，但这期间一、五、六层消失了；</li>
<li>日常交流的时候我们通常使用 OSI 模型，用四层、七层等术语；</li>
<li>HTTP 利用 TCP/IP 协议栈逐层打包再拆包，实现了数据传输，但下面的细节并不可见。</li>
<li>有一个辨别四层和七层比较好的（但不是绝对的）小窍门，“两个凡是”：<strong>凡是由操作系统负责处理的就是四层或四层以下，否则，凡是需要由应用程序（也就是你自己写代码）负责处理的就是七层。</strong></li>
</ol>
<h3 id="课下作业"><a href="#课下作业" class="headerlink" title="课下作业"></a>课下作业</h3><ol>
<li><p>你能用自己的话解释一下“二层转发”“三层路由”吗？</p>
<p>二层转发：二层应该指数据链路层，工作在二层的设备，通过查找到目标MAC地址，进行数据转发；</p>
<p>三层路由：三层应该指网络层，工作在三层的设备，通过解析数据包头信息，找到目标IP地址，转发数据</p>
</li>
<li><p>你认为上一讲中的 DNS 协议位于哪一层呢？</p>
<p>应用层</p>
</li>
<li><p>你认为 CDN 工作在那一层呢？</p>
<p>应用层</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/30/http-04/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/2356874721.github.io/images/avatar.gif">
      <meta itemprop="name" content="sheriff">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="警长的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2356874721.github.io/2021/03/30/http-04/" class="post-title-link" itemprop="url">04 | HTTP世界全览（下）：与HTTP相关的各种协议</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-30 21:40:03 / 修改时间：21:45:49" itemprop="dateCreated datePublished" datetime="2021-03-30T21:40:03+08:00">2021-03-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/2356874721.github.io/categories/HTTP/" itemprop="url" rel="index"><span itemprop="name">HTTP</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在上一讲中，我介绍了与 HTTP 相关的浏览器、服务器、CDN、网络爬虫等应用技术。今天要讲的则是比较偏向于理论的各种 HTTP 相关协议，重点是 TCP/IP、DNS、URI、HTTPS 等，希望能够帮你理清楚它们与 HTTP 的关系。</p>
<img src="/2356874721.github.io/2021/03/30/http-04/4-1.png" class>

<h3 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h3><p>TCP/IP 协议实际上是<strong>一系列网络通信协议的统称</strong>，其中最核心的两个协议是 TCP 和 IP，其他的还有 <strong>UDP、ICMP、ARP</strong> 等等，共同构成了一个复杂但有层次的协议栈。</p>
<p>这个协议栈有<strong>四层，最上层是“应用层”，最下层是“链接层”</strong>，TCP 和 IP 则在中间：TCP 属于“<strong>传输层</strong>”，IP 属于“<strong>网际层</strong>”。协议的层级关系模型非常重要，我会在下一讲中再专门讲解，这里先暂时放一放。</p>
<p><strong><u>IP 协议是“Internet Protocol”的缩写，主要目的是解决寻址和路由问题，以及如何在两点间传送数据包。</u></strong>IP 协议使用“<strong>IP 地址</strong>”的概念来定位互联网上的每一台计算机。可以对比一下现实中的电话系统，你拿着的手机相当于互联网上的计算机，而要打电话就必须接入电话网，由通信公司给你分配一个号码，这个号码就相当于 IP 地址。</p>
<p>现在我们使用的 IP 协议大多数是 v4 版，地址是四个用“.”分隔的数字，例如“192.168.0.1”，总共有 2^32，大约 42 亿个可以分配的地址。看上去好像很多，但互联网的快速发展让地址的分配管理很快就“捉襟见肘”。所以，就又出现了 v6 版，使用 8 组“:”分隔的数字作为地址，容量扩大了很多，有 2^128 个，在未来的几十年里应该是足够用了。</p>
<p><strong><u>TCP 协议是“Transmission Control Protocol”的缩写，意思是“传输控制协议”，它位于 IP 协议之上，基于 IP 协议提供可靠的、字节流形式的通信，是 HTTP 协议得以实现的基础。</u></strong></p>
<p><strong>“可靠”是指保证数据不丢失，“字节流”是指保证数据完整</strong>，<strong>所以在 TCP 协议的两端可以如同操作文件一样访问传输的数据，就像是读写在一个密闭的管道里“流动”的字节。</strong></p>
<p><strong>HTTP 是一个”传输协议”，但它不关心寻址、路由、数据完整性等传输细节，而要求这些工作都由下层来处理</strong>。因为互联网上最流行的是 TCP/IP 协议，而它刚好满足 HTTP 的要求，所以互联网上的 HTTP 协议就运行在了 TCP/IP 上，HTTP 也就可以更准确地称为“<strong>HTTP over TCP/IP</strong>”。</p>
<h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>在 TCP/IP 协议中使用 IP 地址来标识计算机，数字形式的地址对于计算机来说是方便了，但对于人类来说却既难以记忆又难以输入。</p>
<p>于是“<strong>域名系统</strong>”（<strong>Domain Name System</strong>）出现了，<strong>用有意义的名字来作为 IP 地址的等价替代</strong>。设想一下，你是愿意记“95.211.80.227”这样枯燥的数字，还是“nginx.org”这样的词组呢？</p>
<p>在 DNS 中，<strong>“域名”（Domain Name）又称为“主机名”（Host）</strong>，为了更好地标记不同国家或组织的主机，让名字更好记，所以被设计成了一个有层次的结构。</p>
<p>域名用“.”分隔成多个单词，<strong>级别从左到右逐级升高</strong>，最右边的被称为“顶级域名”。对于顶级域名，可能你随口就能说出几个，例如表示商业公司的“com”、表示教育机构的“edu”，表示国家的“cn”“uk”等，买火车票时的域名还记得吗？是“<a href="http://www.12306.cn”。" target="_blank" rel="noopener">www.12306.cn”。</a></p>
<p><strong><u>但想要使用 TCP/IP 协议来通信仍然要使用 IP 地址，所以需要把域名做一个转换，“映射”到它的真实 IP，这就是所谓的“域名解析”。</u></strong></p>
<p>继续用刚才的打电话做个比喻，你想要打电话给小明，但不知道电话号码，就得在手机里的号码簿里一项一项地找，直到找到小明那一条记录，然后才能查到号码。这里的“小明”就相当于域名，而“电话号码”就相当于 IP 地址，这个查找的过程就是域名解析。</p>
<p>域名解析的实际操作要比刚才的例子复杂很多，因为互联网上的电脑实在是太多了。目前全世界有 13 组根 DNS 服务器，下面再有许多的顶级 DNS、权威 DNS 和更小的本地 DNS，逐层递归地实现域名查询。</p>
<p>HTTP 协议中并没有明确要求必须使用 DNS，但实际上为了方便访问互联网上的 Web 服务器，通常都会使用 DNS 来定位或标记主机名，间接地把 DNS 与 HTTP 绑在了一起。</p>
<h3 id="URI-URL"><a href="#URI-URL" class="headerlink" title="URI/URL"></a>URI/URL</h3><p>有了 TCP/IP 和 DNS，是不是我们就可以任意访问网络上的资源了呢？</p>
<p>还不行，DNS 和 IP 地址只是标记了互联网上的主机，但主机上有那么多文本、图片、页面，到底要找哪一个呢？就像小明管理了一大堆文档，你怎么告诉他是哪个呢？</p>
<p>所以就出现了 <strong>URI（Uniform Resource Identifier）</strong>，中文名称是 <strong>统一资源标识符</strong>，使用它就能够<strong>唯一地标记互联网上资源</strong>。</p>
<p>URI 另一个更常用的表现形式是 <strong>URL（Uniform Resource Locator）</strong>， <strong>统一资源定位符</strong>，也就是我们俗称的“网址”，它实际上<strong>是 URI 的一个子集</strong>，不过因为这两者几乎是相同的，差异不大，所以通常不会做严格的区分。</p>
<p>我就拿 Nginx 网站来举例，看一下 URI 是什么样子的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//nginx.org/en/download.html</span></span><br></pre></td></tr></table></figure>

<p>你可以看到，<strong>URI 主要有三个基本的部分构成</strong>：</p>
<p><strong>协议名</strong>：即访问该资源应当使用的协议，在这里是“http”；</p>
<p><strong>主机名</strong>：即互联网上主机的标记，可以是域名或 IP 地址，在这里是“nginx.org”；</p>
<p><strong>路径</strong>：即资源在主机上的位置，使用“/”分隔多级目录，在这里是“/en/download.html”。</p>
<p>还是用打电话来做比喻，你通过电话簿找到了小明，让他把昨天做好的宣传文案快递过来。那么这个过程中你就完成了一次 URI 资源访问，“小明”就是“主机名”，“昨天做好的宣传文案”就是“路径”，而“快递”，就是你要访问这个资源的“协议名”。</p>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>在 TCP/IP、DNS 和 URI 的“加持”之下，HTTP 协议终于可以自由地穿梭在互联网世界里，顺利地访问任意的网页了，真的是“好生快活”。</p>
<p>但且慢，互联网上不仅有“美女”，还有很多的“野兽”。假设你打电话找小明要一份广告创意，很不幸，电话被商业间谍给窃听了，他立刻动用种种手段偷窃了你的快递，就在你还在等包裹的时候，他抢先发布了这份广告，给你的公司造成了无形或有形的损失。</p>
<p>有没有什么办法能够防止这种情况的发生呢？确实有。你可以使用“加密”的方法，比如这样打电话：</p>
<p>你：“喂，小明啊，接下来我们改用火星文通话吧。”</p>
<p>小明：“好啊好啊，就用火星文吧。”</p>
<p>你：“巴拉巴拉巴拉巴拉……”</p>
<p>小明：“巴拉巴拉巴拉巴拉……”</p>
<p>如果你和小明说的火星文只有你们两个才懂，那么即使窃听到了这段谈话，他也不会知道你们到底在说什么，也就无从破坏你们的通话过程。HTTPS 就相当于这个比喻中的“火星文”，它的全称是“<strong>HTTP over SSL/TLS</strong>”，<strong>也就是运行在 SSL/TLS 协议上的 HTTP</strong>。</p>
<p>注意它的名字，这里是 <strong>SSL/TLS</strong>，而不是 TCP/IP，它是一个<strong>负责加密通信的安全协议</strong>，<strong>建立在 TCP/IP 之上，所以也是个可靠的传输协议</strong>，可以被用作 HTTP 的下层。</p>
<p>因为 <u><strong>HTTPS 相当于“HTTP+SSL/TLS+TCP/IP”</strong></u>，其中的“HTTP”和“TCP/IP”我们都已经明白了，只要再了解一下 SSL/TLS，HTTPS 也就能够轻松掌握。</p>
<p>SSL 的全称是“<strong>Secure Socket Layer</strong>”，由网景公司发明，当发展到 3.0 时被标准化，改名为 <strong>TLS，即“Transport Layer Security”</strong>，但由于历史的原因还是有很多人称之为 SSL/TLS，或者直接简称为 SSL。</p>
<p>SSL 使用了许多密码学最先进的研究成果，综合了对称加密、非对称加密、摘要算法、数字签名、数字证书等技术，能够在不安全的环境中为通信的双方创建出一个秘密的、安全的传输通道，为 HTTP 套上一副坚固的盔甲。</p>
<p>你可以在今后上网时留心看一下浏览器地址栏，如果有一个小锁头标志，那就表明网站启用了安全的 HTTPS 协议，而 URI 里的协议名，也从“http”变成了“https”。</p>
<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>代理（Proxy）是 HTTP 协议中请求方和应答方中间的一个环节，作为“中转站”，<strong>既可以转发客户端的请求，也可以转发服务器的应答</strong>。</p>
<p>代理有很多的种类，常见的有：</p>
<p><strong>匿名代理</strong>：完全“隐匿”了被代理的机器，外界看到的只是代理服务器；</p>
<p><strong>透明代理</strong>：顾名思义，它在传输过程中是“透明开放”的，外界既知道代理，也知道客户端；</p>
<p><strong>正向代理</strong>：靠近客户端，代表客户端向服务器发送请求；</p>
<p><strong>反向代理</strong>：靠近服务器端，代表服务器响应客户端的请求；</p>
<p>上一讲提到的 CDN，实际上就是一种代理，它代替源站服务器响应客户端的请求，通常扮演着透明代理和反向代理的角色。</p>
<p>由于代理在传输过程中插入了一个“中间层”，所以可以在这个环节做很多有意思的事情，比如：</p>
<p><strong>负载均衡</strong>：把访问请求均匀分散到多台机器，实现访问集群化；</p>
<p><strong>内容缓存</strong>：暂存上下行的数据，减轻后端的压力；</p>
<p><strong>安全防护</strong>：隐匿 IP, 使用 WAF 等工具抵御网络攻击，保护被代理的机器；</p>
<p><strong>数据处理</strong>：提供压缩、加密等额外的功能。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这次我介绍了与 HTTP 相关的各种协议，在这里简单小结一下今天的内容。</p>
<ol>
<li>TCP/IP 是网络世界最常用的协议，HTTP 通常运行在 TCP/IP 提供的可靠传输基础上；</li>
<li>DNS 域名是 IP 地址的等价替代，需要用域名解析实现到 IP 地址的映射；</li>
<li>URI 是用来标记互联网上资源的一个名字，由“协议名 + 主机名 + 路径”构成，俗称 URL；</li>
<li>HTTPS 相当于“HTTP+SSL/TLS+TCP/IP”，为 HTTP 套了一个安全的外壳；</li>
<li>代理是 HTTP 传输过程中的“中转站”，可以实现缓存加速、负载均衡等功能。</li>
</ol>
<h3 id="课下作业"><a href="#课下作业" class="headerlink" title="课下作业"></a>课下作业</h3><ol>
<li><p>DNS 与 URI 有什么关系？</p>
<p>DNS专门用于域名解析，作用是简化人类记忆数据的复杂度。URI专门用于标识互联网世界中的资源，作用是帮助找到对应的互联网中资源。互联网中的电脑通过IP地址来表示，DNS可以把一个域名变成一个IP地址，IP地址是标识资源的一部分，仅定位了具体的电脑，还有继续定位在电脑上的具体位置。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/30/http-03/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/2356874721.github.io/images/avatar.gif">
      <meta itemprop="name" content="sheriff">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="警长的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2356874721.github.io/2021/03/30/http-03/" class="post-title-link" itemprop="url">03 | HTTP世界全览（上）：与HTTP相关的各种概念</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-30 21:38:14 / 修改时间：21:45:54" itemprop="dateCreated datePublished" datetime="2021-03-30T21:38:14+08:00">2021-03-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/2356874721.github.io/categories/HTTP/" itemprop="url" rel="index"><span itemprop="name">HTTP</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <img src="/2356874721.github.io/2021/03/30/http-03/3-1.png" class>

<p>图左边的部分是与 HTTP 有关系的各种协议，比较偏向于理论；而右边的部分是与 HTTP 有关系的各种应用技术，偏向于实际应用。</p>
<p>我希望借助这张图帮你澄清与 HTTP 相关的各种概念和角色，让你在实际工作中清楚它们在链路中的位置和作用，知道发起一个 HTTP 请求会有哪些角色参与，会如何影响请求的处理，做到“手中有粮，心中不慌”。</p>
<p>因为那张图比较大，所以我会把左右两部分拆开来分别讲，今天先讲右边的部分，也就是与 HTTP 相关的各种应用，着重介绍互联网、浏览器、Web 服务器等常见且重要的概念。</p>
<img src="/2356874721.github.io/2021/03/30/http-03/3-2.png" class>

<h3 id="网络世界"><a href="#网络世界" class="headerlink" title="网络世界"></a>网络世界</h3><p>互联网世界更像是由数不清的大小岛屿组成的“千岛之国”。</p>
<p>互联网的正式名称是 <strong>Internet</strong>，里面存储着无穷无尽的信息资源，我们通常所说的“上网”实际上访问的只是互联网的一个子集“<strong>万维网</strong>”（World Wide Web），它基于 HTTP 协议，传输 HTML 等超文本资源，能力也就被限制在 HTTP 协议之内。</p>
<p>互联网上还有许多<strong>万维网之外的资源</strong>，例如常用的<strong>电子邮件、BT 和 Magnet 点对点下载、FTP 文件下载、SSH 安全登录、各种即时通信服务</strong>等等，它们需要用各自的专有协议来访问。</p>
<p>不过由于 HTTP 协议非常灵活、易于扩展，而且“超文本”的表述能力很强，所以很多其他原本不属于 HTTP 的资源也可以“包装”成 HTTP 来访问，这就是我们为什么能够总看到各种“网页应用”——例如“微信网页版”“邮箱网页版”——的原因。</p>
<p><strong>综合起来看，现在的互联网 90% 以上的部分都被万维网，也就是 HTTP 所覆盖，所以把互联网约等于万维网或 HTTP 应该也不算大错。</strong></p>
<h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p>上网就要用到浏览器，常见的浏览器有 Google 的 Chrome、Mozilla 的 Firefox、Apple 的 Safari、Microsoft 的 IE 和 Edge，还有小众的 Opera 以及国内的各种“换壳”的“极速”“安全”浏览器。</p>
<p>那么你想过没有，所谓的“浏览器”到底是个什么东西呢？浏览器的正式名字叫<strong>“Web Browser</strong>”，顾名思义，就是<strong>检索、查看互联网上网页资源的应用程序</strong>，名字里的 Web，实际上指的就是“World Wide Web”，也就是万维网。</p>
<p><strong>浏览器本质上是一个 HTTP 协议中的请求方</strong>，使用 HTTP 协议获取网络上的各种资源。当然，为了让我们更好地检索查看网页，它还集成了很多额外的功能。</p>
<p>例如，HTML 排版引擎用来展示页面，JavaScript 引擎用来实现动态化效果，甚至还有开发者工具用来调试网页，以及五花八门的各种插件和扩展。</p>
<p><strong>在 HTTP 协议里，浏览器的角色被称为“User Agent”即“用户代理</strong>”，<strong>意思是作为访问者的“代理”来发起 HTTP 请求</strong>。不过在不引起混淆的情况下，我们通常都简单地称之为“<strong>客户端</strong>”。</p>
<h3 id="Web-服务器"><a href="#Web-服务器" class="headerlink" title="Web 服务器"></a>Web 服务器</h3><p>刚才说的浏览器是 HTTP 里的请求方，那么在协议另一端的<strong>应答方（响应方）</strong>又是什么呢？这个你一定也很熟悉，答案就是<strong>服务器</strong>，Web Server。</p>
<p>Web 服务器是一个很大也很重要的概念，它是 <strong>HTTP 协议里响应请求的主体</strong>，通常也<strong>把控着绝大多数的网络资源</strong>，<strong>在网络世界里处于强势地位</strong>。</p>
<p>当我们谈到“Web 服务器”时有两个层面的含义：硬件和软件。</p>
<h4 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h4><p>硬件含义就是<strong>物理形式或“云”形式的机器</strong>，在大多数情况下它可能不是一台服务器，而是利用反向代理、负载均衡等技术组成的庞大<strong>集群</strong>。但从外界看来，它仍然表现为一台机器，但这个形象是“虚拟的”。</p>
<h4 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h4><p>软件含义的 Web 服务器可能我们更为关心，它就是<strong>提供 Web 服务的应用程序</strong>，通常会运行在硬件含义的服务器上。它利用强大的硬件能力响应海量的客户端 HTTP 请求，处理磁盘上的网页、图片等静态文件，或者把请求转发给后面的 Tomcat、Node.js 等业务应用，返回动态的信息。</p>
<p>比起层出不穷的各种 Web 浏览器，Web 服务器就要少很多了，一只手的手指头就可以数得过来。</p>
<p><strong>Apache</strong> 是老牌的服务器，功能相当完善，相关的资料很多，学习门槛低，是许多创业者建站的入门产品。<strong>Nginx</strong> 是 Web 服务器里的后起之秀，特点是高性能、高稳定，且易于扩展。自 2004 年推出后就不断蚕食 Apache 的市场份额，在高流量的网站里更是不二之选。此外，还有 Windows 上的 <strong>IIS</strong>、Java 的 <strong>Jetty/Tomcat</strong> 等，因为性能不是很高，所以在互联网上应用得较少。</p>
<h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>浏览器和服务器是 HTTP 协议的两个端点，那么，在这两者之间还有别的什么东西吗？当然有了。浏览器通常不会直接连到服务器，中间会经过“重重关卡”，其中的一个重要角色就叫做 CDN。</p>
<p>CDN，全称是“<strong>Content Delivery Network</strong>”，翻译过来就是“<strong>内容分发网络</strong>”。它应用了 HTTP 协议里的<strong>缓存</strong>和<strong>代理</strong>技术，<strong>代替源站响应客户端的请求</strong>。</p>
<p>CDN 有什么好处呢？</p>
<p><u><strong>简单来说，它可以缓存源站的数据，让浏览器的请求不用“千里迢迢”地到达源站服务器，直接在“半路”就可以获取响应。如果 CDN 的调度算法很优秀，更可以找到离用户最近的节点，大幅度缩短响应时间。</strong></u></p>
<p>CDN 也是现在互联网中的一项重要基础设施，<strong>除了基本的网络加速外，还提供负载均衡、安全防护、边缘计算、跨运营商网络等功能</strong>，能够成倍地“放大”源站服务器的服务能力，很多云服务商都把 CDN 作为产品的一部分。</p>
<h3 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h3><p>前面说到过浏览器，它是一种用户代理，代替我们访问互联网。</p>
<p>但 <strong>HTTP 协议并没有规定用户代理后面必须是“真正的人类”</strong>，它也完全可以是“<strong>机器人</strong>”，这些“机器人”的正式名称就叫做“爬虫”（Crawler），<strong>实际上是一种可以自动访问 Web 资源的应用程序</strong>。</p>
<p>“爬虫”这个名字非常形象，它们就像是一只只不知疲倦的、辛勤的蚂蚁，在无边无际的网络上爬来爬去，不停地在网站间奔走，搜集抓取各种信息。</p>
<p>据估计，互联网上至少有 50% 的流量都是由爬虫产生的，某些特定领域的比例还会更高，也就是说，如果你的网站今天的访问量是十万，那么里面至少有五六万是爬虫机器人，而不是真实的用户。</p>
<p>爬虫是怎么来的呢？</p>
<p>绝大多数是由各大搜索引擎“放”出来的，抓取网页存入庞大的数据库，再建立关键字索引，这样我们才能够在搜索引擎中快速地搜索到互联网角落里的页面。</p>
<p>爬虫也有不好的一面，它会<strong>过度消耗网络资源，占用服务器和带宽，影响网站对真实数据的分析，甚至导致敏感信息泄漏</strong>。所以，又出现了“反爬虫”技术，通过各种手段来限制爬虫。其中一项就是“君子协定”robots.txt，约定哪些该爬，哪些不该爬。无论是“爬虫”还是“反爬虫”，用到的基本技术都是两个，一个是 HTTP，另一个就是 HTML。</p>
<h3 id="HTML-WebService-WAF"><a href="#HTML-WebService-WAF" class="headerlink" title="HTML/WebService/WAF"></a>HTML/WebService/WAF</h3><p>到现在我已经说完了图中右边的五大部分，而左边的 HTML、WebService、WAF 等由于与 HTTP 技术上实质关联不太大，所以就简略地介绍一下，不再过多展开。</p>
<p><strong>HTML 是 HTTP 协议传输的主要内容之一</strong>，它描述了超文本页面，用各种“标签”定义文字、图片等资源和排版布局，最终由浏览器“渲染”出可视化页面。HTML 目前有两个主要的标准，HTML4 和 HTML5。广义上的 HTML 通常是指 HTML、JavaScript、CSS 等前端技术的组合，能够实现比传统静态页面更丰富的动态页面。</p>
<p><strong>Web Service 是一种由 W3C 定义的应用服务开发规范</strong>，使用 client-server 主从架构，通常使用 WSDL 定义服务接口，使用 HTTP 协议传输 XML 或 SOAP 消息，也就是说，它是一个基于 Web（HTTP）的服务架构技术，既可以运行在内网，也可以在适当保护后运行在外网。因为采用了 HTTP 协议传输数据，所以在 Web Service 架构里服务器和客户端可以采用不同的操作系统或编程语言开发。例如服务器端用 Linux+Java，客户端用 Windows+C#，具有跨平台跨语言的优点。</p>
<p><strong>WAF</strong> 是近几年比较“火”的一个词，意思是“<strong>网络应用防火墙</strong>”。与硬件“防火墙”类似，它是应用层面的“防火墙”，专门检测 HTTP 流量，是防护 Web 应用的安全技术。WAF 通常位于 Web 服务器之前，可以阻止如 SQL 注入、跨站脚本等攻击，目前应用较多的一个开源项目是 ModSecurity，它能够完全集成进 Apache 或 Nginx。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>今天我详细介绍了与 HTTP 有关系的各种应用技术，在这里简单小结一下要点。</p>
<ol>
<li>互联网上绝大部分资源都使用 HTTP 协议传输；</li>
<li>浏览器是 HTTP 协议里的请求方，即 User Agent；</li>
<li>服务器是 HTTP 协议里的应答方，常用的有 Apache 和 Nginx；</li>
<li>CDN 位于浏览器和服务器之间，主要起到缓存加速的作用；</li>
<li>爬虫是另一类 User Agent，是自动访问网络资源的程序。</li>
</ol>
<h3 id="课下作业"><a href="#课下作业" class="headerlink" title="课下作业"></a>课下作业</h3><ol>
<li><p>你觉得 CDN 在对待浏览器和爬虫时会有差异吗？为什么？</p>
<p>CDN在对待浏览器和爬虫时没有差异，都被视为User Agent</p>
</li>
<li><p>你怎么理解 WebService 与 Web Server 这两个非常相似的词？</p>
<p>Webservice是服务，Web Server是服务器</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/2356874721.github.io/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/2356874721.github.io/page/5/">5</a><a class="extend next" rel="next" href="/2356874721.github.io/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">sheriff</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/2356874721.github.io/archives/">
        
          <span class="site-state-item-count">48</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/2356874721.github.io/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/2356874721.github.io/tags/">
          
        <span class="site-state-item-count">47</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sheriff</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/2356874721.github.io/lib/anime.min.js"></script>
  <script src="/2356874721.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/2356874721.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/2356874721.github.io/js/utils.js"></script>

<script src="/2356874721.github.io/js/motion.js"></script>


<script src="/2356874721.github.io/js/schemes/pisces.js"></script>


<script src="/2356874721.github.io/js/next-boot.js"></script>




  















  

  

</body>
</html>
