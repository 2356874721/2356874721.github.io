<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/2356874721.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/2356874721.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/2356874721.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/2356874721.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/2356874721.github.io/css/main.css">


<link rel="stylesheet" href="/2356874721.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/2356874721.github.io/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="警长的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="警长的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="sheriff">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>警长的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/2356874721.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">警长的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录生活 记录成长</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/2356874721.github.io/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/2356874721.github.io/archives/" rel="section"><i class="archives fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/2356874721.github.io/categories/" rel="section"><i class="categories fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/2356874721.github.io/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/2356874721.github.io/about/" rel="section"><i class="about fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/06/03/vue-transition-duration/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/2356874721.github.io/images/avatar.gif">
      <meta itemprop="name" content="sheriff">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="警长的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2356874721.github.io/2022/06/03/vue-transition-duration/" class="post-title-link" itemprop="url">transition组件的duration属性</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-03 15:56:58 / 修改时间：17:55:49" itemprop="dateCreated datePublished" datetime="2022-06-03T15:56:58+08:00">2022-06-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/2356874721.github.io/categories/vue/" itemprop="url" rel="index"><span itemprop="name">vue</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>在项目中我们经常会用到vue的transition组件，来实现一些过渡动画效果。transition有很多的属性，如：name、css、appear、mode、duration等，也提供了很多方便的钩子函数，如经常使用的before-enter、enter、after-enter、before-leave、leave、after-leave等。上述这些属性方法在官网上都有很好的示例和解释，但是其中的duration属性和其他属性比起来，我们不常用到，看官网的解释也很难理解它的应用场景，下面的内容就是对duration的一些更通俗的理解。</p>
<h2 id="二、应用场景"><a href="#二、应用场景" class="headerlink" title="二、应用场景"></a>二、应用场景</h2><p>为了搞清楚duration的应用场景，我们写个组件来实验一下。组件代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;demo&quot;&gt;</span><br><span class="line">    &lt;h4&gt;transition duration&lt;&#x2F;h4&gt;</span><br><span class="line">    &lt;transition</span><br><span class="line">      appear</span><br><span class="line">      :duration&#x3D;&quot;&#123; enter: 4000 &#125;&quot;</span><br><span class="line">      @before-enter&#x3D;&quot;beforeEnter&quot;</span><br><span class="line">      @enter&#x3D;&quot;enter&quot;</span><br><span class="line">      @after-enter&#x3D;&quot;afterEnter&quot;</span><br><span class="line">    &gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;parent&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;child&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;transition&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    beforeEnter () &#123;</span><br><span class="line">      console.log(&#39;before enter&#39;)</span><br><span class="line">    &#125;,</span><br><span class="line">    enter () &#123;</span><br><span class="line">      console.log(&#39;enter&#39;)</span><br><span class="line">    &#125;,</span><br><span class="line">    afterEnter () &#123;</span><br><span class="line">      console.log(&#39;after-enter&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang&#x3D;&quot;less&quot; scoped&gt;</span><br><span class="line">.demo &#123;</span><br><span class="line">  width: 242px;</span><br><span class="line">  margin: 0 auto;</span><br><span class="line">  .parent &#123;</span><br><span class="line">    background-color: gold;</span><br><span class="line">    height: 20px;</span><br><span class="line">    width: 100%;</span><br><span class="line">    position: relative;</span><br><span class="line">  &#125;</span><br><span class="line">  .child &#123;</span><br><span class="line">    height: 20px;</span><br><span class="line">    width: 100%;</span><br><span class="line">    background-color: blueviolet;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: 0;</span><br><span class="line">    bottom: -40px;</span><br><span class="line">  &#125;</span><br><span class="line">  .v-enter &#123;</span><br><span class="line">    width: 0px;</span><br><span class="line">    .child &#123;</span><br><span class="line">      width: 0px;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  .v-enter-active &#123;</span><br><span class="line">    transition: width 2s ease; &#x2F;&#x2F; 父组件完成过渡共需要2s</span><br><span class="line">    .child &#123;</span><br><span class="line">      transition: width 2s 2s ease; &#x2F;&#x2F; 子组件延迟2s执行，过渡耗费2s，所以子组件完成过渡共需时间4s</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>上面组件实现的效果是两个进度条，这两个进度条在dom结构上属于父子关系。transition组件包裹着parent，parent包裹着child，如下图所示：</p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2v5m5z62bj20fy0x00t8.jpg" alt="image-20220603165203499" style="zoom:50%;">

<p>可以看到css代码中parent过渡需要2s，child过渡需要4s，在transition标签上duration，我们设置的时间为4000ms即4s。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* css *&#x2F;</span><br><span class="line">.v-enter-active &#123;</span><br><span class="line">  transition: width 2s ease; &#x2F;&#x2F; 父组件完成过渡共需要2s</span><br><span class="line">  .child &#123;</span><br><span class="line">    transition: width 2s 2s ease; &#x2F;&#x2F; 子组件延迟2s执行，过渡耗费2s，所以子组件完成过渡共需时间4s</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* html *&#x2F; </span><br><span class="line">:duration&#x3D;&quot;&#123; enter: 4000 &#125;&quot;</span><br></pre></td></tr></table></figure>

<p>下面分情况讨论duration对组件过渡动画的影响</p>
<h3 id="1-不设置duration"><a href="#1-不设置duration" class="headerlink" title="1. 不设置duration"></a>1. 不设置duration</h3><p>不设置duration时，在父组件完成过渡后就认为完成进场效果了，随后立即调用after-enter钩子，此时如果子组件的过渡动画没有执行或没有执行完，也不再执行了，立即变成页面最终要展示的样式。</p>
<h3 id="2-设置duration"><a href="#2-设置duration" class="headerlink" title="2. 设置duration"></a>2. 设置duration</h3><p>为了解决1中子元素没有过渡动画的情况，需要设置duration，并且duration的值应该是子组件最后完成过渡动画所需要的时间。钩子函数after-enter将会在duration时间后调用，如本例子中的4000ms后调用，4000ms恰好是子组件child完成过渡所需要的时间。</p>
<h4 id="1-duration设置的比子组件过渡时间大"><a href="#1-duration设置的比子组件过渡时间大" class="headerlink" title="1.duration设置的比子组件过渡时间大"></a>1.duration设置的比子组件过渡时间大</h4><p>duration可以设置的比子组件过渡时间大，如5000ms，这对子组件过渡动画的执行没有影响；但需要注意的是， 钩子函数after-enter会在5000ms时间后才执行。</p>
<h4 id="2-duration设置的比组件过渡时间小"><a href="#2-duration设置的比组件过渡时间小" class="headerlink" title="2. duration设置的比组件过渡时间小"></a>2. duration设置的比组件过渡时间小</h4><p>duration若设置的比组件过渡时间小，如1000ms，那么意味着1000ms后，不管组件是否已经完成过渡动画，都要完成进场，达到页面最终要展示的样式。例如父组件和子组件过渡动画共需要4s，但只能执行1s，就直接中断进入下一个状态了。</p>
<h2 id="三、结论"><a href="#三、结论" class="headerlink" title="三、结论"></a>三、结论</h2><p>duration跟子组件的过渡或动画时长有关，个人理解应该叫做max-duration更贴切，类似于height于max-height的关系，当height和max-height同时存在时，只要height &lt;= max-height都以height为准，但是如果height &gt; max-height，就只能以max-height为准。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/02/20/shlee-cli/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/2356874721.github.io/images/avatar.gif">
      <meta itemprop="name" content="sheriff">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="警长的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2356874721.github.io/2022/02/20/shlee-cli/" class="post-title-link" itemprop="url">从零搭建前端脚手架工具</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-20 17:05:40 / 修改时间：17:06:45" itemprop="dateCreated datePublished" datetime="2022-02-20T17:05:40+08:00">2022-02-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/2356874721.github.io/categories/%E8%84%9A%E6%89%8B%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">脚手架</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>随着业务的发展，团队会维护好多项目，因此根据团队的需要量身打造一款脚手架工具十分必要，真正的做到开箱即用，节省了在项目开发前期，项目搭建、环境配置等等所耗费的大量时间，让开发者把更多的精力放在业务和个人成长上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">环境版本：</span><br><span class="line">node -- v14.17.0</span><br><span class="line">npm -- 6.14.6</span><br></pre></td></tr></table></figure>

<h3 id="二、项目搭建"><a href="#二、项目搭建" class="headerlink" title="二、项目搭建"></a>二、项目搭建</h3><ul>
<li><p>新建shlee-cli文件夹</p>
</li>
<li><p>在文件夹下执行 npm init -y</p>
</li>
<li><p>安装如下依赖，可以直接复制到package中，执行npm install</p>
<p>axios：网络请求</p>
<p>chalk：粉笔，输出有颜色的字体</p>
<p>cli-table2：输出表格</p>
<p>commander：命令行工具</p>
<p>download-git-repo：从github拉取模板</p>
<p>figlet：绘制图形</p>
<p>fs-extra：文件读写操作</p>
<p>inquirer：交互式命令</p>
<p>ora：loading动画</p>
<p>util：公共方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&quot;dependencies&quot;: &#123;</span><br><span class="line">  &quot;axios&quot;: &quot;^0.25.0&quot;,</span><br><span class="line">  &quot;chalk&quot;: &quot;^4.1.2&quot;,</span><br><span class="line">  &quot;cli-table2&quot;: &quot;^0.2.0&quot;,</span><br><span class="line">  &quot;commander&quot;: &quot;^9.0.0&quot;,</span><br><span class="line">  &quot;download-git-repo&quot;: &quot;^3.0.2&quot;,</span><br><span class="line">  &quot;figlet&quot;: &quot;^1.5.2&quot;,</span><br><span class="line">  &quot;fs-extra&quot;: &quot;^10.0.0&quot;,</span><br><span class="line">  &quot;inquirer&quot;: &quot;^8.2.0&quot;,</span><br><span class="line">  &quot;ora&quot;: &quot;^5.4.1&quot;,</span><br><span class="line">  &quot;util&quot;: &quot;^0.12.4&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h3><ul>
<li><p>新建程序的主入口文件bin/index.js，后面再写内容</p>
</li>
<li><p>在package.json中配置脚本命令，执行npm link，将shlee挂载到全局，在终端执行shlee时，就会执行/bin/index.js里面的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;bin&quot;: &#123;</span><br><span class="line">  &quot;shlee&quot;: &quot;.&#x2F;bin&#x2F;index.js&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="bin-index-js"><a href="#bin-index-js" class="headerlink" title="bin/index.js"></a>bin/index.js</h4><p>下面开始实现主入口的逻辑</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env node</span><br><span class="line">const figlet &#x3D; require(&#39;figlet&#39;) &#x2F;&#x2F; 绘制图形</span><br><span class="line">const program &#x3D; require(&#39;commander&#39;) &#x2F;&#x2F; 命令行工具</span><br><span class="line">program.usage(&#39;&lt;command&gt;&#39;)</span><br><span class="line">program.version(require(&#39;..&#x2F;package.json&#39;).version) &#x2F;&#x2F; 获取版本号</span><br><span class="line">const chalk &#x3D; require(&#39;chalk&#39;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义脚手架命令</span><br><span class="line">program.command(&#39;list&#39;)</span><br><span class="line">  .description(&#39;显示模板列表&#39;)</span><br><span class="line">  .action(() &#x3D;&gt; &#123; require(&#39;..&#x2F;commands&#x2F;list&#39;)() &#125;)</span><br><span class="line"></span><br><span class="line">program.command(&#39;init&#39;)</span><br><span class="line">  .description(&#39;初始化一个模板&#39;)</span><br><span class="line">  .option(&#39;-f, --force&#39;, &#39;如果目录已存在，则覆盖&#39;)</span><br><span class="line">  .action(options &#x3D;&gt; &#123; require(&#39;..&#x2F;commands&#x2F;init&#39;)(options) &#125;) &#x2F;&#x2F; options: &#123;force: true&#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 输入shlee -h时显示logo</span><br><span class="line">program</span><br><span class="line">  .on(&#39;--help&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;\r\n&#39; + figlet.textSync(&#39;shlee-cli&#39;, &#123;</span><br><span class="line">      horizontalLayout: &#39;full&#39;,</span><br><span class="line">      verticalLayout: &#39;full&#39;,</span><br><span class="line">      width: 100,</span><br><span class="line">      whitespaceBreak: false</span><br><span class="line">    &#125;))</span><br><span class="line">    console.log(&#96;\r\nRun $&#123;chalk.cyan(&#96;shlee &lt;command&gt; --help&#96;)&#125; for detailed usage of given command.\r\n&#96;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">program.parse(process.argv)</span><br></pre></td></tr></table></figure>

<h4 id="commands-list-js"><a href="#commands-list-js" class="headerlink" title="commands/list.js"></a>commands/list.js</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const &#123; getTemplateList &#125; &#x3D; require(&#39;..&#x2F;lib&#x2F;https&#39;)</span><br><span class="line">const Table &#x3D; require(&#39;cli-table2&#39;)</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; async function () &#123;</span><br><span class="line">  let table &#x3D; new Table(&#123;</span><br><span class="line">    head: [&#39;模板名称&#39;, &#39;模板描述&#39;, &#39;git仓库地址&#39;]</span><br><span class="line">  &#125;)</span><br><span class="line">  let tempalteList &#x3D; await getTemplateList()</span><br><span class="line">  tempalteList.map(item &#x3D;&gt; &#123;</span><br><span class="line">    table.push([item.name, item.description, item.html_url])</span><br><span class="line">  &#125;)</span><br><span class="line">  console.log(table.toString())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="commands-init-js"><a href="#commands-init-js" class="headerlink" title="commands/init.js"></a>commands/init.js</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">const fs &#x3D; require(&#39;fs-extra&#39;)</span><br><span class="line">const path &#x3D; require(&#39;path&#39;)</span><br><span class="line">const inquirer &#x3D; require(&#39;inquirer&#39;) &#x2F;&#x2F; 和用户的交互</span><br><span class="line">const Generator &#x3D; require(&#39;..&#x2F;lib&#x2F;generator&#39;)</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; async function (options) &#123;</span><br><span class="line">  &#x2F;&#x2F; 输入项目的名称、描述、创建者</span><br><span class="line">  const inquirerParams &#x3D; [</span><br><span class="line">    &#123;</span><br><span class="line">      type: &#39;input&#39;,</span><br><span class="line">      name: &#39;name&#39;,</span><br><span class="line">      message: &#39;项目名称&#39;,</span><br><span class="line">      default: &#39;project-name&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      type: &#39;input&#39;,</span><br><span class="line">      name: &#39;author&#39;,</span><br><span class="line">      message: &#39;你的名字&#39;,</span><br><span class="line">      default: &#39;author&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      type: &#39;input&#39;,</span><br><span class="line">      name: &#39;description&#39;,</span><br><span class="line">      message: &#39;项目描述&#39;,</span><br><span class="line">      default: &#39;description&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line">  let inquirerData &#x3D; await inquirer.prompt(inquirerParams)</span><br><span class="line"></span><br><span class="line">  const newDir &#x3D; path.join(process.cwd(), inquirerData.name)</span><br><span class="line">  &#x2F;&#x2F; 创建的目录已经存在</span><br><span class="line">  if (fs.existsSync(newDir)) &#123;</span><br><span class="line">    if (options.force) &#123; &#x2F;&#x2F; --force直接覆盖创建，不进行询问</span><br><span class="line">      await fs.remove(newDir)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 询问</span><br><span class="line">      const inquirerParams &#x3D; [</span><br><span class="line">        &#123;</span><br><span class="line">          name: &#39;action&#39;,</span><br><span class="line">          type: &#39;list&#39;,</span><br><span class="line">          message: &#96;目录$&#123;newDir&#125;已存在，请选择如下操作：&#96;,</span><br><span class="line">          choices: [</span><br><span class="line">            &#123;</span><br><span class="line">              name: &#39;删除已有目录&#39;,</span><br><span class="line">              value: &#39;remove&#39;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              name: &#39;取消当前操作&#39;,</span><br><span class="line">              value: &#39;cancel&#39;</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">      let inquirerData &#x3D; await inquirer.prompt(inquirerParams) &#x2F;&#x2F; &#123; action: &#39;cancel&#39; &#125;</span><br><span class="line">      if (inquirerData.action &#x3D;&#x3D; &#39;cancel&#39;) &#123;</span><br><span class="line">        return</span><br><span class="line">      &#125; else if (inquirerData.action &#x3D;&#x3D; &#39;remove&#39;) &#123;</span><br><span class="line">        console.log(&#39;\r\n正在删除...&#39;)</span><br><span class="line">        await fs.remove(newDir)</span><br><span class="line">        console.log(&#39;\r\n删除成功！\r\n&#39;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 创建项目</span><br><span class="line">  const generator &#x3D; new Generator(inquirerData, newDir)</span><br><span class="line">  generator.create()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="lib-https-js"><a href="#lib-https-js" class="headerlink" title="lib/https.js"></a>lib/https.js</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const axios &#x3D; require(&#39;axios&#39;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 响应拦截</span><br><span class="line">axios.interceptors.response.use(res &#x3D;&gt; &#123;</span><br><span class="line">  return res.data</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 拉取github中的模板列表</span><br><span class="line">async function getTemplateList() &#123;</span><br><span class="line">  return axios.get(&#39;https:&#x2F;&#x2F;api.github.com&#x2F;orgs&#x2F;shlee-cli&#x2F;repos&#39;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  getTemplateList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="lib-generator-js"><a href="#lib-generator-js" class="headerlink" title="lib/generator.js"></a>lib/generator.js</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">const &#123; getTemplateList &#125; &#x3D; require(&#39;.&#x2F;https&#39;)</span><br><span class="line">const chalk &#x3D; require(&#39;chalk&#39;) &#x2F;&#x2F; 粉笔，输出有颜色的字体</span><br><span class="line">const ora &#x3D; require(&#39;ora&#39;) &#x2F;&#x2F; loading动画</span><br><span class="line">const inquirer &#x3D; require(&#39;inquirer&#39;)</span><br><span class="line">const util &#x3D; require(&#39;util&#39;)</span><br><span class="line">const downloadGitRepo &#x3D; require(&#39;download-git-repo&#39;)</span><br><span class="line">const path &#x3D; require(&#39;path&#39;)</span><br><span class="line">const fs &#x3D; require(&#39;fs-extra&#39;)</span><br><span class="line"></span><br><span class="line">class Generator &#123;</span><br><span class="line">  constructor(inquirerData, newDir) &#123;</span><br><span class="line">    this.inquirerData &#x3D; inquirerData</span><br><span class="line">    this.name &#x3D; inquirerData.name</span><br><span class="line">    this.newDir &#x3D; newDir</span><br><span class="line">    this.downloadTemplates &#x3D; util.promisify(downloadGitRepo)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 创建项目</span><br><span class="line">  async create() &#123;</span><br><span class="line">    const template &#x3D; await this.getTemplate()</span><br><span class="line">    await this.download(template)</span><br><span class="line">    console.log(&#39;\r\n***************************&#39;)</span><br><span class="line">    console.log(&#96;您成功的创建了项目： $&#123;chalk.cyan(this.name)&#125;&#96;)</span><br><span class="line">    console.log(&#96;\r\ncd $&#123;chalk.cyan(this.name)&#125;&#96;)</span><br><span class="line">    console.log(&#96;\r\n$&#123;chalk.cyan(&#39;yarn install&#39;)&#125;&#96;)</span><br><span class="line">    console.log(&#96;\r\n$&#123;chalk.cyan(&#39;yarn start&#39;)&#125;&#96;)</span><br><span class="line">    console.log(&#39;***************************\r\n&#39;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 获取用户选择的模板</span><br><span class="line">  async getTemplate() &#123;</span><br><span class="line">    const templateList &#x3D; await this.wrapLoading(getTemplateList, &#39;正在获取模板列表...&#39;, &#39;模板列表获取成功！&#39;)</span><br><span class="line">    if (!templateList) return</span><br><span class="line">    &#x2F;&#x2F; 获取模板名称</span><br><span class="line">    const templates &#x3D; templateList.map(item &#x3D;&gt; item.name)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 通过询问，获取用户选择的模板名称</span><br><span class="line">    const &#123; template &#125; &#x3D; await inquirer.prompt(&#123;</span><br><span class="line">      name: &#39;template&#39;,</span><br><span class="line">      type: &#39;list&#39;,</span><br><span class="line">      choices: templates,</span><br><span class="line">      message: &#39;请选择项目模板&#39;</span><br><span class="line">    &#125;)</span><br><span class="line">    return template</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 动画</span><br><span class="line">  async wrapLoading(fn, waittingmsg, successfulmsg, ...args) &#123;</span><br><span class="line">    &#x2F;&#x2F; 启动动画</span><br><span class="line">    const spinner &#x3D; ora(waittingmsg)</span><br><span class="line">    spinner.start()</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">      const result &#x3D; await fn(...args)</span><br><span class="line">      spinner.succeed(successfulmsg)</span><br><span class="line">      return result</span><br><span class="line">    &#125; catch (error) &#123;</span><br><span class="line">      spinner.fail(&#39;出错了请稍后再试!&#39;, error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 下载模板</span><br><span class="line">  async download(template) &#123;</span><br><span class="line">    const requestUrl &#x3D; &#96;shlee-cli&#x2F;$&#123;template&#125;&#96;</span><br><span class="line">    await this.wrapLoading(</span><br><span class="line">      this.downloadTemplates,</span><br><span class="line">      &#39;正在下载模板...&#39;,</span><br><span class="line">      &#39;模板下载成功！&#39;,</span><br><span class="line">      requestUrl,</span><br><span class="line">      path.resolve(process.cwd(), this.newDir) &#x2F;&#x2F; 模板下载的位置</span><br><span class="line">    )</span><br><span class="line">    &#x2F;&#x2F; 替换模板package.json中的相关字段</span><br><span class="line">    const pkgPath &#x3D; path.resolve(process.cwd(), this.newDir)+&#39;&#x2F;package.json&#39;</span><br><span class="line">    let packageObj &#x3D; require(pkgPath)</span><br><span class="line">    if (packageObj) &#123;</span><br><span class="line">      packageObj &#x3D; &#123;...packageObj, ...this.inquirerData&#125;</span><br><span class="line">      fs.writeFileSync(pkgPath, JSON.stringify(packageObj, null, &#39;\t&#39;))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; Generator</span><br></pre></td></tr></table></figure>

<h3 id="四、发布到npm"><a href="#四、发布到npm" class="headerlink" title="四、发布到npm"></a>四、发布到npm</h3><ul>
<li>执行npm login登录npm账号</li>
<li>执行npm publish命令进行发布</li>
</ul>
<p>注意：发布之前，请确认package.json中已经配置以下字段，否则很可能发布失败；同时，也要保证name的唯一性，即在npm上不能有重名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;name&quot;: &quot;shlee-cli&quot;,</span><br><span class="line">&quot;version&quot;: &quot;0.0.2&quot;,</span><br><span class="line">&quot;description&quot;: &quot;定制脚手架&quot;,</span><br><span class="line">&quot;author&quot;: &quot;sheriff&quot;,</span><br><span class="line">&quot;license&quot;: &quot;ISC&quot;,</span><br></pre></td></tr></table></figure>

<h3 id="五、脚手架使用"><a href="#五、脚手架使用" class="headerlink" title="五、脚手架使用"></a>五、脚手架使用</h3><ul>
<li>执行npm unlink解绑脚本命令 </li>
<li>全局安装脚手架npm install shlee-cli -g</li>
<li>执行 shlee list查看模板列表</li>
<li>执行shlee init创建项目</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/02/20/vscode-plugin/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/2356874721.github.io/images/avatar.gif">
      <meta itemprop="name" content="sheriff">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="警长的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2356874721.github.io/2022/02/20/vscode-plugin/" class="post-title-link" itemprop="url">从零开发一款vscode插件小工具</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-20 16:56:27 / 修改时间：17:05:21" itemprop="dateCreated datePublished" datetime="2022-02-20T16:56:27+08:00">2022-02-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/2356874721.github.io/categories/vscode/" itemprop="url" rel="index"><span itemprop="name">vscode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>前端UI库在很大程度上提升了团队的开发效率，统一了团队的开发风格，避免重复造轮子。很多时候组件库的文档都是写到github上，但是由于国内github的不稳定，经常会打不开文档，令人十分抓狂。基于已上原因，开发了vscode插件，让开发者在vscode中就能轻松阅读文档。</p>
<p>插件提供的主要功能有：</p>
<ul>
<li>代码片段</li>
<li>hover提示</li>
<li>查看组件详情</li>
<li>…</li>
</ul>
<h3 id="二、项目搭建"><a href="#二、项目搭建" class="headerlink" title="二、项目搭建"></a>二、项目搭建</h3><p>安装依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g yo generator-code</span><br></pre></td></tr></table></figure>

<p>执行命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yo code</span><br></pre></td></tr></table></figure>

<p>按照如下提示选择，生成项目框架：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">? What type of extension do you want to create? New Extension (TypeScript)</span><br><span class="line">? What&#39;s the name of your extension? rong-ui-react-helper</span><br><span class="line">? What&#39;s the identifier of your extension? rong-ui-react-helper</span><br><span class="line">? What&#39;s the description of your extension? rong-ui-react-helper</span><br><span class="line">? Initialize a git repository? Yes</span><br><span class="line">? Bundle the source code with webpack? No</span><br><span class="line">? Which package manager to use? yarn</span><br></pre></td></tr></table></figure>



<h3 id="三、目录介绍"><a href="#三、目录介绍" class="headerlink" title="三、目录介绍"></a>三、目录介绍</h3><p>初始目录如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── CHANGELOG.md</span><br><span class="line">├── README.md</span><br><span class="line">├── package.json</span><br><span class="line">├── src</span><br><span class="line">│   ├── extension.ts  &#x2F;&#x2F; 入口</span><br><span class="line">│   └── test</span><br><span class="line">│       ├── runTest.ts</span><br><span class="line">│       └── suite</span><br><span class="line">│           ├── extension.test.ts</span><br><span class="line">│           └── index.ts</span><br><span class="line">├── tsconfig.json</span><br><span class="line">├── vsc-extension-quickstart.md</span><br><span class="line">└── yarn.lock</span><br></pre></td></tr></table></figure>

<p>简单的介绍下项目初始化后的文件信息，代码主要在src目录下，extension.ts是程序开发的入口，test目录用不到删除即可。对于vscode插件开发来说，package.json文件比较重要，下面详细介绍一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;name&quot;: &quot;rong-ui-react-helper&quot;,</span><br><span class="line">	&quot;displayName&quot;: &quot;rong-ui-react-helper&quot;,</span><br><span class="line">	&quot;description&quot;: &quot;rong-ui-react-helper&quot;,</span><br><span class="line">	&quot;version&quot;: &quot;0.0.1&quot;,</span><br><span class="line">	&quot;engines&quot;: &#123;</span><br><span class="line">		&quot;vscode&quot;: &quot;^1.64.0&quot;</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;categories&quot;: [</span><br><span class="line">		&quot;Other&quot;</span><br><span class="line">	],</span><br><span class="line">	&quot;activationEvents&quot;: [  &#x2F;&#x2F; 激活插件的节点</span><br><span class="line">		&quot;onCommand:rong-ui-react-helper.helloWorld&quot;</span><br><span class="line">	],</span><br><span class="line">	&quot;main&quot;: &quot;.&#x2F;out&#x2F;extension.js&quot;, &#x2F;&#x2F; 主入口，src&#x2F;extension.ts打包后输出的文件</span><br><span class="line">	&quot;contributes&quot;: &#123;</span><br><span class="line">		&quot;commands&quot;: [ &#x2F;&#x2F; 插件命令</span><br><span class="line">			&#123;</span><br><span class="line">				&quot;command&quot;: &quot;rong-ui-react-helper.helloWorld&quot;,</span><br><span class="line">				&quot;title&quot;: &quot;Hello World&quot;</span><br><span class="line">			&#125;</span><br><span class="line">		]</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;scripts&quot;: &#123;</span><br><span class="line">		&quot;vscode:prepublish&quot;: &quot;yarn run compile&quot;,</span><br><span class="line">		&quot;compile&quot;: &quot;tsc -p .&#x2F;&quot;,</span><br><span class="line">		&quot;watch&quot;: &quot;tsc -watch -p .&#x2F;&quot;,</span><br><span class="line">		&quot;pretest&quot;: &quot;yarn run compile &amp;&amp; yarn run lint&quot;,</span><br><span class="line">		&quot;lint&quot;: &quot;eslint src --ext ts&quot;,</span><br><span class="line">		&quot;test&quot;: &quot;node .&#x2F;out&#x2F;test&#x2F;runTest.js&quot;</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;devDependencies&quot;: &#123;</span><br><span class="line">		&quot;@types&#x2F;vscode&quot;: &quot;^1.64.0&quot;,</span><br><span class="line">		&quot;@types&#x2F;glob&quot;: &quot;^7.1.4&quot;,</span><br><span class="line">		&quot;@types&#x2F;mocha&quot;: &quot;^9.0.0&quot;,</span><br><span class="line">		&quot;@types&#x2F;node&quot;: &quot;14.x&quot;,</span><br><span class="line">		&quot;@typescript-eslint&#x2F;eslint-plugin&quot;: &quot;^5.1.0&quot;,</span><br><span class="line">		&quot;@typescript-eslint&#x2F;parser&quot;: &quot;^5.1.0&quot;,</span><br><span class="line">		&quot;eslint&quot;: &quot;^8.1.0&quot;,</span><br><span class="line">		&quot;glob&quot;: &quot;^7.1.7&quot;,</span><br><span class="line">		&quot;mocha&quot;: &quot;^9.1.3&quot;,</span><br><span class="line">		&quot;typescript&quot;: &quot;^4.4.4&quot;,</span><br><span class="line">		&quot;@vscode&#x2F;test-electron&quot;: &quot;^1.6.2&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="四、调试"><a href="#四、调试" class="headerlink" title="四、调试"></a>四、调试</h3><p>先分析一下入口文件里面的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import * as vscode from &#39;vscode&#39;;</span><br><span class="line">export function activate(context: vscode.ExtensionContext) &#123;</span><br><span class="line">	&#x2F;&#x2F; 插件激活后输出的文案</span><br><span class="line">	console.log(&#39;Congratulations, your extension &quot;rong-ui-react-helper&quot; is now active!&#39;);</span><br><span class="line"></span><br><span class="line">	let disposable &#x3D; vscode.commands.registerCommand(&#39;rong-ui-react-helper.helloWorld&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">		&#x2F;&#x2F; 执行helloWorld命令后，会展示一个vscode弹窗</span><br><span class="line">		vscode.window.showInformationMessage(&#39;Hello World from rong-ui-react-helper!&#39;);</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	context.subscriptions.push(disposable);</span><br><span class="line">&#125;</span><br><span class="line">export function deactivate() &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>按照上面的代码逻辑，插件启动后控制台会有文案输出，并且展示一个vscode弹窗，下面来验证一下。</p>
<ul>
<li><p>首先打开vscode工具栏启动调试</p>

</li>
<li><p>启动调试后，vscode会自动打开一个调试窗口</p>

</li>
<li><p>输入【commond】+【shift】+【p】打开命令行，在命令行中输入Hello World回车，可以看见右下角出现弹窗提示</p>




</li>
</ul>
<p>  打开工具栏的开发者工具，可以在vscode中打开控制台</p>
  
  

<h3 id="五、实现插件"><a href="#五、实现插件" class="headerlink" title="五、实现插件"></a>五、实现插件</h3><p>在了解了项目基本结构、运行调试之后，就可以实现我们自己的插件了。</p>
<p>在此之前，我们需要了解一下vscode插件开发常用的一些api</p>
<h4 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h4><p>文档：<a href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/" target="_blank" rel="noopener">https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 注册一个命令</span><br><span class="line">vscode.commands.registerCommand(command, commandHandler）</span><br><span class="line">&#x2F;&#x2F; hover时捕捉信息</span><br><span class="line">vscode.languages.registerHoverProvider()</span><br><span class="line">&#x2F;&#x2F; 获取光标所在单词的行列号范围</span><br><span class="line">document.getWordRangeAtPosition(position)</span><br><span class="line">&#x2F;&#x2F; 获取指定范围的文本</span><br><span class="line">document.getText()</span><br><span class="line">&#x2F;&#x2F; 创建webview</span><br><span class="line">vscode.window.createWebviewPanel()</span><br></pre></td></tr></table></figure>

<h4 id="代码片段"><a href="#代码片段" class="headerlink" title="代码片段"></a>代码片段</h4><p>输入组件名称，快速生成代码。</p>
<p>输入组件名称(小写)，vscode会提示可用的组件标签，选择Rong-Ui-xxx标志的选项，即是rong-ui-react中的组件。</p>
<p>代码片段的实现是最简单的，主要是一些配置内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; package.json</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	&quot;contributes&quot;: &#123;</span><br><span class="line">		&quot;snippets&quot;: [</span><br><span class="line">			&#123;</span><br><span class="line">				&quot;language&quot;: &quot;javascript&quot;,</span><br><span class="line">				&quot;path&quot;: &quot;.&#x2F;snippets&#x2F;index.json&quot;</span><br><span class="line">			&#125;,</span><br><span class="line">			&#123;</span><br><span class="line">				&quot;language&quot;: &quot;javascriptreact&quot;,</span><br><span class="line">				&quot;path&quot;: &quot;.&#x2F;snippets&#x2F;index.json&quot;</span><br><span class="line">			&#125;,</span><br><span class="line">			&#123;</span><br><span class="line">				&quot;language&quot;: &quot;typescript&quot;,</span><br><span class="line">				&quot;path&quot;: &quot;.&#x2F;snippets&#x2F;index.json&quot;</span><br><span class="line">			&#125;,</span><br><span class="line">			&#123;</span><br><span class="line">				&quot;language&quot;: &quot;typescriptreact&quot;,</span><br><span class="line">				&quot;path&quot;: &quot;.&#x2F;snippets&#x2F;index.json&quot;</span><br><span class="line">			&#125;</span><br><span class="line">		]</span><br><span class="line">		...</span><br><span class="line">	&#125;,</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在根目录下新建snippets/index.json文件，由于组件库会有好多组件，都写在snippets/index.json这个文件中不好维护，因此为每一个组件再建立一个文件，最终为以下结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">snippets</span><br><span class="line">│   ├── button</span><br><span class="line">│   │   └── index.json</span><br><span class="line">│   ├── checkbox</span><br><span class="line">│   │   └── index.json</span><br><span class="line">│   ├── datepicker</span><br><span class="line">│   │   └── index.json</span><br><span class="line">│   ├── flexfixed</span><br><span class="line">│   │   └── index.json</span><br><span class="line">│   ├── form</span><br><span class="line">│   │   └── index.json</span><br><span class="line">│   ├── index.json</span><br></pre></td></tr></table></figure>

<p>每一个组件中的内容其实就是snippets语法，以button/index.json为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;Rong-Ui-Button&quot;: &#123;</span><br><span class="line">    &quot;prefix&quot;: &quot;button&quot;,</span><br><span class="line">    &quot;body&quot;: [</span><br><span class="line">      &quot;&lt;Button&quot;,</span><br><span class="line">      &quot;\ttype&#x3D;&#39;dark-yellow&#39;&quot;,</span><br><span class="line">      &quot;\tclassName&#x3D;&#39;custom-button&#39;&quot;,</span><br><span class="line">      &quot;\tstyle&#x3D;&#123;&#123;color:&#39;red&#39;&#125;&#125;,&quot;,</span><br><span class="line">      &quot;&gt;&quot;,</span><br><span class="line">      &quot;\t提交&quot;,</span><br><span class="line">      &quot;&lt;&#x2F;Button&gt;&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;description&quot;: &quot;Code snippet for &#39;Button&#39;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当输入的内容为button时，vscode会出现如下提示：</p>


<p>回车选择后，就会输出完整的button组件代码：</p>




<p>特别说明的是，我们不能在package.json中为每一个组件都配置一个path，这样做的后果是每增加一个代码片段，都要更改package.json文件，效率很低，并且package.json也会很大不易阅读。因此接下来要做的就是把每一个组件下面的index.json复制到snippets/index.json中去，在package.json中只配置这一个路径就可以了。那么怎么复制呢？</p>
<p>我在项目的根目录下建立了一个脚本，combine.sh，脚本的功能是读取每个组件的配置，再写入到snippets/index.json下面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#! &#x2F;bin&#x2F;bash</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">node &#39;.&#x2F;combine.js&#39;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; combine.js</span><br><span class="line"></span><br><span class="line">const fs &#x3D; require(&#39;fs&#39;)</span><br><span class="line">const path &#x3D; require(&#39;path&#39;)</span><br><span class="line"></span><br><span class="line">let combineJson &#x3D; &#123;&#125;</span><br><span class="line">let rootPath &#x3D; &#39;.&#x2F;snippets&#39;</span><br><span class="line">let entryPath &#x3D; &#39;.&#x2F;snippets&#x2F;index.json&#39;</span><br><span class="line"></span><br><span class="line">fs.readdir(rootPath, (error, files) &#x3D;&gt; &#123;</span><br><span class="line">  files.map(filename &#x3D;&gt; &#123;</span><br><span class="line">    var filedir &#x3D; path.join(rootPath, filename)</span><br><span class="line">    var stats &#x3D; fs.statSync(filedir)</span><br><span class="line">    var isDir &#x3D; stats.isDirectory()</span><br><span class="line">    if (isDir) &#123;</span><br><span class="line">      let path &#x3D; &#96;.&#x2F;$&#123;filedir&#125;&#x2F;index.json&#96;</span><br><span class="line">      var json &#x3D; fs.readFileSync(path, &#39;utf-8&#39;)</span><br><span class="line">      combineJson &#x3D; &#123; ...combineJson, ...JSON.parse(json) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  fs.unlink(entryPath, function (err) &#123;</span><br><span class="line">    fs.writeFile(entryPath, JSON.stringify(combineJson), err &#x3D;&gt; &#123;</span><br><span class="line">      if (err) &#123;</span><br><span class="line">        throw err</span><br><span class="line">      &#125;</span><br><span class="line">      console.log(&#39;代码片段合并成功！&#39;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>为了更加方便操作，可以把这个操作配置成脚本命令，在项目打包之前，执行这个脚本进行代码片段合并处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;build&quot;: &quot;sh .&#x2F;combine.sh &amp;&amp; vsce package&quot;</span><br></pre></td></tr></table></figure>



<h4 id="hover提示"><a href="#hover提示" class="headerlink" title="hover提示"></a>hover提示</h4><p>光标悬浮组件标签之上，显示该组件的api，某一些组件的api较多(如Modal、Form等)，不适合在Hover中展示，如果需要查看具体api，请使用【查看组件详情】功能。</p>
<p>把入口文件改造一下，将hover功能差分出来，在src下建立hover/index.ts和hover/map.ts</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import * as vscode from &#39;vscode&#39;</span><br><span class="line">import hoverInfo from &#39;.&#x2F;hover&#x2F;index&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export function activate(context: vscode.ExtensionContext) &#123;</span><br><span class="line">	hoverInfo(context) &#x2F;&#x2F; 插件启动后，会执行这个方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function deactivate()&#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;hover&#x2F;index.ts</span><br><span class="line"></span><br><span class="line">import * as vscode from &#39;vscode&#39;;</span><br><span class="line">import &#123;tagMap&#125; from &#39;.&#x2F;map&#39;</span><br><span class="line"></span><br><span class="line">function hover(document: vscode.TextDocument, position: vscode.Position, token: vscode.CancellationToken) &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; getWordRangeAtPosition获取光标所在单词的行列号范围；getText获取指定范围的文本</span><br><span class="line">  const positionWord &#x3D; document.getText(document.getWordRangeAtPosition(position));</span><br><span class="line"></span><br><span class="line">  let tag &#x3D; tagMap[positionWord]</span><br><span class="line"></span><br><span class="line">  return new vscode.Hover(tag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; registerHoverProvider的第一个参数数组表明此处理器的作用范围</span><br><span class="line">const hoverDisposable &#x3D; vscode.languages.registerHoverProvider([&#39;javascript&#39;, &#39;javascriptreact&#39;], &#123;</span><br><span class="line">  provideHover: hover,</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">export default function(context) &#123;</span><br><span class="line">  context.subscriptions.push(hoverDisposable)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; hover&#x2F;map.ts</span><br><span class="line"></span><br><span class="line">export const tagMap &#x3D; &#123;</span><br><span class="line">  &#39;Titlebar&#39;: &#96;</span><br><span class="line">    title: String | ReactNode</span><br><span class="line">    theme: a | b | c | d | e | f | 自定义</span><br><span class="line">    showBackto: Boolean</span><br><span class="line">    backArrowStyle: 自定义样式</span><br><span class="line">    l: 左侧插槽 ReactNode</span><br><span class="line">    r: 右侧插槽 ReactNode</span><br><span class="line">    onBack: callback</span><br><span class="line">  &#96;,</span><br><span class="line">  &#39;Button&#39;: &#96;</span><br><span class="line">    type: default | warning | disabled</span><br><span class="line">    radius: boolean</span><br><span class="line">    fill: boolean</span><br><span class="line">    style: 自定义样式</span><br><span class="line">    onClick: callback</span><br><span class="line">  &#96;,</span><br><span class="line">  &#39;Loading&#39;: &#96;</span><br><span class="line">    icon: 图标 ReactNode</span><br><span class="line">    text: 文字 ReactNode</span><br><span class="line">    textStyle: 文字样式 CSSProperties</span><br><span class="line">  &#96;,</span><br><span class="line">  &#39;Toast&#39;: &#96;</span><br><span class="line">    content: 内容 ReactNode</span><br><span class="line">    type: long | positive | negetive</span><br><span class="line">    time: 时长 2000ms</span><br><span class="line">    callback: callback</span><br><span class="line">  &#96;,</span><br><span class="line">  &#39;FlexFixed&#39;: &#96;</span><br><span class="line">    header: ReactNode</span><br><span class="line">    footer: ReactNode</span><br><span class="line">    extra: 额外插槽位置在footer之后 ReactNode</span><br><span class="line">    onScroll: function(&#123;scrollTop, maxScrollTop, direction&#125;)</span><br><span class="line">    hideFooterOnKeyboardShow: 键盘弹起之后隐藏footer boolean</span><br><span class="line">  &#96;,</span><br><span class="line">  &#39;TextScroll&#39;: &#96;</span><br><span class="line">    list: Array</span><br><span class="line">    prepend: ReactNode</span><br><span class="line">    append: ReactNode</span><br><span class="line">  &#96;,</span><br><span class="line">  &#39;Switch&#39;: &#96;</span><br><span class="line">    defaultChecked: 默认勾选状态 boolean</span><br><span class="line">    disabled: 禁用 boolean</span><br><span class="line">    checkedChildren: 选中时的内容 ReactNode</span><br><span class="line">    unCheckedChildren: 非选中时的内容 ReactNode</span><br><span class="line">    onChange: function(checked: boolean, event: Event)</span><br><span class="line">  &#96;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现效果如下图：</p>




<h4 id="查看组件详情"><a href="#查看组件详情" class="headerlink" title="查看组件详情"></a>查看组件详情</h4><p>双击选中组件标签，右键打开面板，选择【查看组件详细用法】或使用快捷键cmd+r，快速打开组件详情窗口。</p>
<p>首先要在package.json中配置命令和快捷键</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&quot;commands&quot;: [</span><br><span class="line">			&#123;</span><br><span class="line">				&quot;command&quot;: &quot;rong-ui-react-helper.preview&quot;, &#x2F;&#x2F; 定义一个命令</span><br><span class="line">				&quot;title&quot;: &quot;查看组件详细用法&quot;</span><br><span class="line">			&#125;</span><br><span class="line">		],</span><br><span class="line">&quot;keybindings&quot;: [</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;command&quot;: &quot;rong-ui-react-helper.preview&quot;,</span><br><span class="line">    &quot;key&quot;: &quot;ctrl+r&quot;,</span><br><span class="line">    &quot;mac&quot;: &quot;cmd+r&quot;, &#x2F;&#x2F; 给命令绑定一下快捷键</span><br><span class="line">    &quot;when&quot;: &quot;editorHasSelection&quot; &#x2F;&#x2F; 当文字被选中的时候</span><br><span class="line">  &#125;</span><br><span class="line">],</span><br><span class="line">&quot;menus&quot;: &#123; &#x2F;&#x2F; 在右键菜单中新增选项</span><br><span class="line">  &quot;editor&#x2F;context&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;when&quot;: &quot;editorHasSelection&quot;,</span><br><span class="line">      &quot;command&quot;: &quot;rong-ui-react-helper.preview&quot;,</span><br><span class="line">      &quot;group&quot;: &quot;navigation&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>下面进行实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; extension.ts</span><br><span class="line"></span><br><span class="line">import * as vscode from &#39;vscode&#39;</span><br><span class="line">import createWebview from &#39;.&#x2F;webview&#x2F;index&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export function activate(context: vscode.ExtensionContext) &#123;</span><br><span class="line">	createWebview(context)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function deactivate()&#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; webview&#x2F;index.ts</span><br><span class="line">import * as vscode from &#39;vscode&#39;;</span><br><span class="line">import &#123; render &#125; from &#39;.&#x2F;render&#39;;</span><br><span class="line">import &#123;codeMap&#125; from &#39;.&#x2F;codetext&#x2F;index&#39;</span><br><span class="line"></span><br><span class="line">let panel &#x3D; null;</span><br><span class="line"></span><br><span class="line">const preview &#x3D; vscode.commands.registerCommand(&#39;rong-ui-react-helper.preview&#39;, async function (uri) &#123;</span><br><span class="line">    let editor &#x3D; vscode.window.activeTextEditor;</span><br><span class="line">    if (!editor) &#123;</span><br><span class="line">        vscode.window.showWarningMessage(&#39;请新开一个文件使用&#39;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F; 获取到当前鼠标选中的单词</span><br><span class="line">    let selection &#x3D; editor.selection;</span><br><span class="line">    const document&#x3D;editor.document;</span><br><span class="line">    let text &#x3D; document.getText(selection);</span><br><span class="line"></span><br><span class="line">    if (!codeMap[text.toLocaleLowerCase()]) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if (!panel || panel._store._isDisposed) &#123;</span><br><span class="line">        panel &#x3D; createWebviewPanel();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 将选中的单词传给render函数，render函数返回的是一个完整的html</span><br><span class="line">    panel.webview.html &#x3D; render(text);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">function createWebviewPanel() &#123;</span><br><span class="line">    let panel &#x3D; vscode.window.createWebviewPanel(</span><br><span class="line">        &#39;rong-ui-react-helper&#39;,</span><br><span class="line">        &#39;组件详细信息&#39;,</span><br><span class="line">        vscode.ViewColumn.Two, &#123;</span><br><span class="line">            enableScripts: true,</span><br><span class="line">            retainContextWhenHidden: false,</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">    panel.onDidDispose(async (event) &#x3D;&gt; &#123;</span><br><span class="line">    &#125;);</span><br><span class="line">    return panel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default function(context: vscode.ExtensionContext) &#123;</span><br><span class="line">    context.subscriptions.push(preview);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; webview&#x2F;render.ts</span><br><span class="line"></span><br><span class="line">import &#123;codeMap&#125; from &#39;.&#x2F;codetext&#x2F;index&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export const render &#x3D; (key) &#x3D;&gt; &#123;</span><br><span class="line">  var componentName &#x3D; key.toLocaleLowerCase() &#x2F;&#x2F; 将传过来的单词变成小写</span><br><span class="line">	</span><br><span class="line">  return &#96;&lt;!DOCTYPE html&gt;</span><br><span class="line">  &lt;html lang&#x3D;&quot;en&quot; style&#x3D;&quot;height: 100%&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">      &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">      &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">      &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">      &lt;style&gt;</span><br><span class="line">        textarea&#123;</span><br><span class="line">          background-color: rgb(36,33,28);</span><br><span class="line">          color: rgb(254,254,254);</span><br><span class="line">          width: 100%;</span><br><span class="line">          height: 100%;</span><br><span class="line">          resize: none;</span><br><span class="line">          overflow-x: hidden;</span><br><span class="line">          overflow-y: scroll;</span><br><span class="line">          font-size: 10px;</span><br><span class="line">          font-family: source-code-pro,Menlo,Monaco,Consolas,Courier New,monospace;</span><br><span class="line">          padding: 10px;</span><br><span class="line">          line-height: 1.8;</span><br><span class="line">        &#125;</span><br><span class="line">      &lt;&#x2F;style&gt;</span><br><span class="line">  &lt;&#x2F;head&gt;</span><br><span class="line">  &lt;body style&#x3D;&quot;height: 100%&quot;&gt;</span><br><span class="line">      &lt;h4&gt;$&#123;key&#125;组件详细信息如下：&lt;&#x2F;h4&gt;</span><br><span class="line">      &#x2F;&#x2F; 从对象中取出该组件的文档</span><br><span class="line">      &lt;textarea readonly&gt;$&#123;codeMap[componentName]&#125;&lt;&#x2F;textarea&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">  &lt;&#x2F;html&gt;&#96;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里要注意的是，codetext/index.ts也是由脚本处理的，脚本的功能就是将每一个组件的文档合并成一个</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">codetext</span><br><span class="line">│   ├── button</span><br><span class="line">│   │   └── index.txt</span><br><span class="line">│   ├── checkbox</span><br><span class="line">│   │   └── index.txt</span><br><span class="line">│   ├── datepicker</span><br><span class="line">│   │   └── index.txt</span><br><span class="line">│   ├── flexfixed</span><br><span class="line">│   │   └── index.txt</span><br><span class="line">│   ├── form</span><br><span class="line">│   │   └── index.txt</span><br><span class="line">│   ├── index.ts</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">const fs &#x3D; require(&#39;fs&#39;)</span><br><span class="line">const path &#x3D; require(&#39;path&#39;)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">var _rootPath &#x3D; &#39;.&#x2F;src&#x2F;webview&#x2F;codetext&#39;</span><br><span class="line">var _codeMap &#x3D; &#123;&#125;</span><br><span class="line">let _exportPath &#x3D; &#39;.&#x2F;src&#x2F;webview&#x2F;codetext&#x2F;index.ts&#39;</span><br><span class="line"></span><br><span class="line">fs.readdir(_rootPath, (error, files) &#x3D;&gt; &#123;</span><br><span class="line">  files.map(filename &#x3D;&gt; &#123;</span><br><span class="line">    var filedir &#x3D; path.join(_rootPath, filename)</span><br><span class="line">    var stats &#x3D; fs.statSync(filedir)</span><br><span class="line">    var isDir &#x3D; stats.isDirectory()</span><br><span class="line">    if (isDir) &#123;</span><br><span class="line">      let path &#x3D; &#96;.&#x2F;$&#123;filedir&#125;&#x2F;index.txt&#96;</span><br><span class="line">      var json &#x3D; fs.readFileSync(path, &#39;utf-8&#39;)</span><br><span class="line">      _codeMap &#x3D; &#123;..._codeMap, ...&#123;[filename]: json&#125;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  fs.writeFile(_exportPath, &quot;export var codeMap&#x3D;&quot;+JSON.stringify(_codeMap), err &#x3D;&gt; &#123;</span><br><span class="line">    if (err) &#123;</span><br><span class="line">      throw err</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&#39;组件文档准备成功！&#39;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>最终实现效果如下所示：</p>


<h3 id="六、项目打包"><a href="#六、项目打包" class="headerlink" title="六、项目打包"></a>六、项目打包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g vsce</span><br><span class="line">vsce package</span><br></pre></td></tr></table></figure>

<h3 id="七、发布到插件市场"><a href="#七、发布到插件市场" class="headerlink" title="七、发布到插件市场"></a>七、发布到插件市场</h3><p>略</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/05/13/http-15/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/2356874721.github.io/images/avatar.gif">
      <meta itemprop="name" content="sheriff">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="警长的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2356874721.github.io/2021/05/13/http-15/" class="post-title-link" itemprop="url">15 | HTTP传输大文件的方法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-13 09:49:33" itemprop="dateCreated datePublished" datetime="2021-05-13T09:49:33+08:00">2021-05-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-12 15:02:02" itemprop="dateModified" datetime="2021-09-12T15:02:02+08:00">2021-09-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/2356874721.github.io/categories/HTTP/" itemprop="url" rel="index"><span itemprop="name">HTTP</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>HTTP 可以传输很多种类的数据，不仅是文本，也能传输图片、音频和视频。</p>
<p>早期互联网上传输的基本上都是只有几 K 大小的文本和小图片，现在的情况则大有不同。网页里包含的信息实在是太多了，随随便便一个主页 HTML 就有可能上百 K，高质量的图片都以 M 论，更不要说那些电影、电视剧了，几 G、几十 G 都有可能。</p>
<p>相比之下，100M 的光纤固网或者 4G 移动网络在这些大文件的压力下都变成了“小水管”，无论是上传还是下载，都会把网络传输链路挤的“满满当当”。</p>
<p>所以，<strong>如何在有限的带宽下高效快捷地传输这些大文件就成了一个重要的课题</strong>。这就好比是已经打开了冰箱门（建立连接），该怎么把大象（文件）塞进去再关上门（完成传输）呢？</p>
<p>今天我们就一起看看 HTTP 协议里有哪些手段能解决这个问题。</p>
<h3 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h3><p>还记得上一讲中说到的“数据类型与编码”吗？如果你还有印象的话，肯定能够想到一个最基本的解决方案，那就是“<strong>数据压缩</strong>”，把大象变成小猪佩奇，再放进冰箱。</p>
<p>通常浏览器在发送请求时都会带着“<strong>Accept-Encoding</strong>”头字段，里面是浏览器支持的压缩格式列表，例如 gzip、deflate、br 等，这样服务器就可以从中选择一种压缩算法，放进“<strong>Content-Encoding</strong>”响应头里，再把原数据压缩后发给浏览器。</p>
<p>如果压缩率能有 50%，也就是说 100K 的数据能够压缩成 50K 的大小，<strong>那么就相当于在带宽不变的情况下网速提升了一倍</strong>，加速的效果是非常明显的。</p>
<p>不过这个解决方法也有个缺点，<strong>gzip 等压缩算法通常只对文本文件有较好的压缩率，而图片、音频视频等多媒体数据本身就已经是高度压缩的，再用 gzip 处理也不会变小（甚至还有可能会增大一点），所以它就失效了。</strong></p>
<p>不过<strong>数据压缩在处理文本的时候效果还是很好的</strong>，所以各大网站的服务器都会使用这个手段作为“保底”。例如，在 Nginx 里就会使用“<strong>gzip on</strong>”指令，<strong>启用对“text/html”的压缩</strong>。</p>
<h3 id="分块传输"><a href="#分块传输" class="headerlink" title="分块传输"></a>分块传输</h3><p>在数据压缩之外，还能有什么办法来解决大文件的问题呢？</p>
<p><strong>压缩是把大文件整体变小，我们可以反过来思考，如果大文件整体不能变小，那就把它“拆开”，分解成多个小块，把这些小块分批发给浏览器，浏览器收到后再组装复原。</strong></p>
<p>这样浏览器和服务器都不用在内存里保存文件的全部，<strong>每次只收发一小部分</strong>，网络也不会被大文件长时间占用，内存、带宽等资源也就节省下来了。</p>
<p>这种“<strong>化整为零</strong>”的思路在 HTTP 协议里就是“<strong>chunked</strong>”分块传输编码，在响应报文里用头字段“<strong>Transfer-Encoding: chunked</strong>”来表示，<strong>意思是报文里的 body 部分不是一次性发过来的，而是分成了许多的块（chunk）逐个发送</strong>。</p>
<p>这就好比是用魔法把大象变成“乐高积木”，拆散了逐个装进冰箱，到达目的地后再施法拼起来“满血复活”。</p>
<p>分块传输也可以用于“<strong>流式数据</strong>”，例如由数据库动态生成的表单页面，这种情况下 body 数据的长度是未知的，<strong>无法在头字段“Content-Length”里给出确切的长度，所以也只能用 chunked 方式分块发送</strong>。</p>
<p><strong>“Transfer-Encoding: chunked”和“Content-Length”这两个字段是互斥的，也就是说响应报文里这两个字段不能同时出现，一个响应报文的传输要么是长度已知，要么是长度未知（chunked），这一点你一定要记住</strong>。</p>
<p>下面我们来看一下分块传输的编码规则，其实也很简单，同样采用了明文的方式，很类似响应头。</p>
<ul>
<li>每个分块包含两个部分，长度头和数据块；</li>
<li>长度头是以 CRLF（回车换行，即\r\n）结尾的一行明文，用 16 进制数字表示长度；</li>
<li>数据块紧跟在长度头后，最后也用 CRLF 结尾，但数据不包含 CRLF；</li>
<li><strong>最后用一个长度为 0 的块表示结束</strong>，即“0\r\n\r\n”。、</li>
</ul>
<p>听起来好像有点难懂，看一下图就好理解了：</p>
<img src="/2356874721.github.io/2021/05/13/http-15/15-1.png" class>

<p>响应报文里的 chunked 数据格式：先是一行 16 进制长度，然后是数据，然后再是 16 进制长度和数据，如此重复，最后是 0 长度分块结束。</p>
<img src="/2356874721.github.io/2021/05/13/http-15/15-2.png" class>

<h3 id="范围请求"><a href="#范围请求" class="headerlink" title="范围请求"></a>范围请求</h3><p>有了分块传输编码，服务器就可以轻松地收发大文件了，但对于<strong>上 G</strong> 的超大文件，还有一些问题需要考虑。</p>
<p>比如，你在看当下正热播的某穿越剧，想跳过片头，直接看正片，或者有段剧情很无聊，想拖动进度条快进几分钟，<strong>这实际上是想获取一个大文件其中的片段数据，而分块传输并没有这个能力</strong>。</p>
<p>HTTP 协议为了满足这样的需求，提出了“<strong>范围请求</strong>”（range requests）的概念，<strong>允许客户端在请求头里使用专用字段来表示只获取文件的一部分，相当于是客户端的“化整为零”</strong>。</p>
<p>范围请求不是 Web 服务器必备的功能，可以实现也可以不实现，所以服务器必须在响应头里使用字段<strong>“Accept-Ranges: bytes</strong>”明确告知客户端：“我是支持范围请求的”。</p>
<p>如果不支持的话该怎么办呢？服务器可以发送“<strong>Accept-Ranges: none</strong>”，或者<strong>干脆不发送“Accept-Ranges”字段，这样客户端就认为服务器没有实现范围请求功能，只能老老实实地收发整块文件了。</strong></p>
<p><strong>请求头 Range</strong> 是 HTTP 范围请求的专用字段，格式是<strong>“bytes=x-y</strong>”，其中的 x 和 y 是以字节为单位的数据范围。</p>
<p>要注意 x、y 表示的是“偏移量”，范围必须从 0 计数，例如前 10 个字节表示为“0-9”，第二个 10 字节表示为“10-19”，而“0-10”实际上是前 11 个字节。</p>
<p>Range 的格式也很灵活，起点 x 和终点 y 可以省略，能够很方便地表示正数或者倒数的范围。假设文件是 100 个字节，那么：</p>
<ul>
<li>“0-”表示从文档起点到文档终点，相当于“0-99”，即整个文件；</li>
<li>“10-”是从第 10 个字节开始到文档末尾，相当于“10-99”；</li>
<li>“-1”是文档的最后一个字节，相当于“99-99”；</li>
<li>“-10”是从文档末尾倒数 10 个字节，相当于“90-99”。</li>
</ul>
<p>服务器收到 Range 字段后，需要做四件事。</p>
<p><strong>第一，它必须检查范围是否合法</strong>，比如文件只有 100 个字节，但请求“200-300”，这就是<strong>范围越界</strong>了。服务器就会返回状态码 <strong>416</strong>，意思是“你的范围请求有误，我无法处理，请再检查一下”。</p>
<p><strong>第二，如果范围正确</strong>，服务器就可以根据 Range 头计算偏移量，<strong>读取文件的片段</strong>了，返回状态码“<strong>206 Partial Content</strong>”，和 200 的意思差不多，但<strong>表示 body 只是原数据的一部分</strong>。</p>
<p><strong>第三，服务器要添加一个响应头字段 Content-Range</strong>，告诉片段的<strong>实际偏移量和资源的总大小</strong>，格式是“<strong>bytes x-y/length</strong>”，与 Range 头区别在没有“=”，范围后多了总长度。例如，对于“0-10”的范围请求，值就是“bytes 0-10/100”。</p>
<p>最后剩下的就是发送数据了，直接把片段用 TCP 发给客户端，一个范围请求就算是处理完了。</p>
<p>有了范围请求之后，HTTP 处理大文件就更加轻松了，看视频时可以根据时间点计算出文件的 Range，不用下载整个文件，直接精确获取片段所在的数据内容。</p>
<p><strong>不仅看视频的拖拽进度需要范围请求，常用的下载工具里的多段下载、断点续传也是基于它实现的，要点是：</strong></p>
<ul>
<li>先发个 HEAD，看服务器是否支持范围请求，同时获取文件的大小；</li>
<li>开 N 个线程，每个线程使用 Range 字段划分出各自负责下载的片段，发请求传输数据；</li>
<li>下载意外中断也不怕，不必重头再来一遍，只要根据上次的下载记录，用 Range 请求剩下的那一部分就可以了。</li>
</ul>
<h3 id="多段数据"><a href="#多段数据" class="headerlink" title="多段数据"></a>多段数据</h3><p>刚才说的范围请求一次只获取一个片段，其实它还支持在 Range 头里使用多个“x-y”，一次性获取多个片段数据。</p>
<p>这种情况需要使用一种特殊的 MIME 类型：“<strong>multipart/byteranges</strong>”，表示报文的 body 是由多段字节序列组成的，并且还要用一个参数“<strong>boundary=xxx</strong>”给出段之间的分隔标记。</p>
<p>多段数据的格式与分块传输也比较类似，但它需要用分隔标记 boundary 来区分不同的片段，可以通过图来对比一下。</p>
<img src="/2356874721.github.io/2021/05/13/http-15/15-3.png" class>

<p><strong>每一个分段必须以“- -boundary”开始（前面加两个“-”），之后要用“Content-Type”和“Content-Range”标记这段数据的类型和所在范围，然后就像普通的响应头一样以回车换行结束，再加上分段数据，最后用一个“- -boundary- -”（前后各有两个“-”）表示所有的分段结束。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /<span class="number">16</span><span class="number">-2</span> HTTP/<span class="number">1.1</span></span><br><span class="line">Host: www.chrono.com</span><br><span class="line">Range: bytes=<span class="number">0</span><span class="number">-9</span>, <span class="number">20</span><span class="number">-29</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">206</span> Partial Content</span><br><span class="line">Content-Type: multipart/byteranges; boundary=<span class="number">00000000001</span></span><br><span class="line">Content-Length: <span class="number">189</span></span><br><span class="line">Connection: keep-alive</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-<span class="number">-00000000001</span></span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Range: bytes <span class="number">0</span><span class="number">-9</span>/<span class="number">96</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// this is</span></span><br><span class="line">-<span class="number">-00000000001</span></span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Range: bytes <span class="number">20</span><span class="number">-29</span>/<span class="number">96</span></span><br><span class="line"></span><br><span class="line">ext json d</span><br><span class="line">-<span class="number">-00000000001</span>--</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol>
<li><strong>压缩 HTML</strong> 等文本文件是传输大文件最基本的方法；</li>
<li><strong>分块传输</strong>可以流式收发数据，节约内存和带宽，使用响应头字段“Transfer-Encoding: chunked”来表示，分块的格式是 16 进制长度头 + 数据块；</li>
<li><strong>范围请求</strong>可以只获取部分数据，即“分块请求”，实现视频拖拽或者断点续传，使用请求头字段“Range”和响应头字段“Content-Range”，响应状态码必须是 206；</li>
<li>也可以一次<strong>请求多个范围</strong>，这时候响应报文的数据类型是“multipart/byteranges”，body 里的多个部分会用 boundary 字符串分隔。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/05/08/http-14/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/2356874721.github.io/images/avatar.gif">
      <meta itemprop="name" content="sheriff">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="警长的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2356874721.github.io/2021/05/08/http-14/" class="post-title-link" itemprop="url">14 | 海纳百川：HTTP的实体数据</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-08 11:30:55" itemprop="dateCreated datePublished" datetime="2021-05-08T11:30:55+08:00">2021-05-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-12 15:02:02" itemprop="dateModified" datetime="2021-09-12T15:02:02+08:00">2021-09-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/2356874721.github.io/categories/HTTP/" itemprop="url" rel="index"><span itemprop="name">HTTP</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在前面我们了解了 HTTP 报文的结构，知道一个 HTTP 报文是由“header+body”组成的。但那时我们主要研究的是 header，没有涉及到 body。</p>
<h3 id="数据类型与编码"><a href="#数据类型与编码" class="headerlink" title="数据类型与编码"></a>数据类型与编码</h3><p>在 TCP/IP 协议栈里，传输数据基本上都是“header+body”的格式。但 TCP、UDP 因为是传输层的协议，它们不会关心 body 数据是什么，只要把数据发送到对方就算是完成了任务。</p>
<p>而 HTTP 协议则不同，它是应用层的协议，数据到达之后工作只能说是完成了一半，还必须要告诉上层应用这是什么数据才行，否则上层应用就会“不知所措”。</p>
<p>你可以设想一下，假如 HTTP 没有告知数据类型的功能，服务器把“一大坨”数据发给了浏览器，浏览器看到的是一个“黑盒子”，这时候该怎么办呢？</p>
<p>当然，它可以“猜”。因为很多数据都是有固定格式的，所以通过检查数据的前几个字节也许就能知道这是个 GIF 图片、或者是个 MP3 音乐文件，但这种方式无疑十分低效，而且有很大几率会检查不出来文件类型。</p>
<p>幸运的是，早在 HTTP 协议诞生之前就已经有了针对这种问题的解决方案，不过它是用在电子邮件系统里的，让电子邮件可以发送 ASCII 码以外的任意数据，方案的名字叫做“<strong>多用途互联网邮件扩展</strong>”（Multipurpose Internet Mail Extensions），简称为 <strong>MIME</strong>。</p>
<p>MIME 是一个很大的标准规范，但 HTTP 只“顺手牵羊”取了其中的一部分，用来标记 body 的数据类型，这就是我们平常总能听到的“<strong>MIME type</strong>”。</p>
<p>MIME 把数据分成了<strong>八大类，每个大类下再细分出多个子类，形式是“type/subtype”</strong>的字符串，巧得很，刚好也符合了 HTTP 明文的特点，所以能够很容易地纳入 HTTP 头字段里。</p>
<p>这里简单列举一下在 HTTP 里经常遇到的几个类别：</p>
<ul>
<li>text：即文本格式的可读数据，我们最熟悉的应该就是 text/html 了，表示超文本文档，此外还有纯文本 text/plain、样式表 text/css 等。</li>
<li>image：即图像文件，有 image/gif、image/jpeg、image/png 等。</li>
<li>audio/video：音频和视频数据，例如 audio/mpeg、video/mp4 等。</li>
<li>application：数据格式不固定，可能是文本也可能是二进制，必须由上层应用程序来解释。常见的有 application/json，application/javascript、application/pdf 等，另外，如果实在是不知道数据是什么类型，像刚才说的“黑盒”，就会是 application/octet-stream，即不透明的二进制数据。</li>
</ul>
<p>但仅有 MIME type 还不够，因为 HTTP 在传输时为了<strong>节约带宽</strong>，有时候还会<strong>压缩数据</strong>，为了不要让浏览器继续“猜”，还需要有一个“<strong>Encoding type</strong>”，告诉数据是用的什么<strong>编码格式</strong>，这样对方才能正确解压缩，还原出原始的数据。</p>
<p>比起 MIME type 来说，Encoding type 就少了很多，常用的只有下面三种：</p>
<ul>
<li>gzip：GNU zip 压缩格式，也是互联网上最流行的压缩格式；</li>
<li>deflate：zlib（deflate）压缩格式，流行程度仅次于 gzip；</li>
<li>br：一种专门为 HTTP 优化的新压缩算法（Brotli）。</li>
</ul>
<h3 id="数据类型使用的头字段"><a href="#数据类型使用的头字段" class="headerlink" title="数据类型使用的头字段"></a>数据类型使用的头字段</h3><p>有了 MIME type 和 Encoding type，无论是浏览器还是服务器就都可以轻松识别出 body 的类型，也就能够正确处理数据了。</p>
<p>HTTP 协议为此定义了两个 Accept 请求头字段和两个 Content 实体头字段，用于<strong>客户端和服务器进行“内容协商”</strong>。也就是说，客户端用 Accept 头告诉服务器希望接收什么样的数据，而服务器用 Content 头告诉客户端实际发送了什么样的数据。</p>
<img src="/2356874721.github.io/2021/05/08/http-14/14-1.png" class>

<p>Accept 字段标记的是客户端可理解的 MIME type，可以用“,”做分隔符列出多个类型，让服务器有更多的选择余地，例如下面的这个头：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept: text/html,application/xml,image/webp,image/png</span><br></pre></td></tr></table></figure>

<p>这就是告诉服务器：“我能够看懂 HTML、XML 的文本，还有 webp 和 png 的图片，请给我这四类格式的数据”。</p>
<p>相应的，服务器会在响应报文里用头字段 Content-Type 告诉实体数据的真实类型：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: text/html</span><br><span class="line">Content-Type: image/png</span><br></pre></td></tr></table></figure>

<p>这样浏览器看到报文里的类型是“text/html”就知道是 HTML 文件，会调用排版引擎渲染出页面，看到“image/png”就知道是一个 PNG 文件，就会在页面上显示出图像。</p>
<p><strong>Accept-Encoding</strong> <strong>字段标记的是客户端支持的压缩格式</strong>，例如上面说的 gzip、deflate 等，同样也可以用“,”列出多个，服务器可以选择其中一种来压缩数据，<strong>实际使用的压缩格式放在响应头字段 Content-Encoding 里</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Content-Encoding: gzip</span><br></pre></td></tr></table></figure>

<p>不过这两个字段是可以省略的，<strong>如果请求报文里没有 Accept-Encoding 字段，就表示客户端不支持压缩数据；如果响应报文里没有 Content-Encoding 字段，就表示响应数据没有被压缩</strong>。</p>
<h3 id="语言类型与编码"><a href="#语言类型与编码" class="headerlink" title="语言类型与编码"></a>语言类型与编码</h3><p>MIME type 和 Encoding type 解决了计算机理解 body 数据的问题，但互联网遍布全球，不同国家不同地区的人使用了很多不同的语言，虽然都是 text/html，但如何让浏览器显示出每个人都可理解可阅读的语言文字呢？这实际上就是“<strong>国际化</strong>”的问题。HTTP 采用了与数据类型相似的解决方案，又引入了两个概念：<strong>语言类型与字符集</strong>。</p>
<p>所谓的“语言类型”就是人类使用的自然语言，例如英语、汉语、日语等，而这些自然语言可能还有下属的地区性方言，所以在需要明确区分的时候也要使用“<strong>type-subtype</strong>”的形式，不过这里的格式与数据类型不同，<strong>分隔符不是“/”，而是“-”</strong>。</p>
<p>举几个例子：<strong>en 表示任意的英语，en-US 表示美式英语，en-GB 表示英式英语，而 zh-CN 就表示我们最常使用的汉语</strong>。</p>
<p>关于自然语言的计算机处理还有一个更麻烦的东西叫做“字符集”。</p>
<p>在计算机发展的早期，各个国家和地区的人们“各自为政”，发明了许多字符编码方式来处理文字，比如英语世界用的 ASCII、汉语世界用的 GBK、BIG5，日语世界用的 Shift_JIS 等。同样的一段文字，用一种编码显示正常，换另一种编码后可能就会变得一团糟。</p>
<p>所以后来就出现了 Unicode 和 UTF-8，把世界上所有的语言都容纳在一种编码方案里，<strong>遵循 UTF-8 字符编码方式的 Unicode 字符集也成为了互联网上的标准字符集</strong>。</p>
<h3 id="语言类型使用的头字段"><a href="#语言类型使用的头字段" class="headerlink" title="语言类型使用的头字段"></a>语言类型使用的头字段</h3><p>同样的，HTTP 协议也使用 Accept 请求头字段和 Content 实体头字段，用于<strong>客户端和服务器就语言与编码进行“内容协商”</strong>。</p>
<p><strong>Accept-Language</strong> 字段标记了客户端可理解的自然语言，也允许用“,”做分隔符列出多个类型，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Language: zh-CN, zh, en</span><br></pre></td></tr></table></figure>

<p><strong>这个请求头会告诉服务器：“最好给我 zh-CN 的汉语文字，如果没有就用其他的汉语方言，如果还没有就给英文”。</strong></p>
<p>相应的，服务器应该在响应报文里用头字段 <strong>Content-Language</strong> 告诉客户端实体数据使用的实际语言类型：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Language: zh-CN</span><br></pre></td></tr></table></figure>

<p><strong>字符集在 HTTP 里使用的请求头字段是 Accept-Charset</strong>，<strong>但响应头里却没有对应的 Content-Charset，而是在 Content-Type 字段的数据类型后面用“charset=xxx”来表示，这点需要特别注意</strong>。</p>
<p>例如，浏览器请求 GBK 或 UTF-8 的字符集，然后服务器返回的是 UTF-8 编码，就是下面这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Accept-Charset: gbk, utf<span class="number">-8</span></span><br><span class="line">Content-Type: text/html; charset=utf<span class="number">-8</span></span><br></pre></td></tr></table></figure>

<p><strong><u>不过现在的浏览器都支持多种字符集，通常不会发送 Accept-Charset，而服务器也不会发送 Content-Language，因为使用的语言完全可以由字符集推断出来，所以在请求头里一般只会有 Accept-Language 字段，响应头里只会有 Content-Type 字段。</u></strong></p>
<h3 id="内容协商的质量值"><a href="#内容协商的质量值" class="headerlink" title="内容协商的质量值"></a>内容协商的质量值</h3><p>在 HTTP 协议里用 Accept、Accept-Encoding、Accept-Language 等请求头字段进行内容协商的时候，还可以用一种特殊的<strong>“q”参数表示权重来设定优先级</strong>，这里的“q”是“quality factor”的意思。</p>
<p><strong>权重的最大值是 1，最小值是 0.01，<u>默认值是 1</u>，如果值是 0 就表示拒绝。具体的形式是在数据类型或语言代码后面加一个“;”，然后是“q=value”。</strong></p>
<p><strong>这里要提醒的是“;”的用法，在大多数编程语言里“;”的断句语气要强于“,”，而在 HTTP 的内容协商里却恰好反了过来，“;”的意义是小于“,”的。</strong></p>
<p>例如下面的 Accept 字段：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept: text/html,application/xml;q=<span class="number">0.9</span>,*<span class="comment">/*;q=0.8</span></span><br></pre></td></tr></table></figure>

<p>它表示浏览器最希望使用的是 HTML 文件，权重是 1，其次是 XML 文件，权重是 0.9，最后是任意数据类型，权重是 0.8。服务器收到请求头后，就会计算权重，再根据自己的实际情况优先输出 HTML 或者 XML。</p>
<h3 id="内容协商的结果"><a href="#内容协商的结果" class="headerlink" title="内容协商的结果"></a>内容协商的结果</h3><p>内容协商的过程是不透明的，每个 Web 服务器使用的算法都不一样。但有的时候，服务器会在响应头里多加一个 <strong>Vary</strong> 字段，记录服务器在内容协商时参考的请求头字段，给出一点信息，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vary: Accept-Encoding,User-Agent,Accept</span><br></pre></td></tr></table></figure>

<p><strong>这个 Vary 字段表示服务器依据了 Accept-Encoding、User-Agent 和 Accept 这三个头字段，然后决定了发回的响应报文。</strong></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>今天我们学习了 HTTP 里的数据类型和语言类型，在这里为今天的内容做个小结。</p>
<img src="/2356874721.github.io/2021/05/08/http-14/14-2.png" class>

<ol>
<li>数据类型表示实体数据的内容是什么，使用的是 MIME type，相关的头字段是 Accept 和 Content-Type；</li>
<li>数据编码表示实体数据的压缩方式，相关的头字段是 Accept-Encoding 和 Content-Encoding；</li>
<li>语言类型表示实体数据的自然语言，相关的头字段是 Accept-Language 和 Content-Language；</li>
<li>字符集表示实体数据的编码方式，相关的头字段是 Accept-Charset 和 Content-Type；</li>
<li>客户端需要在请求头里使用 Accept 等头字段与服务器进行“内容协商”，要求服务器返回最合适的数据；</li>
<li>Accept 等头字段可以用“,”顺序列出多个可能的选项，还可以用“;q=”参数来精确指定权重。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/04/22/http-13/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/2356874721.github.io/images/avatar.gif">
      <meta itemprop="name" content="sheriff">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="警长的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2356874721.github.io/2021/04/22/http-13/" class="post-title-link" itemprop="url">13 | HTTP有哪些优点？又有哪些缺点？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-22 20:42:09" itemprop="dateCreated datePublished" datetime="2021-04-22T20:42:09+08:00">2021-04-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-12 15:02:02" itemprop="dateModified" datetime="2021-09-12T15:02:02+08:00">2021-09-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/2356874721.github.io/categories/HTTP/" itemprop="url" rel="index"><span itemprop="name">HTTP</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今天的讨论范围仅限于 HTTP/1.1，所说的优点和缺点也仅针对 HTTP/1.1。</p>
<h3 id="简单、灵活、易于扩展"><a href="#简单、灵活、易于扩展" class="headerlink" title="简单、灵活、易于扩展"></a>简单、灵活、易于扩展</h3><p>首先，HTTP 最重要也是最突出的优点是“<strong>简单、灵活、易于扩展</strong>”。</p>
<p>初次接触 HTTP 的人都会认为，HTTP 协议是很“简单”的，基本的报文格式就是“<strong>header+body</strong>”，头部信息也是简单的文本格式，用的也都是常见的英文单词，即使不去看 RFC 文档，只靠猜也能猜出个“八九不离十”。</p>
<p>可不要小看了“简单”这个优点，它不仅降低了学习和使用的门槛，能够让更多的人研究和开发 HTTP 应用，<strong>“简单”蕴含了进化和扩展的可能性，所谓“少即是多”，“把简单的系统变复杂”，要比“把复杂的系统变简单”容易得多</strong>。</p>
<p>所以，在“简单”这个最基本的设计理念之下，HTTP 协议又多出了“灵活和易于扩展”的优点。</p>
<p>“灵活和易于扩展”实际上是一体的，它们互为表里、相互促进，因为“灵活”所以才会“易于扩展”，而“易于扩展”又反过来让 HTTP 更加灵活，拥有更强的表现能力。</p>
<p>HTTP 协议里的<em>请求方法、URI、状态码、原因短语、头字段等每一个核心组成要素都没有被“写死”，允许开发者任意定制、扩充或解释，给予了浏览器和服务器最大程度的信任和自由，也正好符合了互联网“自由与平等”的精神——缺什么功能自己加个字段或者错误码什么的补上就是了。</em></p>
<p>“请勿跟踪”所使用的头字段 <strong>DNT</strong>（Do Not Track）就是一个很好的例子。它最早由 Mozilla 提出，<strong>用来保护用户隐私，防止网站监测追踪用户的偏好</strong>。不过可惜的是 DNT 从推出至今有差不多七八年的历史，但很多网站仍然选择“无视”DNT。虽然 DNT 基本失败了，但这也正说明 HTTP 协议是“灵活自由的”，不会受单方面势力的压制。</p>
<p>“灵活、易于扩展”的特性还表现在 HTTP 对“<strong>可靠传输</strong>”的定义上，<strong>它不限制具体的下层协议，不仅可以使用 TCP、UNIX Domain Socket，还可以使用 SSL/TLS，甚至是基于 UDP 的 QUIC，下层可以随意变化，而上层的语义则始终保持稳定</strong>。</p>
<h3 id="应用广泛、环境成熟"><a href="#应用广泛、环境成熟" class="headerlink" title="应用广泛、环境成熟"></a>应用广泛、环境成熟</h3><p>HTTP 协议的另一大优点是“<strong>应用广泛</strong>”，软硬件环境都非常成熟。</p>
<p>随着互联网特别是移动互联网的普及，<strong>HTTP 的触角已经延伸到了世界的每一个角落</strong>：从简单的 Web 页面到复杂的 JSON、XML 数据，从台式机上的浏览器到手机上的各种 APP，从看新闻、泡论坛到购物、理财、“吃鸡”，你很难找到一个没有使用 HTTP 的地方。</p>
<p>不仅在应用领域，在开发领域 HTTP 协议也得到了广泛的支持。它并不限定某种编程语言或者操作系统，所以天然具有“<strong>跨语言、跨平台</strong>”的优越性。而且，因为本身的简单特性很容易实现，所以几乎所有的编程语言都有 HTTP 调用库和外围的开发测试工具，这一点我觉得就不用再举例了吧，你可能比我更熟悉。</p>
<p>HTTP 广泛应用的背后还有许多硬件基础设施支持，各个互联网公司和传统行业公司都不遗余力地“触网”，购买服务器开办网站，建设数据中心、CDN 和高速光纤，持续地优化上网体验，让 HTTP 运行的越来越顺畅。</p>
<p>“应用广泛”的这个优点也就决定了：无论是创业者还是求职者，无论是做网站服务器还是写应用客户端，HTTP 协议都是必须要掌握的基本技能。</p>
<h3 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h3><p>看过了两个优点，我们再来看看一把“<strong>双刃剑</strong>”，也就是上一讲中说到的“无状态”，它对于 HTTP 来说既是优点也是缺点。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p><strong>因为服务器没有“记忆能力”，所以就不需要额外的资源来记录状态信息，不仅实现上会简单一些，而且还能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务。</strong></p>
<p><strong>而且，“无状态”也表示服务器都是相同的，没有“状态”的差异，所以可以很容易地组成集群，让负载均衡把请求转发到任意一台服务器，不会因为状态不一致导致处理出错，使用“堆机器”的“笨办法”轻松实现高并发高可用。</strong></p>
<h4 id="坏处"><a href="#坏处" class="headerlink" title="坏处"></a>坏处</h4><p>既然服务器没有“记忆能力”，它就<strong>无法支持需要连续多个步骤的“事务”操作</strong>。<strong>例如电商购物，首先要登录，然后添加购物车，再下单、结算、支付，这一系列操作都需要知道用户的身份才行，但“无状态”服务器是不知道这些请求是相互关联的，每次都得问一遍身份信息，不仅麻烦，而且还增加了不必要的数据传输量</strong>。</p>
<h3 id="明文"><a href="#明文" class="headerlink" title="明文"></a>明文</h3><p>HTTP 协议里还有一把优缺点一体的“<strong>双刃剑</strong>”，就是明文传输。</p>
<p><strong>“明文”意思就是协议里的报文（准确地说是 header 部分）不使用二进制数据，而是用简单可阅读的文本形式。</strong></p>
<h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><p>对比 TCP、UDP 这样的二进制协议，它的优点显而易见，<strong>不需要借助任何外部工具，用浏览器、Wireshark 或者 tcpdump 抓包后，直接用肉眼就可以很容易地查看或者修改，为我们的开发调试工作带来极大的便利</strong>。</p>
<h4 id="坏处-1"><a href="#坏处-1" class="headerlink" title="坏处"></a>坏处</h4><p>当然，明文的缺点也是一样显而易见，HTTP 报文的所有信息都会<strong>暴露在“光天化日之下”，在漫长的传输链路的每一个环节上都毫无隐私可言，不怀好意的人只要侵入了这个链路里的某个设备，简单地“旁路”一下流量，就可以实现对通信的窥视</strong>。</p>
<h3 id="不安全"><a href="#不安全" class="headerlink" title="不安全"></a>不安全</h3><p>安全有很多的方面，明文只是“机密”方面的一个缺点，在“<strong>身份认证</strong>”和“<strong>完整性校验</strong>”这两方面 HTTP 也是欠缺的。</p>
<p>HTTP 没有提供有效的手段来确认通信双方的真实身份。虽然协议里有一个基本的认证机制，但因为刚才所说的明文传输缺点，这个机制几乎可以说是“纸糊的”，非常容易被攻破。如果仅使用 HTTP 协议，很可能你会连到一个页面一模一样但却是个假冒的网站，然后再被“钓”走各种私人信息。</p>
<p>HTTP 协议也不支持“完整性校验”，数据在传输过程中容易被窜改而无法验证真伪。比如，你收到了一条银行用 HTTP 发来的消息：“小明向你转账一百元”，你无法知道小明是否真的就只转了一百元，也许他转了一千元或者五十元，但被黑客窜改成了一百元，真实情况到底是什么样子 HTTP 协议没有办法给你答案。</p>
<p><strong>为了解决 HTTP 不安全的缺点，所以就出现了 HTTPS</strong>，这个我们以后再说。</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>最后我们来谈谈 HTTP 的性能，可以用六个字来概括：“不算差，不够好”。</p>
<p>HTTP 协议基于 TCP/IP，并且使用了“请求 - 应答”的通信模式，所以性能的关键就在这两点上。</p>
<p>必须要说的是，<strong>TCP 的性能是不差的</strong>，否则也不会纵横互联网江湖四十余载了，而且它已经被研究的很透，集成在操作系统内核里经过了细致的优化，足以应付大多数的场景。</p>
<p>只可惜如今的江湖已经不是从前的江湖，现在互联网的特点是<strong>移动和高并发</strong>，不能保证稳定的连接质量，所以在 TCP 层面上 HTTP 协议有时候就会表现的不够好。</p>
<p>而“请求 - 应答”模式则加剧了 HTTP 的性能问题，这就是著名的“<strong>队头阻塞</strong>”（Head-of-line blocking），当顺<strong>序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一并被阻塞，会导致客户端迟迟收不到数据</strong>。</p>
<p>不过现在已经有了终极解决方案：HTTP/2 和 HTTP/3.</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol>
<li>HTTP 最大的优点是简单、灵活和易于扩展；</li>
<li>HTTP 拥有成熟的软硬件环境，应用的非常广泛，是互联网的基础设施；</li>
<li>HTTP 是无状态的，可以轻松实现集群化，扩展性能，但有时也需要用 Cookie 技术来实现“有状态”；</li>
<li>HTTP 是明文传输，数据完全肉眼可见，能够方便地研究分析，但也容易被窃听；</li>
<li>HTTP 是不安全的，无法验证通信双方的身份，也不能判断报文是否被窜改；</li>
<li>HTTP 的性能不算差，但不完全适应现在的互联网，还有很大的提升空间。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/04/08/http-12/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/2356874721.github.io/images/avatar.gif">
      <meta itemprop="name" content="sheriff">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="警长的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2356874721.github.io/2021/04/08/http-12/" class="post-title-link" itemprop="url">12 | HTTP有哪些特点？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-04-08 18:40:03 / 修改时间：21:05:16" itemprop="dateCreated datePublished" datetime="2021-04-08T18:40:03+08:00">2021-04-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/2356874721.github.io/categories/HTTP/" itemprop="url" rel="index"><span itemprop="name">HTTP</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今天主要说的是 HTTP 协议的特点，但不会讲它们的好坏，这些特点即有可能是优点，也有可能是缺点。</p>
<img src="/2356874721.github.io/2021/04/08/http-12/12-1.png" class>

<h3 id="灵活可扩展"><a href="#灵活可扩展" class="headerlink" title="灵活可扩展"></a>灵活可扩展</h3><p>首先， <strong>HTTP 协议是一个“灵活可扩展”的传输协议。</strong></p>
<p>HTTP 协议最初诞生的时候就比较简单，本着开放的精神只规定了报文的基本格式，比如用空格分隔单词，用换行分隔字段，“header+body”等，报文里的各个组成部分都没有做严格的语法语义限制，可以由开发者任意定制。</p>
<p>所以，HTTP 协议就随着互联网的发展一同成长起来了。在这个过程中，HTTP 协议逐渐增加了请求方法、版本号、状态码、头字段等特性。而 body 也不再限于文本形式的 TXT 或 HTML，而是能够传输图片、音频视频等任意数据，这些都是源于它的“灵活可扩展”的特点。</p>
<p>而那些 RFC 文档，实际上也可以理解为是对已有扩展的“承认和标准化”，实现了“从实践中来，到实践中去”的良性循环。</p>
<p>也正是因为这个特点，HTTP 才能在三十年的历史长河中“屹立不倒”，从最初的低速实验网络发展到现在的遍布全球的高速互联网，始终保持着旺盛的生命力。</p>
<h3 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h3><p>第二个特点， <strong>HTTP 协议是一个“可靠”的传输协议。</strong></p>
<p>这个特点显而易见，<strong>因为 HTTP 协议是基于 TCP/IP 的，而 TCP 本身是一个“可靠”的传输协议，所以 HTTP 自然也就继承了这个特性</strong>，能够在请求方和应答方之间“可靠”地传输数据。</p>
<p><em>不过我们必须正确地理解“可靠”的含义，HTTP 并不能 100% 保证数据一定能够发送到另一端，在网络繁忙、连接质量差等恶劣的环境下，也有可能收发失败。“可靠”只是向使用者提供了一个“承诺”，会在下层用多种手段“尽量”保证数据的完整送达。</em></p>
<p>当然，如果遇到光纤被意外挖断这样的极端情况，即使是神仙也不能发送成功。所以，“可靠”传输是指在网络基本正常的情况下数据收发必定成功，借用运维里的术语，大概就是“3 个 9”或者“4 个 9”的程度吧。</p>
<h3 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h3><p>第三个特点，<strong>HTTP 协议是一个应用层的协议。</strong></p>
<p>在 TCP/IP 诞生后的几十年里，虽然出现了许多的应用层协议，但它们都仅关注很小的应用领域，局限在很少的应用场景。例如 FTP 只能传输文件、SMTP 只能发送邮件、SSH 只能远程登录等，在<strong>通用的数据传输方面</strong>“完全不能打”。</p>
<p>所以 HTTP 凭借着可携带任意头字段和实体数据的报文结构，以及连接控制、缓存代理等方便易用的特性，一出现就“技压群雄”，迅速成为了应用层里的“明星”协议。<strong>只要不太苛求性能，HTTP 几乎可以传递一切东西，满足各种需求，称得上是一个“万能”的协议</strong>。</p>
<p>套用一个网上流行的段子，HTTP 完全可以用开玩笑的口吻说：“不要误会，我不是针对 FTP，我是说在座的应用层各位，都是垃圾。”</p>
<h3 id="请求-应答"><a href="#请求-应答" class="headerlink" title="请求 - 应答"></a>请求 - 应答</h3><p>第四个特点，<strong>HTTP 协议使用的是请求 - 应答通信模式。</strong></p>
<p>这个请求 - 应答模式是 HTTP 协议最根本的通信模型，通俗来讲就是“<strong>一发一收</strong>”“<strong>有来有去</strong>”，就像是写代码时的函数调用，只要填好请求头里的字段，“调用”后就会收到答复。</p>
<p>请求 - 应答模式也明确了 HTTP 协议里通信双方的定位，<strong>永远是请求方先发起连接和请求，是主动的，而应答方只有在收到请求后才能答复，是被动的，如果没有请求时不会有任何动作</strong>。</p>
<p>当然，<strong>请求方和应答方的角色也不是绝对的</strong>，在浏览器 - 服务器的场景里，通常服务器都是应答方，但如果将它用作代理连接后端服务器，那么它就可能同时扮演请求方和应答方的角色。</p>
<h3 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h3><p>第五个特点，<strong>HTTP 协议是无状态的</strong>。</p>
<p>这个所谓的“状态”应该怎么理解呢？<strong>“状态”其实就是客户端或者服务器里保存的一些数据或者标志</strong>，记录了通信过程中的一些变化信息。</p>
<p>你一定知道，<em>TCP 协议是有状态的，一开始处于 CLOSED 状态，连接成功后是 ESTABLISHED 状态，断开连接后是 FIN-WAIT 状态，最后又是 CLOSED 状态。</em></p>
<p><em>这些“状态”就需要 TCP 在内部用一些数据结构去维护，可以简单地想象成是个标志量，标记当前所处的状态，例如 0 是 CLOSED，2 是 ESTABLISHED 等等。</em></p>
<p>再来看 HTTP，那么对比一下 TCP 就看出来了，在整个协议里没有规定任何的“状态”，客户端和服务器永远是处在一种“<strong>无知</strong>”的状态。建立连接前两者互不知情，每次收发的报文也都是互相独立的，没有任何的联系。收发报文也不会对客户端或服务器产生任何影响，连接后也不会要求保存任何信息。</p>
<p><strong>“无状态”形象地来说就是“没有记忆能力”</strong>。<em>比如，浏览器发了一个请求，说“我是小明，请给我 A 文件。”，服务器收到报文后就会检查一下权限，看小明确实可以访问 A 文件，于是把文件发回给浏览器。接着浏览器还想要 B 文件，但服务器不会记录刚才的请求状态，不知道第二个请求和第一个请求是同一个浏览器发来的，所以浏览器必须还得重复一次自己的身份才行：“我是刚才的小明，请再给我 B 文件。”</em></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol>
<li>HTTP 是灵活可扩展的，可以任意添加头字段实现任意功能；</li>
<li>HTTP 是可靠传输协议，基于 TCP/IP 协议“尽量”保证数据的送达；</li>
<li>HTTP 是应用层协议，比 FTP、SSH 等更通用功能更多，能够传输任意数据；</li>
<li>HTTP 使用了请求 - 应答模式，客户端主动发起请求，服务器被动回复请求；</li>
<li>HTTP 本质上是无状态的，每个请求都是互相独立、毫无关联的，协议不要求客户端或服务器记录请求相关的信息。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/04/08/http-11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/2356874721.github.io/images/avatar.gif">
      <meta itemprop="name" content="sheriff">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="警长的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2356874721.github.io/2021/04/08/http-11/" class="post-title-link" itemprop="url">11 | 响应状态码该怎么用？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-04-08 18:12:30 / 修改时间：21:05:16" itemprop="dateCreated datePublished" datetime="2021-04-08T18:12:30+08:00">2021-04-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/2356874721.github.io/categories/HTTP/" itemprop="url" rel="index"><span itemprop="name">HTTP</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>前面，我们学习了 HTTP 报文里请求行的组成部分，包括请求方法和 URI。有了请求行，加上后面的头字段就形成了请求头，可以通过 TCP/IP 协议发送给服务器。</p>
<p>服务器收到请求报文，解析后需要进行处理，具体的业务逻辑多种多样，但最后必定是拼出一个响应报文发回客户端。</p>
<p><strong>响应报文由响应头加响应体数据组成，响应头又由状态行和头字段构成。</strong></p>
<p>我们先来复习一下状态行的结构，有三部分：</p>
<img src="/2356874721.github.io/2021/04/08/http-11/11-1.png" class>

<p>开头的 Version 部分是 HTTP 协议的版本号，通常是 HTTP/1.1，用处不是很大。后面的 Reason 部分是原因短语，是状态码的简短文字描述，例如“OK”“Not Found”等等，也可以自定义。但它只是为了兼容早期的文本客户端而存在，提供的信息很有限，目前的大多数客户端都会忽略它。</p>
<p>所以，状态行里有用的就只剩下中间的<strong>状态码（Status Code）</strong>了。它是一个<strong>十进制数字</strong>，以代码的形式表示服务器对请求的处理结果，就像我们通常编写程序时函数返回的错误码一样。</p>
<p>不过你要注意，<strong>它的名字是“状态码”而不是“错误码”</strong>。也就是说，<strong>它的含义不仅是错误，更重要的意义在于表达 HTTP 数据处理的“状态”</strong>，客户端可以依据代码适时转换处理状态，例如继续发送请求、切换协议，重定向跳转等，有那么点 TCP 状态转换的意思。</p>
<h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p>目前 RFC 标准里规定的状态码是三位数，所以取值范围就是从 000 到 999。但如果把代码简单地从 000 开始顺序编下去就显得有点太“low”，不灵活、不利于扩展，所以状态码也被设计成有一定的格式。</p>
<p>RFC 标准把状态码分成了<strong>五类</strong>，用数字的第一位表示分类，而 0<del>99 不用，这样状态码的实际可用范围就大大缩小了，由 000</del>999 变成了 <strong>100~599</strong>。</p>
<p>这五类的具体含义是：</p>
<ul>
<li>1××：提示信息，表示目前是协议处理的中间状态，还需要后续的操作；</li>
<li>2××：成功，报文已经收到并被正确处理；</li>
<li>3××：重定向，资源位置发生变动，需要客户端重新发送请求；</li>
<li>4××：客户端错误，请求报文有误，服务器无法处理；</li>
<li>5××：服务器错误，服务器在处理请求时内部发生了错误。</li>
</ul>
<p>在 HTTP 协议中，<strong>正确地理解并应用这些状态码不是客户端或服务器单方的责任，而是双方共同的责任。</strong></p>
<p><strong>客户端作为请求的发起方，获取响应报文后，需要通过状态码知道请求是否被正确处理，是否要再次发送请求，如果出错了原因又是什么。这样才能进行下一步的动作，要么发送新请求，要么改正错误重发请求。</strong></p>
<p><strong>服务器端作为请求的接收方，也应该很好地运用状态码。在处理请求时，选择最恰当的状态码回复客户端，告知客户端处理的结果，指示客户端下一步应该如何行动。特别是在出错的时候，尽量不要简单地返 400、500 这样意思含糊不清的状态码。</strong></p>
<h3 id="1××"><a href="#1××" class="headerlink" title="1××"></a>1××</h3><p>1××类状态码属于<strong>提示信息</strong>，<strong>是协议处理的中间状态</strong>，实际能够用到的时候很少。</p>
<h4 id="101"><a href="#101" class="headerlink" title="101"></a>101</h4><p>我们偶尔能够见到的是“<strong>101 Switching Protocols”</strong>。<strong>它的意思是客户端使用 Upgrade 头字段，要求在 HTTP 协议的基础上改成其他的协议继续通信，比如 WebSocket</strong>。而如果服务器也同意变更协议，就会发送状态码 101，但这之后的数据传输就不会再使用 HTTP 了。</p>
<h3 id="2××"><a href="#2××" class="headerlink" title="2××"></a>2××</h3><p>2××类状态码<strong>表示服务器收到并成功处理了客户端的请求</strong>，这也是客户端最愿意看到的状态码。</p>
<h4 id="200"><a href="#200" class="headerlink" title="200"></a>200</h4><p>“<strong>200 OK</strong>”是最常见的成功状态码，表示一切正常，服务器如客户端所期望的那样返回了处理结果，如果是非 HEAD 请求，通常在响应头后都会有 body 数据。</p>
<h4 id="204"><a href="#204" class="headerlink" title="204"></a>204</h4><p>“<strong>204 No Content</strong>”是另一个很常见的成功状态码，它的含义与“200 OK”基本相同，但<strong>响应头后没有 body 数据</strong>。所以对于 Web 服务器来说，正确地区分 200 和 204 是很必要的。</p>
<h4 id="206"><a href="#206" class="headerlink" title="206"></a>206</h4><p>“<strong>206 Partial Content</strong>”是 <strong>HTTP 分块下载或断点续传的基础</strong>，在客户端发送“范围请求”、要求获取资源的部分数据时出现，它与 200 一样，也是服务器成功处理了请求，但 <strong>body 里的数据不是资源的全部，而是其中的一部分</strong>。</p>
<p>状态码 206 通常还会伴随着头字段“<strong>Content-Range</strong>”，<strong>表示响应报文里 body 数据的具体范围</strong>，供客户端确认<strong>，例如“Content-Range: bytes 0-99/2000”，意思是此次获取的是总计 2000 个字节的前 100 个字节。</strong></p>
<h3 id="3××"><a href="#3××" class="headerlink" title="3××"></a>3××</h3><p>3××类状态码表示客户端请求的资源发生了变动，客户端必须用新的 URI 重新发送请求获取资源，也就是通常所说的“重定向”，包括著名的 301、302 跳转。</p>
<h4 id="301"><a href="#301" class="headerlink" title="301"></a>301</h4><p>“301 Moved Permanently”俗称“<strong>永久重定向</strong>”，<strong>含义是此次请求的资源已经不存在了，需要改用新的 URI 再次访问</strong>。</p>
<h4 id="302"><a href="#302" class="headerlink" title="302"></a>302</h4><p>与它类似的是“302 Found”，曾经的描述短语是“Moved Temporarily”，俗称“临时重定向”，<strong>意思是请求的资源还在，但需要暂时用另一个 URI 来访问。</strong></p>
<p>301 和 302 都会在响应头里使用字段 <strong>Location 指明后续要跳转的 URI</strong>，最终的效果很相似，浏览器都会重定向到新的 URI。<strong>两者的根本区别在于语义，一个是“永久”，一个是“临时”，所以在场景、用法上差距很大</strong>。</p>
<p><em>比如，你的网站升级到了 HTTPS，原来的 HTTP 不打算用了，这就是“永久”的，所以要配置 301 跳转，把所有的 HTTP 流量都切换到 HTTPS。</em></p>
<p><em>再比如，今天夜里网站后台要系统维护，服务暂时不可用，这就属于“临时”的，可以配置成 302 跳转，把流量临时切换到一个静态通知页面，浏览器看到这个 302 就知道这只是暂时的情况，<strong>不会做缓存优化</strong>，第二天还会访问原来的地址。</em></p>
<h4 id="304"><a href="#304" class="headerlink" title="304"></a>304</h4><p>“304 Not Modified” 是一个比较有意思的状态码，它<strong>用于 If-Modified-Since 等条件请求，表示资源未修改，用于缓存控制</strong>。它不具有通常的跳转含义，但可以理解成“<strong>重定向已到缓存的文件”</strong>（即“<strong>缓存重定向</strong>”）。</p>
<h3 id="4××"><a href="#4××" class="headerlink" title="4××"></a>4××</h3><p>4××类状态码表示<strong>客户端发送的请求报文有误</strong>，服务器无法处理，它就是真正的“错误码”含义了。</p>
<h4 id="400"><a href="#400" class="headerlink" title="400"></a>400</h4><p>“400 Bad Request”是一个通用的错误码，表示请求报文有错误，但具体是数据格式错误、缺少请求头还是 URI 超长它没有明确说，只是一个笼统的错误，客户端看到 400 只会是“一头雾水”“不知所措”。所以，在开发 Web 应用时应当尽量避免给客户端返回 400，而是要用其他更有明确含义的状态码。</p>
<h4 id="403"><a href="#403" class="headerlink" title="403"></a>403</h4><p>“403 Forbidden”实际上不是客户端的请求出错，而是表示<strong>服务器禁止访问资源</strong>。原因可能多种多样，例如信息敏感、法律禁止等，如果服务器友好一点，可以在 body 里详细说明拒绝请求的原因，不过现实中通常都是直接给一个“闭门羹”。</p>
<h4 id="404"><a href="#404" class="headerlink" title="404"></a>404</h4><p>“404 Not Found”可能是我们最常看见也是最不愿意看到的一个状态码，它的原意是<strong>资源在本服务器上未找到</strong>，所以无法提供给客户端。但现在已经被“用滥了”，只要服务器“不高兴”就可以给出个 404，而我们也无从得知后面到底是真的未找到，还是有什么别的原因，某种程度上它比 403 还要令人讨厌。</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul>
<li>405 Method Not Allowed：不允许使用某些方法操作资源，例如不允许 POST 只能 GET；</li>
<li>406 Not Acceptable：资源无法满足客户端请求的条件，例如请求中文但只有英文；</li>
<li>408 Request Timeout：请求超时，服务器等待了过长的时间；</li>
<li>409 Conflict：多个请求发生了冲突，可以理解为多线程并发时的竞态；</li>
<li>413 Request Entity Too Large：请求报文里的 body 太大；</li>
<li>414 Request-URI Too Long：请求行里的 URI 太大；</li>
<li>429 Too Many Requests：客户端发送了太多的请求，通常是由于服务器的限连策略；</li>
<li>431 Request Header Fields Too Large：请求头某个字段或总体太大；</li>
</ul>
<h3 id="5xx"><a href="#5xx" class="headerlink" title="5xx"></a>5xx</h3><p>5××类状态码表示客户端请求报文正确，但<strong>服务器在处理时内部发生了错误</strong>，无法返回应有的响应数据，是服务器端的“错误码”。</p>
<h4 id="500"><a href="#500" class="headerlink" title="500"></a>500</h4><p>“500 Internal Server Error”与 400 类似，也是一个<strong>通用的错误码，服务器究竟发生了什么错误我们是不知道的</strong>。<strong>不过对于服务器来说这应该算是好事，通常不应该把服务器内部的详细信息，例如出错的函数调用栈告诉外界。虽然不利于调试，但能够防止黑客的窥探或者分析</strong>。</p>
<h4 id="501"><a href="#501" class="headerlink" title="501"></a>501</h4><p>“501 Not Implemented”表示<strong>客户端请求的功能还不支持</strong>，这个错误码比 500 要“温和”一些，和“即将开业，敬请期待”的意思差不多，不过具体什么时候“开业”就不好说了。</p>
<h4 id="502"><a href="#502" class="headerlink" title="502"></a>502</h4><p>“502 Bad Gateway”通常是<strong>服务器作为网关或者代理时返回的错误码</strong>，表示<strong>服务器自身工作正常，访问后端服务器时发生了错误</strong>，但具体的错误原因也是不知道的。</p>
<h4 id="503"><a href="#503" class="headerlink" title="503"></a>503</h4><p>“503 Service Unavailable”<strong>表示服务器当前很忙，暂时无法响应服务</strong>，我们上网时有时候遇到的“网络服务正忙，请稍后重试”的提示信息就是状态码 503。</p>
<p>503 是一个“临时”的状态，很可能过几秒钟后服务器就不那么忙了，可以继续提供服务，所以 503 响应报文里通常还会有一个“Retry-After”字段，指示客户端可以在多久以后再次尝试发送请求。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol>
<li>状态码在响应报文里表示了服务器对请求的处理结果；</li>
<li>状态码后的原因短语是简单的文字描述，可以自定义；</li>
<li>状态码是十进制的三位数，分为五类，从 100 到 599；</li>
<li>2××类状态码表示成功，常用的有 200、204、206；</li>
<li>3××类状态码表示重定向，常用的有 301、302、304；</li>
<li>4××类状态码表示客户端错误，常用的有 400、403、404；</li>
<li>5××类状态码表示服务器错误，常用的有 500、501、502、503。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/04/01/http-10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/2356874721.github.io/images/avatar.gif">
      <meta itemprop="name" content="sheriff">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="警长的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2356874721.github.io/2021/04/01/http-10/" class="post-title-link" itemprop="url">10 | 你能写出正确的网址吗？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-01 18:36:09" itemprop="dateCreated datePublished" datetime="2021-04-01T18:36:09+08:00">2021-04-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-08 21:05:16" itemprop="dateModified" datetime="2021-04-08T21:05:16+08:00">2021-04-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/2356874721.github.io/categories/HTTP/" itemprop="url" rel="index"><span itemprop="name">HTTP</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>应该用什么来标记服务器上的资源呢？怎么区分“这个”资源和“那个”资源呢？</p>
<p>你一定已经知道了，用的是 <strong>URI</strong>，也就是<strong>统一资源标识符</strong>（Uniform Resource Identifier）。因为它经常出现在浏览器的地址栏里，所以俗称为“网络地址”，简称“网址”。</p>
<p><strong>严格地说，URI 不完全等同于网址，它包含有 URL 和 URN 两个部分</strong>，在 HTTP 世界里用的网址实际上是 <strong>URL——统一资源定位符</strong>（Uniform Resource Locator）。但因为 URL 实在是太普及了，所以常常把这两者简单地视为相等。</p>
<p>URI 非常重要，要搞懂 HTTP 甚至网络应用，就必须搞懂 URI。</p>
<h3 id="URI-的格式"><a href="#URI-的格式" class="headerlink" title="URI 的格式"></a>URI 的格式</h3><p>不知道你平常上网的时候有没有关注过地址栏里的那一长串字符，有的比较简短，有的则一行都显示不下，有的意思大概能看明白，而有的则带着各种怪字符，有如“天书”。</p>
<p>其实只要你弄清楚了 URI 的格式，就能够轻易地“破解”这些难懂的“天书”了。</p>
<p>URI 本质上是一个字符串，这个字符串的<strong>作用是唯一地标记资源的位置或者名字</strong>。</p>
<p>这里我要提醒你注意，<strong>它不仅能够标记万维网的资源，也可以标记其他的，如邮件系统、本地文件系统等任意资源</strong>。而“资源”既可以是存在磁盘上的静态文本、页面数据，也可以是由 Java、PHP 提供的动态服务。</p>
<p>下面的这张图显示了 URI 最常用的形式，由 scheme、host:port、path 和 query 四个部分组成，但有的部分可以视情况省略。</p>


<h3 id="URI-的基本组成"><a href="#URI-的基本组成" class="headerlink" title="URI 的基本组成"></a>URI 的基本组成</h3><p>URI 第一个组成部分叫 <strong>scheme</strong>，翻译成中文叫“方案名”或者“<strong>协议名</strong>”，<strong>表示资源应该使用哪种协议来访问</strong>。</p>
<p>最常见的当然就是“<strong>http</strong>”了，表示使用 HTTP 协议。另外还有“<strong>https</strong>”，表示使用经过加密、安全的 HTTPS 协议。此外还有其他不是很常见的 scheme，例如 <strong>ftp、ldap、file、news</strong> 等。</p>
<p>浏览器或者你的应用程序看到 URI 里的 scheme，就知道下一步该怎么走了，会调用相应的 HTTP 或者 HTTPS 下层 API。显然，如果一个 URI 没有提供 scheme，即使后面的地址再完善，也是无法处理的。</p>
<p>在 scheme 之后，<strong>必须是三个特定的字符“://”</strong>，它把 scheme 和后面的部分分离开。</p>
<p>实话实说，这个设计非常的怪异，URI 的创造者蒂姆·伯纳斯 - 李也曾经私下承认“://”并非必要，当初有些“过于草率”了。不过这个设计已经有了三十年的历史，不管我们愿意不愿意，只能接受。</p>
<p>在“://”之后，是被称为“<strong>authority</strong>”的部分，表示<strong>资源所在的主机名</strong>，通常的形式是“<strong>host:port</strong>”，即<strong>主机名加端口号</strong>。</p>
<p><strong>主机名可以是 IP 地址或者域名的形式，必须要有</strong>，否则浏览器就会找不到服务器。<strong>但端口号有时可以省略</strong>，浏览器等客户端会依据 scheme 使用默认的端口号，例如 <strong>HTTP 的默认端口号是 80，HTTPS 的默认端口号是 443</strong>。</p>
<p>有了<strong>协议名</strong>和<strong>主机地址、端口号</strong>，再加上后面标记资源所在位置的 <strong>path</strong>，浏览器就可以连接服务器访问资源了。</p>
<p>URI 里 path 采用了类似文件系统“目录”“路径”的表示方式，因为早期互联网上的计算机多是 UNIX 系统，所以采用了 UNIX 的“/”风格。其实也比较好理解，它与 scheme 后面的“://”是一致的。</p>
<p><strong><u>这里我也要再次提醒你注意，URI 的 path 部分必须以“/”开始，也就是必须包含“/”，不要把“/”误认为属于前面 authority。</u></strong></p>
<p>说了这么多“理论”，来看几个实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//nginx.org</span></span><br><span class="line">http:<span class="comment">//www.chrono.com:8080/11-1</span></span><br><span class="line">https:<span class="comment">//tools.ietf.org/html/rfc7230</span></span><br><span class="line">file:<span class="comment">///D:/http_study/www/</span></span><br></pre></td></tr></table></figure>

<p>第一个 URI 算是最简单的了，协议名是“http”，主机名是“nginx.org”，端口号省略，所以是默认的 80，而路径部分也被省略了，<strong>默认就是一个“/”，表示根目录</strong>。</p>
<p>第二个 URI 是在实验环境里这次课程的专用 URI，主机名是“<a href="http://www.chrono.com”，端口号是" target="_blank" rel="noopener">www.chrono.com”，端口号是</a> 8080，后面的路径是“/11-1”。</p>
<p>第三个是 HTTP 协议标准文档 RFC7230 的 URI，主机名是“tools.ietf.org”，路径是“/html/rfc7230”。</p>
<p>最后一个 URI 要注意了，它的协议名不是“http”，而是“<strong>file</strong>”，表示这是<strong>本地文件</strong>，而后面居然有<strong>三个斜杠</strong>，这是怎么回事？如果你刚才仔细听了 scheme 的介绍就能明白，这三个斜杠里的<strong>前两个属于 URI 特殊分隔符“://”</strong>，<strong>然后后面的“/D:/http_study/www/”是路径，而中间的主机名被“省略”了</strong>。这实际上是 <strong>file 类型 URI 的“特例”，它允许省略主机名，默认是本机 localhost</strong>。</p>
<p><strong><u>但对于 HTTP 或 HTTPS 这样的网络通信协议，主机名是绝对不能省略的。原因之前也说了，会导致浏览器无法找到服务器。</u></strong></p>
<h3 id="URI-的查询参数"><a href="#URI-的查询参数" class="headerlink" title="URI 的查询参数"></a>URI 的查询参数</h3><p>使用“协议名 + 主机名 + 路径”的方式，已经可以精确定位网络上的任何资源了。但这还不够，很多时候我们还想在操作资源的时候附加一些额外的修饰参数。</p>
<p>仅用“协议名 + 主机名 + 路径”的方式是无法适应这些场景的，所以 URI 后面还有一个“<strong>query</strong>”部分，<strong>它在 path 之后，用一个“?”开始，但不包含“?”</strong>，<strong>表示对资源附加的额外要求</strong>。这是个很形象的符号，比“://”要好的多，很明显地表示了“查询”的含义。</p>
<p>查询参数 query 有一套自己的格式，是多个“key=value”的字符串，这些 <strong>KV</strong> 值用字符“<strong>&amp;</strong>”连接，浏览器和服务器都可以按照这个格式把长串的查询参数解析成可理解的字典或关联数组形式。</p>
<h3 id="URI-的完整格式"><a href="#URI-的完整格式" class="headerlink" title="URI 的完整格式"></a>URI 的完整格式</h3><p>讲完了 query 参数，URI 就算完整了，HTTP 协议里用到的 URI 绝大多数都是这种形式。不过必须要说的是，URI 还有一个“真正”的完整形态，如下图所示。</p>


<p>这个“真正”形态比基本形态多了两部分。</p>
<p>第一个多出的部分是协议名之后、主机名之前的<strong>身份信息</strong>“user:passwd@”，表示登录主机时的用户名和密码，但现在已经不推荐使用这种形式了（RFC7230），因为它把敏感信息以明文形式暴露出来，存在严重的安全隐患。</p>
<p>第二个多出的部分是查询参数后的<strong>片段标识符</strong>“#fragment”，它是 URI 所定位的资源内部的一个“锚点”或者说是“标签”，浏览器可以在获取资源后直接跳转到它指示的位置。</p>
<h3 id="URI-的编码"><a href="#URI-的编码" class="headerlink" title="URI 的编码"></a>URI 的编码</h3><p>刚才我们看到了，在 URI 里只能使用 ASCII 码，但如果要在 URI 里使用英语以外的汉语、日语等其他语言该怎么办呢？还有，某些特殊的 URI，会在 path、query 里出现“@&amp;?”等起界定符作用的字符，会导致 URI 解析错误，这时又该怎么办呢？</p>
<p>所以，URI 引入了编码机制，对于 ASCII 码以外的字符集和特殊字符做一个特殊的操作，把它们转换成与 URI 语义不冲突的形式。这在 RFC 规范里称为“escape”和“unescape”，俗称“<strong>转义</strong>”。</p>
<p><strong>URI 转义的规则有点“简单粗暴”，直接把非 ASCII 码或特殊字符转换成十六进制字节值，然后前面再加上一个“%”。</strong></p>
<p>例如，空格被转义成“%20”，“?”被转义成“%3F”。而中文、日文等则通常使用 UTF-8 编码后再转义，例如“银河”会被转义成“%E9%93%B6%E6%B2%B3”。</p>
<p>有了这个编码规则后，URI 就更加完美了，可以支持任意的字符集用任何语言来标记资源。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol>
<li>URI 是用来唯一标记服务器上资源的一个字符串，通常也称为 URL；</li>
<li>URI 通常由 scheme、host:port、path 和 query 四个部分组成，有的可以省略；</li>
<li>scheme 叫“方案名”或者“协议名”，表示资源应该使用哪种协议来访问；</li>
<li>“host:port”表示资源所在的主机名和端口号；</li>
<li>path 标记资源所在的位置；</li>
<li>query 表示对资源附加的额外要求；</li>
<li>在 URI 里对“@&amp;/”等特殊字符和汉字必须要做编码，否则服务器收到 HTTP 报文后会无法正确处理。</li>
</ol>
<h3 id="课下作业"><a href="#课下作业" class="headerlink" title="课下作业"></a>课下作业</h3><ol>
<li><p>HTTP 协议允许在在请求行里使用完整的 URI，但为什么浏览器没有这么做呢？</p>
<p>因为在请求头的字段中都有，没必要重复</p>
</li>
<li><p>URI 的查询参数和头字段很相似，都是 key-value 形式，都可以任意自定义，那么它们在使用时该如何区别呢？</p>
<p>头字段是针对这次请求的，query是针对访问的资源</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/31/http-09/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/2356874721.github.io/images/avatar.gif">
      <meta itemprop="name" content="sheriff">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="警长的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2356874721.github.io/2021/03/31/http-09/" class="post-title-link" itemprop="url">09 | 应该如何理解请求方法？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-31 18:16:50" itemprop="dateCreated datePublished" datetime="2021-03-31T18:16:50+08:00">2021-03-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-08 21:05:16" itemprop="dateModified" datetime="2021-04-08T21:05:16+08:00">2021-04-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/2356874721.github.io/categories/HTTP/" itemprop="url" rel="index"><span itemprop="name">HTTP</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>HTTP 的报文结构是由 header+body 构成，请求头里有请求方法和请求目标，响应头里有状态码和原因短语，今天要说的就是请求头里的请求方法。</p>
<h3 id="标准请求方法"><a href="#标准请求方法" class="headerlink" title="标准请求方法"></a>标准请求方法</h3><p>HTTP 协议里为什么要有“请求方法”这个东西呢？</p>
<p>这就要从 HTTP 协议设计时的定位说起了。还记得吗？蒂姆·伯纳斯 - 李最初设想的是要用 HTTP 协议构建一个超链接文档系统，使用 URI 来定位这些文档，也就是资源。那么，该怎么在协议里操作这些资源呢？</p>
<p>很显然，需要有某种“动作的指示”，告诉操作这些资源的方式。所以，就这么出现了“请求方法”。它的<strong>实际含义就是客户端发出了一个“动作指令”，要求服务器端对 URI 定位的资源执行这个动作</strong>。</p>
<p>目前 HTTP/1.1 规定了八种方法，单词都必须是大写的形式，我先简单地列把它们列出来，后面再详细讲解。</p>
<ol>
<li>GET：获取资源，可以理解为读取或者下载数据；</li>
<li>HEAD：获取资源的元信息；</li>
<li>POST：向资源提交数据，相当于写入或上传数据；</li>
<li>PUT：类似 POST；</li>
<li>DELETE：删除资源；</li>
<li>CONNECT：建立特殊的连接隧道；</li>
<li>OPTIONS：列出可对资源实行的方法；</li>
<li>TRACE：追踪请求 - 响应的传输路径。</li>
</ol>
<img src="/2356874721.github.io/2021/03/31/http-09/9-1.jpeg" class>

<p>看看这些方法，是不是有点像对文件或数据库的“增删改查”操作，只不过这些动作操作的目标不是本地资源，而是远程服务器上的资源，所以只能由客户端“请求”或者“指示”服务器来完成。</p>
<p>既然请求方法是一个“指示”，那么客户端自然就没有决定权，<strong>服务器掌控着所有资源，也就有绝对的决策权力</strong>。<strong>它收到 HTTP 请求报文后，看到里面的请求方法，可以执行也可以拒绝，或者改变动作的含义，毕竟 HTTP 是一个“协议”，两边都要“商量着来”</strong>。</p>
<p>比如，你发起了一个 GET 请求，想获取“/orders”这个文件，但这个文件保密级别比较高，不是谁都能看的，服务器就可以有如下的几种响应方式：</p>
<ol>
<li>假装这个文件不存在，直接返回一个 404 Not found 报文；</li>
<li>稍微友好一点，明确告诉你有这个文件，但不允许访问，返回一个 403 Forbidden；</li>
<li>再宽松一些，返回 405 Method Not Allowed，然后用 Allow 头告诉你可以用 HEAD 方法获取文件的元信息。</li>
</ol>
<h3 id="GET-HEAD"><a href="#GET-HEAD" class="headerlink" title="GET/HEAD"></a>GET/HEAD</h3><p>GET 方法应该是 HTTP 协议里最知名的请求方法了，也应该是用的最多的，自 0.9 版出现并一直被保留至今，是名副其实的“元老”。它的含义是<strong>请求从服务器获取资源</strong>，这个资源既可以是静态的文本、页面、图片、视频，也可以是由 PHP、Java 动态生成的页面或者其他格式的数据。。</p>
<p>HEAD 方法与 GET 方法类似，也是请求从服务器获取资源，服务器的处理机制也是一样的，<strong>但服务器不会返回请求的实体数据，只会传回响应头，也就是资源的“元信息”</strong>。HEAD 方法可以看做是 GET 方法的一个“简化版”或者“轻量版”。因为它的响应头与 GET 完全相同，所以<strong>可以用在很多并不真正需要资源的场合，避免传输 body 数据的浪费</strong>。比如，想要检查一个文件是否存在，只要发个 HEAD 请求就可以了，没有必要用 GET 把整个文件都取下来。再比如，要检查文件是否有最新版本，同样也应该用 HEAD，服务器会在响应头里把文件的修改时间传回来。</p>
<h3 id="POST-PUT"><a href="#POST-PUT" class="headerlink" title="POST/PUT"></a>POST/PUT</h3><p>GET 和 HEAD 方法是从服务器获取数据，而 POST 和 PUT 方法则是相反操作，<strong>向 URI 指定的资源提交数据，数据就放在报文的 body 里</strong>。</p>
<p>POST 也是一个经常用到的请求方法，使用频率应该是仅次于 GET，应用的场景也非常多，只要向服务器发送数据，用的大多数都是 POST。</p>
<p>PUT 的作用与 POST 类似，也可以向服务器提交数据，但与 POST 存在微妙的不同，<strong>通常 POST 表示的是“新建”“create”的含义，而 PUT 则是“修改”“update”的含义</strong>。</p>
<p>在实际应用中，PUT 用到的比较少。而且，因为它与 POST 的语义、功能太过近似，有的服务器甚至就直接禁止使用 PUT 方法，只用 POST 方法上传数据。</p>
<h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><p>DELETE 方法<strong>指示服务器删除资源</strong>，因为这个动作危险性太大，所以通常服务器不会执行真正的删除操作，而是对资源做一个删除标记。当然，更多的时候服务器就直接不处理 DELETE 请求。</p>
<h3 id="CONNECT"><a href="#CONNECT" class="headerlink" title="CONNECT"></a>CONNECT</h3><p>CONNECT 是一个比较特殊的方法，<strong>要求服务器为客户端和另一台远程服务器建立一条特殊的连接隧道，这时 Web 服务器在中间充当了代理的角色</strong>。</p>
<h3 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h3><p>OPTIONS 方法<strong>要求服务器列出可对资源实行的操作方法，在响应头的 Allow 字段里返回</strong>。它的功能很有限，用处也不大，有的服务器（例如 Nginx）干脆就没有实现对它的支持。</p>
<h3 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h3><p>TRACE 方法<strong>多用于对 HTTP 链路的测试或诊断</strong>，可以显示出请求 - 响应的传输路径。它的本意是好的，但存在漏洞，会泄漏网站的信息，所以 Web 服务器通常也是禁止使用。</p>
<h3 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h3><p>虽然 HTTP/1.1 里规定了八种请求方法，但它并没有限制我们只能用这八种方法，这也体现了 HTTP 协议良好的扩展性，我们可以任意添加请求动作，只要请求方和响应方都能理解就行。</p>
<p>此外，还有一些得到了实际应用的请求方法（WebDAV），例如 MKCOL、COPY、MOVE、LOCK、UNLOCK、PATCH 等。如果有合适的场景，你也可以把它们应用到自己的系统里，比如用 LOCK 方法锁定资源暂时不允许修改，或者使用 PATCH 方法给资源打个小补丁，部分更新数据。但因为这些方法是非标准的，所以需要为客户端和服务器编写额外的代码才能添加支持。</p>
<p>当然了，你也完全可以根据实际需求，自己发明新的方法，比如“PULL”拉取某些资源到本地，“PURGE”清理某个目录下的所有缓存数据。</p>
<h3 id="安全与幂等"><a href="#安全与幂等" class="headerlink" title="安全与幂等"></a>安全与幂等</h3><p>关于请求方法还有两个面试时有可能会问到、比较重要的概念：安全与幂等。</p>
<p><strong>在 HTTP 协议里，所谓的“安全”是指请求方法不会“破坏”服务器上的资源，即不会对服务器上的资源造成实质的修改。</strong></p>
<p>按照这个定义，<strong>只有 GET 和 HEAD 方法是“安全”的</strong>，因为它们是“只读”操作，只要服务器不故意曲解请求方法的处理方式，无论 GET 和 HEAD 操作多少次，服务器上的数据都是“安全的”。</p>
<p>而 <strong>POST/PUT/DELETE 操作会修改服务器上的资源，增加或删除数据，所以是“不安全”的。</strong></p>
<p>所谓的“<strong>幂等</strong>”实际上是一个数学用语，被借用到了 HTTP 协议里，<strong>意思是多次执行相同的操作，结果也都是相同的，即多次“幂”后结果“相等”。</strong></p>
<p>很显然，<strong>GET 和 HEAD 既是安全的也是幂等的</strong>，<strong>DELETE</strong> 可以多次删除同一个资源，效果都是“资源不存在”，所以也是幂等的。</p>
<p>按照 RFC 里的语义，<strong>POST 是“新增或提交数据”，多次提交数据会创建多个资源，所以不是幂等的</strong>；<strong>而 PUT 是“替换或更新数据”，多次更新一个资源，资源还是会第一次更新的状态，所以是幂等的</strong>。</p>
<p>我对你的建议是，你可以对比一下 SQL 来加深理解：<strong>把 POST 理解成 INSERT，把 PUT 理解成 UPDATE，这样就很清楚了。多次 INSERT 会添加多条记录，而多次 UPDATE 只操作一条记录，而且效果相同</strong>。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol>
<li>请求方法是客户端发出的、要求服务器执行的、对资源的一种操作；</li>
<li>请求方法是对服务器的“指示”，真正应如何处理由服务器来决定；</li>
<li>最常用的请求方法是 GET 和 POST，分别是获取数据和发送数据；</li>
<li>HEAD 方法是轻量级的 GET，用来获取资源的元信息；</li>
<li>PUT 基本上是 POST 的同义词，多用于更新数据；</li>
<li>“安全”与“幂等”是描述请求方法的两个重要属性，具有理论指导意义，可以帮助我们设计系统。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/2356874721.github.io/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/2356874721.github.io/page/6/">6</a><a class="extend next" rel="next" href="/2356874721.github.io/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">sheriff</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/2356874721.github.io/archives/">
        
          <span class="site-state-item-count">53</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/2356874721.github.io/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/2356874721.github.io/tags/">
          
        <span class="site-state-item-count">52</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sheriff</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/2356874721.github.io/lib/anime.min.js"></script>
  <script src="/2356874721.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/2356874721.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/2356874721.github.io/js/utils.js"></script>

<script src="/2356874721.github.io/js/motion.js"></script>


<script src="/2356874721.github.io/js/schemes/pisces.js"></script>


<script src="/2356874721.github.io/js/next-boot.js"></script>




  















  

  

</body>
</html>
